{
  "Create views that update automatically when data changes": "自動的にデータ変更を更新するビューを作成",
  "Store temporary data for the user interface": "ユーザーインターフェースのための一時的なデータ保存",
  "Re-run functions when data changes": "データ変更時の再実行",
  "Store persistent data": "永続データを格納",
  "Let users log in with passwords, Facebook, Google, GitHub, etc.": "SNSを利用したソーシャルログイン",
  "Call server functions from the client": "クライアントからの実行",
  "Sync part of your data to the client": "クライアント側へのデータ同期",
  "Control when and where your code runs": "スクリプトの実行をコントロール",
  "Choose from thousands of community packages": "コミュニティパッケージ",
  "The web was originally designed to work in the same way that mainframes worked in the 70s. The application server rendered a screen and sent it over the network to a dumb terminal. Whenever the user did anything, that server rerendered a whole new screen. This model served the Web well for over a decade. It gave rise to LAMP, Rails, Django, PHP.": "Webはもともとは70年代のメインフレームと同じように動くように設計されました。アプリケーションサーバが描画した画面をネットワーク経由で端末に表示させます。ユーザが何かしたらサーバが画面全体を再描画します。このモデルは10年にわたってWebに残りました。そのため、LAMPやRailsやDjangoやPHPが伸びたのです。",
  "But the best teams, with the biggest budgets and the longest schedules, now build applications in JavaScript that run on the client. These apps have stellar interfaces. They don&apos;t reload pages. They are reactive: changes from any client immediately appear on everyone&apos;s screen.": "しかし、優れたチームが大きな予算と長い開発期間をかけて、今ではクライアントで動作するJavaScriptアプリケーションを開発するようになりました。そのアプリケーションはすばらしいインタフェースを備えました。ページをリロードする必要がないのです。それらはリアクティブであり、あるクライアントでの変更が瞬時にすべての人の画面に反映されます。",
  "They&apos;ve built them the hard way. Meteor makes it an order of magnitude simpler, and a lot more fun. You can build a complete application in a weekend, or a sufficiently caffeinated hackathon. No longer do you need to provision server resources, or deploy API endpoints in the cloud, or manage a database, or wrangle an ORM layer, or swap back and forth between JavaScript and Ruby, or broadcast data invalidations to clients.": "開発者はとても苦労して作りあげたことでしょう。Meteorはそれを桁違いに簡単にし、楽しくします。ひとつの完全なアプリケーションを一週間で作ることができるでしょう。もしくは、一回の充実したハッカソンでも可能でしょう。サーバの準備もすることなく、クラウドにAPIを用意することもなく、データベースを管理することもなく、ORMレイヤーの論争をすることもなく、JavaScriptとRubyをいったりきたりすることもなく、データ形式のエラーをクライアントに伝搬することもありません。",
  "Meteor supports <a href=\"https://github.com/meteor/meteor/wiki/Supported-Platforms\">OS X, Windows, and Linux</a>.": "Meteorは<a href=\"https://github.com/meteor/meteor/wiki/Supported-Platforms\">OS X、Windows、Linux</a>をサポートしています。",
  "On Windows? <a href=\"https://install.meteor.com/windows\">Download the official Meteor installer here</a>.": "Windows用のMeteorインストーラは<a href=\"https://install.meteor.com/windows\">ここからダウンロードできます。</a>",
  "On OS X or Linux? Install the latest official Meteor release from your terminal:": "OS XまたはLinuxならMeteor最新版をターミナルからインストールできます。",
  "The Windows installer supports Windows 7, Windows 8.1, Windows Server 2008, and Windows Server 2012. The command line installer supports Mac OS X 10.7 (Lion) and above, and Linux on x86 and x86_64 architectures.": "WindowsインストーラはWindows 7、Windows 8.1、Windows Server 2008、Windows Server 2012をサポートしています。コマンドインストーラはMac OS X 10.7 (Lion)以上、またx86とx86_64アーキテクチャ上で動くLinuxをサポートしています。",
  "Once you&apos;ve installed Meteor, create a project:": "Meteorをインストールしたら、プロジェクトを作成しましょう。",
  "Run it locally:": "ローカルで動かします:",
  "Then, open a new terminal tab and unleash it on the world (on a free server we provide):": "さらに、新しいターミナルタブを開き、以下のコマンドを実行して世界中に公開しましょう(Meteorが提供している無料のサーバー上で動きます):",
  "<em>Data on the Wire</em>. Meteor doesn&apos;t send HTML over the network. The server sends data and lets the client render it.": "<em>ネットワークを流れるデータ</em>. MeteorはネットワークでHTMLを送りません。サーバはデータを送り、クライアントがそれを描画します。",
  "<em>One Language.</em> Meteor lets you write both the client and the server parts of your application in JavaScript.": "<em>単一の言語.</em> Meteorでは、アプリケーションのクライアントサイドもサーバサイドも両方JavaScriptで記述します。",
  "<em>Database Everywhere</em>. You can use the same methods to access your database from the client or the server.": "<em>どこでもデータベース</em>. クライアントサイドでもサーバサイドでもデータベースにアクセスするのに同じメソッドを使うことができます。",
  "<em>Latency Compensation</em>. On the client, Meteor prefetches data and simulates models to make it look like server method calls return instantly.": "<em>遅延の補償</em>. クライアントサイドではデータを事前取得しモデル変化を追従することにより、サーバのメソッド呼び出しの応答が瞬時にあったかのように見せかけます。",
  "<em>Full Stack Reactivity</em>. In Meteor, realtime is the default. All layers, from database to template, update themselves automatically when necessary.": "<em>フルスタックリアクティビティ</em>. Meteorでは、標準でリアルタイムです。データベースからテンプレートまでのすべてのレイヤーで必要に応じて自動で更新されます。",
  "<em>Embrace the Ecosystem</em>. Meteor is open source and integrates with existing open source tools and frameworks.": "<em>エコシステムの採用</em>. Meteorはオープンソースであり、既存のオープンソースのツールやフレームワークと統合します。",
  "<em>Simplicity Equals Productivity</em>. The best way to make something seem simple is to have it actually <em>be</em> simple. Meteor&apos;s main functionality has clean, classically beautiful APIs.": "<em>単純さによる生産性</em>. 何かを簡単に見せるための一番の方法は「単純」にすることです。Meteorの中心機能はクリーンできれいなAPIになっています。",
  "There are many community resources for getting help with your app. If Meteor catches your interest, we hope you&apos;ll get involved with the project!": "Meteorには様々なコミュニティがあります。もしよろしければ、プロジェクトにご参加ください！",
  "Get help on <code>meteor</code> command line usage. Running <code>meteor help</code> by itself will list the common <code>meteor</code> commands. Running <code>meteor help &lt;command&gt;</code> will print detailed help about <code>meteor &lt;command&gt;</code>.": "<code>meteor</code>コマンドラインツールのヘルプを見ます。<code>meteor help</code>を実行するとよく使うコマンドのリストが表示されます。<code>meteor help &lt;command&gt;</code>を実行すると<code>meteor &lt;command&gt;</code>の詳しい使い方が表示されます。",
  "Make a subdirectory called <code>&lt;name&gt;</code> and create a new Meteor app there.": "<code>&lt;name&gt;</code>という名前のディレクトリを作り、そこにMeteorアプリを新しく作ります。",
  "Serve the current app at <a href=\"http://localhost:3000\">http://localhost:3000</a> using Meteor&apos;s local development server.": "アプリを起動し、<a href=\"http://localhost:3000\">http://localhost:3000</a>にローカル開発サーバを用意します。",
  "Run the project with Node Inspector attached, so that you can step through your server code line by line. See <a href=\"#/full/meteordebug\"><code>meteor debug</code></a> in the full docs for more information.": "Nodeインスペクタでアプリを起動します。これにより、サーバサイドのコードをステップ実行できます。詳しくはFull APIのドキュメントを参照してください。",
  "Bundle your app and deploy it to <code>&lt;site&gt;</code>. Meteor provides free hosting if you deploy to <code>&lt;your app&gt;.meteor.com</code> as long as <code>&lt;your app&gt;</code> is a name that has not been claimed by someone else.": "アプリを<code>&lt;site&gt;</code>にデプロイします。<code>&lt;your app&gt;.meteor.com</code>にデプロイした場合、Meteorは無料のホスティングを提供します。ただし、<code>&lt;your app&gt;</code>が既に他に人にとられていない場合です。",
  "Update your Meteor installation to the latest released version and then (if <code>meteor update</code> was run from an app directory) update the packages used by the current app to the latest versions that are compatible with all other packages used by the app.": "インストールされたMeteorを最新のバージョンにします。さらに、コマンドがアプリのディレクトリから実行された場合には、そのアプリで使用しているパッケージのバージョンを互換性を保てる範囲でアップデートします。",
  "Add a package (or multiple packages) to your Meteor project. To query for available packages, use the <code>meteor search</code> command.": "パッケージをMeteorアプリに追加します。使えるパッケージを検索するには、<code>meteor search</code>コマンドを使います。",
  "Remove a package previously added to your Meteor project. For a list of the packages that your application is currently using, use the <code>meteor list</code> command.": "以前Meteorアプリに追加されたパッケージを削除します。現在使っているパッケージの一覧を表示するには、<code>meteor list</code>コマンドを使います。",
  "Opens a MongoDB shell for viewing and/or manipulating collections stored in the database. Note that you must already be running a server for the current app (in another terminal window) in order for <code>meteor mongo</code> to connect to the app&apos;s database.": "データベースに格納されているコレクションを閲覧もしくは操作するためのMongoDBシェルを開きます。<code>meteor mongo</code>でアプリのデータベースに接続するためには、あらかじめ(別のターミナルで)アプリを起動しておく必要があります。",
  "Reset the current project to a fresh state. Removes all local data.": "現在のアプリを完全に新しい状態にします。すべてのローカルデータが削除されます。",
  "If you use <code>meteor reset</code> often, but you have some initial data that you don&apos;t want to discard, consider using <a href=\"#/basic/Meteor-startup\"><code>Meteor.startup</code></a> to recreate that data the first time the server starts up:": "<code>meteor reset</code>をよく使う場合で、初期データを入れたい場合は、<a href=\"#/basic/Meteor-startup\"><code>Meteor.startup</code></a>を使って次のようにサーバ起動時にデータを再生成するようにできます。",
  "Meteor is very flexible about how you structure the files in your app. It automatically loads all of your files, so there is no need to use <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> tags to include JavaScript or CSS.": "Meteorはとても柔軟なファイル構造をしており、どこにファイルを置いても自動的に読み込まれます。そのため、CSSやJavaScriptを読み込むための<code>&lt;script&gt;</code>や<code>&lt;link&gt;</code>タグは必要ありません。",
  "If files are outside of the special directories listed below, Meteor does the following:": "もし特別なディレクトリ以外にファイルを置いた場合、Meteorは次の動きをします:",
  "If you want more control over which JavaScript code is loaded on the client and the server, you can use the special directories listed below.": "クライアントやサーバー上でもっとJavaScriptコードの制御を行いたい場合は、以下の特別なディレクトリを使うこともできます。",
  "Any files here are only served to the client. This is a good place to keep your HTML, CSS, and UI-related JavaScript code.": "ここに置いたファイルはクライアントにのみ提供されます。ここはHTMLやCSS、UI関連のJavaScriptコードを保管するのに良い場所です。",
  "Any files in this directory are only used on the server, and are never sent to the client. Use <code>/server</code> to store source files with sensitive logic or data that should not be visible to the client.": "このディレクトリに置いたファイルはサーバーでのみ使用され、クライアントには送られません。クライアントに見られたくない極秘のロジックやデータの入ったファイルは<code>/server</code>ディレクトリを使用してください。",
  "Files in <code>/public</code> are served to the client as-is. Use this to store assets such as images. For example, if you have an image located at <code>/public/background.png</code>, you can include it in your HTML with <code>&lt;img src=&apos;/background.png&apos;/&gt;</code> or in your CSS with <code>background-image: url(/background.png)</code>. Note that <code>/public</code> is not part of the image URL.": "<code>/public</code>に置いたファイルはそのままクライアントに提供されます。画像などのアセットを保管するために使用します。例えば、<code>/public/background.png</code>にイメージファイルを置くと、HTMLで<code>&lt;img src=&apos;/background.png&apos;/&gt;</code>もしくはCSSで<code>background-image: url(/background.png)</code>と記述することでそのファイルを読み込むことができます。注:<code>/public</code>は画像のURLに含まれません。",
  "These files can only be accessed by server code through <a href=\"#assets\"><code>Assets</code></a> API and are not accessible to the client.": "ここに置いたファイルはサーバーからは<a href=\"#assets\"><code>Assets</code></a> API経由でのみアクセス可能で、クライアントからはアクセスできません。",
  "Read more about file load order and special directories in the <a href=\"#/full/structuringyourapp\">Structuring Your App section</a> of the full API documentation.": "ファイルの読み込み順番と特別なディレクトリの詳細は、full API の<a href=\"#/full/structuringyourapp\">Structuring Your App section</a>をお読みください。",
  "Once you&apos;ve built your web app with Meteor, you can easily build a native wrapper for your app and publish it to the Google Play Store or iOS App Store with just a few commands. We&apos;ve put a lot of work into making the same packages and APIs work on desktop and mobile, so that you don&apos;t have to worry about a lot of the edge cases associated with mobile app development.": "ウェブアプリをMeteorで構築すると、簡単にネイティブラッパーを作成でき、わずか数コマンドでGoogle Play StoreやiOS App Storeにそのアプリを配信できます。我々はデスクトップとモバイルで同一のパッケージとAPIが動くように、多くの努力をしており、モバイルアプリ開発に関連した多くの特殊なケースについて心配する必要はありません。",
  "Install the development tools for Android or iOS with one command:": "1コマンドでAndroidまたはiOSの開発ツールをインストール:",
  "Add the relevant platform to your app:": "あなたのアプリに関連するプラットフォームを追加:",
  "You can configure your app&apos;s icons, title, version number, splash screen, and other metadata with the special <a href=\"#/full/mobileconfigjs\"><code>mobile-config.js</code> file</a>.": "特別なファイルの<a href=\"#/full/mobileconfigjs\"><code>mobile-config.js</code></a>でアプリのアイコン、タイトル、バージョン番号、スプラッシュスクリーン、その他のメタデータを設定することができます。",
  "Learn more about Meteor&apos;s mobile support on the <a href=\"https://github.com/meteor/meteor/wiki/Meteor-Cordova-Phonegap-integration\">GitHub wiki page</a>.": "<a href=\"https://github.com/meteor/meteor/wiki/Meteor-Cordova-Phonegap-integration\">GitHub wiki ページ</a>でモバイルサポートについて詳しく学ぶことができます。",
  "Your JavaScript code can run in two environments: the <em>client</em> (browser), and the <em>server</em> (a <a href=\"http://nodejs.org/\">Node.js</a> container on a server). For each function in this API reference, we&apos;ll indicate if the function is available just on the client, just on the server, or <em>Anywhere</em>.": "JavaScriptコードは2つの環境で動きます。一つは<em>client</em>すなわちブラウザです。もう一つは、<em>server</em>すなわちサーバ上の<a href=\"http://nodejs.org/\">Node.js</a>の中です。このAPI仕様書ではそれぞれの関数がどちらで動くものか明記されます。クライアントとサーバの両方で動く場合は<em>Anywhere</em>と示されます。",
  "In Meteor, views are defined in <em>templates</em>. A template is a snippet of HTML that can include dynamic data. You can also interact with your templates from JavaScript code to insert data and listen to events.": "Meteorではビューは<em>templates</em>内に定義されます。一つのテンプレートは動的なデータを含むことのできるHTMLのスニペットです。テンプレートにはJavaScriptコードからアクセスでき、データを挿入したりイベントを待ち受けたりできます。",
  "Templates are defined in <code>.html</code> files that can be located anywhere in your Meteor project folder except the <code>server</code>, <code>public</code>, and <code>private</code> directories.": "テンプレートは<code>.html</code>ファイルに定義されます。ファイルは複数でもよくMeteorプロジェクトディレクトリのどこにあっても構いません。ただし、次の3つのディレクトリは除きます。<code>server</code>と<code>public</code>と<code>private</code>。",
  "Each <code>.html</code> file can contain any number of the following top-level elements: <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, or <code>&lt;template&gt;</code>. Code in the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags is appended to that section of the HTML page, and code inside <code>&lt;template&gt;</code> tags can be included using <code>{{&gt; templateName}}</code>, as shown in the example below. Templates can be included more than once &#x2014; one of the main purposes of templates is to avoid writing the same HTML multiple times by hand.": "<code>.html</code>ファイルには次のトップレベル要素をいくつでも含むことができます。<code>&lt;head&gt;</code>や<code>&lt;body&gt;</code>や<code>&lt;template&gt;</code>。<code>&lt;head&gt;</code>と<code>&lt;body&gt;</code>タグのコードはすべて連結されHTMLページの所定の位置に入れられます。<code>&lt;template&gt;</code>タグのコードは<code>{{&gt; templateName}}</code>を使ってインクルードすることができます。次の例を参照してください。テンプレートは複数回インクルードすることができます。テンプレートは同じHTMLを複数回記述しなくすむためのものです。",
  "The <code>{{ ... }}</code> syntax is part of a language called Spacebars that Meteor uses to add functionality to HTML. As shown above, it lets you include templates in other parts of your page. Using Spacebars, you can also display data obtained from <em>helpers</em>. Helpers are written in JavaScript, and can be either simple values or functions.": "<code>{{ ... }}</code>という文法はMeteorがHTMLを拡張するためのSpacebarsという言語の一部です。上記の例ように、テンプレートをページの任意の位置にインクルードすることができます。Spacebarsを使うと<em>helpers</em>からのデータを表示することもできます。ヘルパーはJavaScriptで記述し、単なる値もしくは関数で書きます。",
  "Specify template helpers available to this template.": "このテンプレート用のテンプレートヘルパーを指定する。",
  "Dictionary of helper functions by name.": "名前とヘルパー関数の辞書",
  "Here&apos;s how you might define a helper called <code>name</code> for a template called <code>nametag</code> (in JavaScript):": "下記の例は、<code>nametag</code>というテンプレートに<code>name</code>とうヘルパー関数を定義するものです。(JavaScriptで)",
  "And here is the <code>nametag</code> template itself (in HTML):": "そしてこちらが<code>nametag</code>テンプレートそのものです。(HTMLで)",
  "Spacebars also has a few other handy control structures that can be used to make your views more dynamic:": "Spacebarsには他にもビューを動的にする便利な制御構造が用意されています。",
  "Each nested <code>#each</code> or <code>#with</code> block has its own <em>data context</em>, which is an object whose properties can be used as helpers inside the block. For <code>#with</code> blocks, the data context is simply the value that appears after the <code>#with</code> and before the <code>}}</code> characters. For <code>#each</code> blocks, each element of the given array becomes the data context while the block is evaluated for that element.": "<code>#each</code>や<code>#with</code>で囲まれたブロックは独自の<em>data context</em>を持ち、そのプロパティをブロック内で使うことができます。<code>#with</code>ブロックの場合は、<code>#with</code>と<code>}}</code>の間にある値が単にデータコンテキストになります。<code>#each</code>ブロックの場合は、与えられた配列のそれぞれの要素が、そのブロックを評価する際のデータコンテキストになります。",
  "For instance, if the <code>people</code> helper has the following value": "例えば、<code>people</code>ヘルパーが次のような値を持つ場合",
  "then you can display every person&apos;s name as a list of <code>&lt;p&gt;</code> tags:": "この場合は次のようにしてすべての人の名前を<code>&lt;p&gt;</code>タグのリストで表示することができます:",
  "or use the &quot;nametag&quot; template from above instead of <code>&lt;p&gt;</code> tags:": "もしくは<code>&lt;p&gt;</code>タグの代わりに上記の&quot;nametag&quot;テンプレートを使うこともできます:",
  "Remember that helpers can be functions as well as simple values. For example, to show the logged in user&apos;s username, you might define a function-valued helper called <code>username</code>:": "ヘルパーは単純な値だけでなく関数を指定することもできます。例えば、ログインユーザのユーザ名を表示するには、<code>username</code>というヘルパーに関数を指定することができます:",
  "Now, each time you use the <code>username</code> helper, the helper function above will be called to determine the user&apos;s name:": "このとき、<code>username</code>ヘルパーを使う度に、上記のヘルパー関数が呼び出されユーザ名を決定することになります:",
  "Helpers can also take arguments. For example, here&apos;s a helper that pluralizes a word:": "ヘルパー関数は引数をとることもできます。例えば、下記は単語を複数形にする関数です:",
  "Pass in arguments by putting them inside the curly braces after the name of the helper:": "引数は{{}}ブロック内のヘルパー名の後に指定します:",
  "The helpers above have all been associated with specific templates, but you can also make a helper available in all templates by using <a href=\"#template_registerhelper\"><code>Template.registerHelper</code></a>.": "上記のヘルパーはすべて特定のテンプレートに関連づけられていましたが、すべてのテンプレートで使えるヘルパーを作ることもできます。これには、<a href=\"#template_registerhelper\"><code>Template.registerHelper</code></a>を使います。",
  "You can find detailed documentation for Spacebars in the <a href=\"https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md\">README on GitHub</a>. Later in this documentation, the sections about <code>Session</code>, <code>Tracker</code>, <code>Collections</code>, and <code>Accounts</code> will talk more about how to add dynamic data to your templates.": "Spacebarsに関する詳細ドキュメントは<a href=\"https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md\">README on GitHub</a>にあります。本ドキュメント後半では、<code>Session</code>や<code>Tracker</code>や<code>Collections</code>や<code>Accounts</code>の説明があり、テンプレートに動的にデータを渡す方法についてさらに解説します。",
  "Specify event handlers for this template.": "テンプレートのイベントハンドラを指定する",
  "Event handlers to associate with this template.": "テンプレートに関係づけるイベントハンドラ",
  "The event map passed into <code>Template.myTemplate.events</code> has event descriptors as its keys and event handler functions as the values. Event handlers get two arguments: the event object and the template instance. Event handlers can also access the data context of the target element in <code>this</code>.": "<code>Template.myTemplate.events</code>に渡されるイベントハンドラはイベントディスクリプタをキーとしイベントハンドラの関数を値にしたオブジェクトです。イベントハンドラ関数は2つの引数をとります: イベントオブジェクトとテンプレートインスタンスです。また、イベントハンドラはターゲット要素のデータコンテキストに<code>this</code>でアクセスできます。",
  "To attach event handlers to the following template": "次のテンプレートにイベントハンドラを指定するには",
  "you might call <code>Template.example.events</code> as follows:": "次のように<code>Template.example.events</code>を呼び出します。",
  "The first part of the key (before the first space) is the name of the event being captured. Pretty much any DOM event is supported. Some common ones are: <code>click</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseenter</code>, <code>mouseleave</code>, <code>keydown</code>, <code>keyup</code>, <code>keypress</code>, <code>focus</code>, <code>blur</code>, and <code>change</code>.": "キーの前半(スペースの前)はイベント名です。ほとんどのDOMイベントがサポートされています。よく使うものは、<code>click</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseenter</code>, <code>mouseleave</code>, <code>keydown</code>, <code>keyup</code>, <code>keypress</code>, <code>focus</code>, <code>blur</code>, <code>change</code>です。",
  "The second part of the key (after the first space) is a CSS selector that indicates which elements to listen to. This can be almost any selector <a href=\"http://api.jquery.com/category/selectors/\">supported by JQuery</a>.": "キーの後半(スペースの後ろ)はどの要素を対象とするかを示すCSSセレクタです。これはほとんどすべての<a href=\"http://api.jquery.com/category/selectors/\">supported by JQuery</a>のセレクタが使えます。",
  "Register a function to be called when an instance of this template is inserted into the DOM.": "テンプレートがDOMに追加されたときに呼び出される関数を登録する。",
  "A function to be added as a callback.": "コールバック関数",
  "The functions added with this method are called once for every instance of <em>Template.myTemplate</em> when it is inserted into the page for the first time.": "このメソッドにより追加された関数は、<em>Template.myTemplate</em>のすべてのインスタンスが初めてページに挿入されるときに、一度だけ呼び出されます。",
  "These callbacks can be used to integrate external libraries that aren&apos;t familiar with Meteor&apos;s automatic view rendering, and need to be initialized every time HTML is inserted into the page. You can perform initialization or clean-up on any objects in <a href=\"#template_oncreated\"><code>onCreated</code></a> and <a href=\"#template_ondestroyed\"><code>onDestroyed</code></a> callbacks.": "これらのコールバック関数は外部ライブラリを使うことに利用できます。外部ライブラリはMeteorの自動ビューレンダリングをそのままでは使えず、HTMLがページに挿入されるたびに初期化する必要があります。初期化や終了の処理は<a href=\"#template_oncreated\"><code>onCreated</code></a>と<a href=\"#template_ondestroyed\"><code>onDestroyed</code></a>のコールバック内で行うことができます。",
  "For example, to use the HighlightJS library to apply code highlighting to all <code>&lt;pre&gt;</code> elements inside the <code>codeSample</code> template, you might pass the following function to <code>Template.codeSample.onRendered</code>:": "例えば、<code>codeSample</code>テンプレート内のすべての<code>&lt;pre&gt;</code>要素をハイライトするためにHighlightJSライブラリを使う場合は、次の関数を<code>Template.codeSample.onRendered</code>に渡すでしょう:",
  "In the callback function, <code>this</code> is bound to a <a href=\"#template_inst\">template instance</a> object that is unique to this inclusion of the template and remains across re-renderings. You can use methods like <a href=\"#template_find\"><code>this.find</code></a> and <a href=\"#template_findAll\"><code>this.findAll</code></a> to access DOM nodes in the template&apos;s rendered HTML.": "コールバック関数の中では、<code>this</code>は<a href=\"#template_inst\">template instance</a>オブジェクトになります。このオブジェクトはこのテンプレートに固有のもので再描画されても変わりません。テンプレートHTMLのDOMにアクセスするために<a href=\"#template_find\"><code>this.find</code></a>や<a href=\"#template_findAll\"><code>this.findAll</code></a>などのメソッドを使うことができます。",
  "A template instance object represents a single inclusion of a template in the document. It can be used to access the HTML elements inside the template and it can be assigned properties that persist as the template is reactively updated.": "テンプレートインスタンスオブジェクトはドキュメント中の一つのテンプレートの挿入に相当します。このオブジェクトはテンプレート内のHTML要素へのアクセスやプロパティ保持に使われます。プロパティはテンプレートがリアクティブに更新されても変化しません。",
  "Template instance objects can be found in several places:": "テンプレートインスタンスオブジェクトは複数の所で使用されます:",
  "You can assign additional properties of your choice to the template instance to keep track of any state relevant to the template. For example, when using the Google Maps API you could attach the <code>map</code> object to the current template instance to be able to refer to it in helpers and event handlers. Use the <a href=\"#template_onCreated\"><code>onCreated</code></a> and <a href=\"#template_onDestroyed\"><code>onDestroyed</code></a> callbacks to perform initialization or clean-up.": "テンプレートには追加で開発者が任意のプロパティを設定することができます。このプロパティはテンプレートの状態を保持することに使えます。例えば、Google Maps APIを使う場合に、<code>map</code>オブジェクトをテンプレートインスタンスに設定し、ヘルパー関数やイベントハンドラ関数から参照することができます。初期化や終了の処理には、<a href=\"#template_onCreated\"><code>onCreated</code></a>や<a href=\"#template_onDestroyed\"><code>onDestroyed</code></a>のコールバックを使いましょう。",
  "Find all elements matching <code>selector</code> in this template instance.": "テンプレート内で<code>selector</code>にマッチする要素をすべて見つける",
  "The CSS selector to match, scoped to the template contents.": "マッチするCSSセレクタ。テンプレート内に限定される。",
  "<code>template.findAll</code> returns an array of DOM elements matching <code>selector</code>. You can also use <code>template.$</code>, which works exactly like the JQuery <code>$</code> function but only returns elements within <code>template</code>.": "<code>template.findAll</code>は、<code>selector</code>にマッチするDOM要素の配列を返します。また、<code>template.$</code>はJQueryの<code>$</code>と同じように使える関数です。ただし、<code>template</code>内の要素しか返しません。",
  "Find one element matching <code>selector</code> in this template instance.": "テンプレート内で<code>selector</code>にマッチする要素をひとつ見つける",
  "<code>find</code> is just like <code>findAll</code> but only returns the first element found. Like <code>findAll</code>, <code>find</code> only returns elements from inside the template.": "<code>find</code>は<code>findAll</code>とほぼ同じですが、最初に見つかったひとつの要素だけを返します。<code>findAll</code>と同じく、<code>find</code>はテンプレート内の要素だけを返します。",
  "<code>Session</code> provides a global object on the client that you can use to store an arbitrary set of key-value pairs. Use it to store things like the currently selected item in a list.": "Session(セッション)はクライアント上のグローバルオブジェクトとして提供され、キーと値のペアのセットを格納するために使用できます。それは、リストで現在選択している項目のようなものを一時的に保持するのに使用します。",
  "What&apos;s special about <code>Session</code> is that it&apos;s <em>reactive</em>. If you call <code>Session.get(&quot;myKey&quot;)</code> in a <a href=\"#template_helpers\">template helper</a> or inside <a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>, the relevant part of the template will be re-rendered automatically whenever <code>Session.set(&quot;myKey&quot;, newValue)</code> is called.": "<code>Session</code>が特別なのは<em>リアクティブ</em>であるところです。<a href=\"#template_helpers\">template helper</a>や<a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>の中で、<code>Session.get(&quot;myKey&quot;)</code>と記述しておくと、どこかで<code>Session.set(&quot;myKey&quot;, newValue)</code>を呼び出した時に、テンプレートの関連する部分が自動的に再描画されます。",
  "Set a variable in the session. Notify any listeners that the value has changed (eg: redraw templates, and rerun any <a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a> computations, that called <a href=\"#session_get\"><code>Session.get</code></a> on this <code>key</code>.)": "セッションに変数をセットします。また、リスナーに値が変更されたことが通知されます(例: <code>Session.get</code>でこのキーを呼び出しているテンプレートを再描画したり、<a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>処理を再実行します。",
  "The key to set, eg, <code>selectedItem</code>": "セッションのキー、例: <code>selectedItem</code>",
  "The new value for <code>key</code>": "<code>key</code>の新しい値",
  "Get the value of a session variable. If inside a <a href=\"#reactivity\">reactive computation</a>, invalidate the computation the next time the value of the variable is changed by <a href=\"#session_set\"><code>Session.set</code></a>. This returns a clone of the session value, so if it&apos;s an object or an array, mutating the returned value has no effect on the value stored in the session.": "セッション変数の値を取得します。もしリアクティブ処理の中では、Session.setにより変数の値が変更になった場合に処理が無効化（再計算）されます。これはセッション値のクローンを返します。そのため、それがオブジェクトまたは配列の場合、返された値を変更したとしても、セッションに格納されている値には影響を与えません。",
  "The name of the session variable to return": "値を取得したいセッション変数名",
  "Using <code>Session</code> gives us our first taste of <em>reactivity</em>, the idea that the view should update automatically when necessary, without us having to call a <code>render</code> function manually. In the next section, we will learn how to use Tracker, the lightweight library that makes this possible in Meteor.": "<code>Session</code>を使うと、<code>render</code>ファンクションを手動で呼び出すことなく、必要に応じて自動でビューを更新する<em>リアクティビティ</em>の一端に触れることができます。次のセクションでは、Meteorでこれを可能にしている軽量ライブラリTrackerの使い方を学習します。",
  "Meteor has a simple dependency tracking system which allows it to automatically rerun templates and other functions whenever <a href=\"#session\"><code>Session</code></a> variables, database queries, and other data sources change.": "Meteorはシンプルな依存関係のトラッキングシステムをもっており、<a href=\"#session\"><code>Session</code></a>変数やデータベースクエリ、その他データソースを変更を検知して、自動的にテンプレートを再描画したり関数を再実行します。",
  "Unlike most other systems, you don&apos;t have to manually declare these dependencies &#x2014; it &quot;just works.&quot; The mechanism is simple and efficient. Once you&apos;ve initialized a computation with <code>Tracker.autorun</code>, whenever you call a Meteor function that returns data, <code>Tracker</code> automatically records which data were accessed. Later, when this data changes, the computation is rerun automatically. This is how a template knows how to re-render whenever its <a href=\"#template_helpers\">helper functions</a> have new data to return.": "他のほとんどのシステムとは異なり、手動でこれらの依存関係を宣言する必要はありません。特に何もしなくても動きます。そのメカニズムはシンプルかつ効率的です。<code>Tracker.autorun</code>で処理を初期化すると、データを返すMeteor関数を呼び出した場合に、どのデータにアクセスしたかが自動で記録されます。その後、そのデータが変更されると、処理が自動的に再実行されます。このようにして、<a href=\"#template_helpers\">ヘルパー関数</a>が新しいデータを返すとテンプレートは再レンダリングが必要なことを検知できます。",
  "Run a function now and rerun it later whenever its dependencies change. Returns a Computation object that can be used to stop or observe the rerunning.": "関数を直ちに実行し、また依存関係にあるものが変更されるたびに、後でそれを実行します。停止または再実行を観察するために使用することができる演算オブジェクトを返します。",
  "The function to run. It receives one argument: the Computation object that will be returned.": "実行する関数。1つの引数を取る: 演算オブジェクトを返します。",
  "Optional. The function to run when an error happens in the Computation. The only argument it recieves is the Error thrown. Defaults to the error being logged to the console.": "オプション。runFuncでエラーが発生した時にこの関数を実行します。この関数は1つの引数を取り、発生したエラーを受け取ります。省略した場合、デフォルトではコンソールにエラーを出力します。",
  "<code>Tracker.autorun</code> allows you to run a function that depends on reactive data sources. Whenever those data sources are updated with new data, the function will be rerun.": "<code>Tracker.autorun</code>はリアクティブデータソースに依存した関数を実行できるようにします。これらのデータソースが新しいデータで更新されるたびに、その関数は再実行されます。",
  "For example, you can monitor one <code>Session</code> variable and set another:": "例えば、1つの<code>Session</code>変数を監視し、それを別のものにセットすることができます:",
  "Or you can wait for a session variable to have a certain value, and do something the first time it does. If you want to prevent further rerunning of the function, you can call <code>stop</code> on the computation object that is passed as the first parameter to the callback function:": "また、Session変数が特定の値になった時に初めて処理を実行するようにもできます。もし、これ以上関数を再実行させたくなければ、コールバック関数の第１引数に渡される演算オブジェクトの<code>stop</code>を呼び出すことで、再実行しないようにできます。",
  "The first time <code>Tracker.autorun</code> is called, the callback function is invoked immediately, at which point it alerts and stops right away if <code>counter === 2</code> already. In this example, <code>Session.get(&quot;counter&quot;) === 0</code> when <code>Tracker.autorun</code> is called, so nothing happens the first time, and the function is run again each time <code>counter</code> changes, until <code>computation.stop()</code> is called after <code>counter</code> reaches <code>2</code>.": "初めて<code>Tracker.autorun</code>が呼ばれると、コールバック関数はすぐに実行され、もしすでに <code>counter === 2</code> の場合は、アラートを表示してすぐに停止します。上の例では、<code>Tracker.autorun</code>が呼ばれた時は <code>Session.get(&quot;counter&quot;) === 0</code> なので、初めは何も起きません。そして、<code>counter</code>が<code>2</code>になり<code>computation.stop()</code>が呼ばれるまでは、<code>counter</code>が変更されるたびに関数が実行されます。",
  "If the initial run of an autorun throws an exception, the computation is automatically stopped and won&apos;t be rerun.": "もし、autorunの初期実行で例外が発生すると、自動的に処理は停止し、再実行されることはありません。",
  "To learn more about how <code>Tracker</code> works and to explore advanced ways to use it, visit the <a href=\"http://manual.meteor.com/#tracker\">Tracker</a> chapter in the <a href=\"http://manual.meteor.com/\">Meteor Manual</a>, which describes it in much more detail.": "<code>Tracker</code>の動きについてもっと学習したり、高度な使い方を知りたい場合は、<a href=\"http://manual.meteor.com/\">Meteor Manual</a>の<a href=\"http://manual.meteor.com/#tracker\">Tracker</a>チャプターにより詳細な説明があります。",
  "Meteor stores data in <em>collections</em>. JavaScript objects stored in collections are called <code>documents</code>. To get started, declare a collection with <code>new Mongo.Collection</code>.": "Meteorは<em>コレクション</em>の中にデータを保存します。コレクションの中に保存されたJavaScriptオブジェクトは<code>documents</code>(ドキュメント)と呼ばれます。開始するには、<code>new Mongo.Collection</code> でコレクションを宣言します。",
  "Constructor for a Collection": "コレクションのコンストラクタ",
  "The name of the collection. If null, creates an unmanaged (unsynchronized) local collection.": "コレクション名。もしnullを指定した場合、管理されない(同期されない)ローカルコレクションを作ります。",
  "Calling the <code>Mongo.Collection</code> constructor creates a collection object which acts just like a MongoDB collection. If you pass a name when you create the collection, then you are declaring a persistent collection &#x2014; one that is stored on the server and can be published to clients.": "<code>Mongo.Collection</code>コンストラクタを呼び出すと、ちょうどMongoDBコレクションのように動作するコレクション・オブジェクトを作成します。コレクションを作成する時に名前を渡すと、永続的なコレクションの宣言になります。それはサーバーに保存され、クライアントに配信することができます。",
  "To allow both client code and server code to access the same collection using the same API, it&apos;s usually best to declare collections as global variables in a JavaScript file that&apos;s present on both client and server.": "クライアントコードとサーバーコードの両方が同じAPIを使用して同じコレクションにアクセスできるようにするには、クライアントとサーバーの両方で使用されるJavaScriptファイル内で、グローバル変数としてコレクションを宣言します。",
  "Here&apos;s an example of declaring two named, persistent collections as global variables:": "ここで、グローバル変数として永続的なコレクションを2つ宣言する例を示します:",
  "If you pass <code>null</code> as the name, then you&apos;re creating a local collection. Local collections are not synchronized between the client and the server; they are just temporary collections of JavaScript objects that support Mongo-style <code>find</code>, <code>insert</code>, <code>update</code>, and <code>remove</code> operations.": "もしnullを名前に渡すと、ローカルコレクションを作成します。ローカルコレクションはクライアントとサーバー間で同期されません。これらはMongoスタイルの<code>find</code>、<code>insert</code>、<code>update</code>、<code>remove</code>をサポートしたJavaScriptオブジェクトの一時的なコレクションとなります。",
  "By default, Meteor automatically publishes every document in your collection to each connected client. To disable this behavior, you must remove the <code>autopublish</code> package, in your terminal:": "デフォルトでは、Meteorは自動的にあなたのコレクションのすべてのドキュメントを接続しているクライアントに配信します。この振る舞いを止めるには、ターミナルで以下のコマンドを実行して、<code>autopublish</code>パッケージを取り除く必要があります:",
  "Then, use <a href=\"#meteor_publish\"><code>Meteor.publish</code></a> and <a href=\"#meteor_subscribe\"><code>Meteor.subscribe</code></a> to specify which parts of your collection should be published to which clients.": "それから、コレクションの一部をどのクライアントに配信するかを指定するため、<a href=\"#meteor_publish\"><code>Meteor.publish</code></a>と<a href=\"#meteor_subscribe\"><code>Meteor.subscribe</code></a>を使用します。",
  "Use <code>findOne</code> or <code>find</code> to retrieve documents from a collection.": "コレクションからドキュメントを取得するには、<code>findOne</code>や<code>find</code>を使用します。",
  "Finds the first document that matches the selector, as ordered by sort and skip options.": "selectorにマッチする初めのドキュメントを検索します。sortやskipオプションで順序を指定できます。",
  "A query describing the documents to find": "ドキュメントを検索するためのクエリ",
  "Sort order (default: natural order)": "ソート順 (デフォルト: 自然な順序)",
  "Number of results to skip at the beginning": "結果の先頭からスキップする数",
  "Dictionary of fields to return or exclude.": "取得する or 除外するフィールド",
  "This method lets you retrieve a specific document from your collection. The <code>findOne</code> method is most commonly called with a specific document <code>_id</code>:": "このメソッドは特定のドキュメントをコレクションから取得します。<code>findOne</code>メソッドは特定のドキュメント<code>_id</code>と共に呼び出されるのが最も一般的です:",
  "However, you can also call <code>findOne</code> with a Mongo selector, which is an object that specifies a required set of attributes of the desired document. For example, this selector": "しかしながら、ドキュメントの属性のセットを細かく指定したMongoセレクタで<code>findOne</code>を呼び出すこともできます。たとえば、このセレクタは:",
  "will match this document": "このドキュメントにマッチします",
  "You can read about MongoDB query operators such as <code>$regex</code>, <code>$lt</code> (less than), <code>$text</code> (text search), and more in the <a href=\"http://docs.mongodb.org/manual/reference/operator/query/\">MongoDB documentation</a>.": "<code>$regex</code> (正規表現)、<code>$lt</code> (より小さい)、<code>$text</code> (テキスト検索)など多くのMongoDBクエリ操作について、詳しくは<a href=\"http://docs.mongodb.org/manual/reference/operator/query/\">MongoDBドキュメント</a>をご覧ください。",
  "One useful behavior that might not be obvious is that Mongo selectors also match items in arrays. For example, this selector": "明確ではないかもしれませんが、ひとつの便利な動作として、Mongoセレクタは配列内の要素にもマッチします。たとえば、このセレクタは",
  "The <code>findOne</code> method is reactive just like <a href=\"#session_get\"><code>Session.get</code></a>, meaning that, if you use it inside a <a href=\"#template_helpers\">template helper</a> or a <a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a> callback, it will automatically rerender the view or rerun the computation if the returned document changes.": "<code>findOne</code>メソッドは<a href=\"#session_get\"><code>Session.get</code></a>のようにリアクティブです。すなわち、<a href=\"#template_helpers\">テンプレートヘルパー</a>の中や<a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>のコールバックで使用すると、ドキュメントが更新された時に自動的に表示が再描画されたり、計算処理が再実行されます。",
  "Note that <code>findOne</code> will return <code>null</code> if it fails to find a matching document, which often happens if the document hasn&apos;t been loaded yet or has been removed from the collection, so you should be prepared to handle <code>null</code> values.": "注:<code>findOne</code>はマッチするドキュメントが見つからなかった時に<code>null</code>を返します。それはドキュメントがまだ読み込まれていなかったり、コレクションからドキュメントを取り除いた時に頻繁に起こります。そのため<code>null</code>値の場合の処理を用意する必要があります。",
  "Find the documents in a collection that match the selector.": "コレクションの中からselectorにマッチしたドキュメントを検索します。",
  "Maximum number of results to return": "結果の最大数",
  "The <code>find</code> method is similar to <code>findOne</code>, but instead of returning a single document it returns a MongoDB <em>cursor</em>. A cursor is a special object that represents a list of documents that might be returned from a query. You can pass a cursor into a template helper anywhere you could pass an array:": "<code>find</code>メソッドは<code>findOne</code>と似ていますが、一つのドキュメントの代わりに、MongoDB<em>カーソル</em>を返します。カーソルは、クエリから返される可能性があるドキュメントのリストを表す特別なオブジェクトです。テンプレートヘルパーの中で配列を渡すことができる場所ならどこでもカーソルを渡すことができます:",
  "When you want to retrieve the current list of documents from a cursor, call the cursor&apos;s <code>.fetch()</code> method:": "カーソルからドキュメントのリストを取り出すには、カーソルの<code>.fetch()</code>メソッドを呼び出します:",
  "Keep in mind that while the computation in which you call <code>fetch</code> will rerun when the data changes, the resulting array will not be reactive if it is passed somewhere else.": "注意すべきは、データが更新されたときに<code>fetch</code>自体の計算は再実行されますが、その結果の配列はリアクティブではないため別のところに渡した場合は更新されなくなる点です。",
  "You can modify the data stored in a <code>Mongo.Collection</code> by calling <code>insert</code>, <code>update</code>, or <code>remove</code>.": "<code>Mongo.Collection</code>の中に保存されたデータは<code>insert</code>や<code>update</code>、<code>remove</code>を呼ぶことで変更できます。",
  "Insert a document in the collection. Returns its unique _id.": "コレクションにドキュメントを挿入します。そして一意の_idを返します。",
  "The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.": "挿入するドキュメント。_id属性が持っていない場合、Meteorは_idを生成します。",
  "Optional. If present, called with an error object as the first argument and, if no error, the _id as the second.": "オプション。存在した場合、コールバック関数の第１引数にエラーオブジェクトを渡します。もしエラーがなければ、_idを第２引数に渡します。",
  "Here&apos;s how you insert a document into a collection:": "コレクションにドキュメントを挿入する方法は次の通りです:",
  "Every document in every <code>Mongo.Collection</code> has an <code>_id</code> field. It must be unique, and is automatically generated if you don&apos;t provide one. The <code>_id</code> field can be used to retrieve a specific document using <a href=\"#findOne\"><code>collection.findOne</code></a>.": "すべての<code>Mongo.Collection</code>のすべてのドキュメントは、_idフィールドを持っています。それは一意であり、<code>_id</code>を指定しなかった時は自動的に生成されます。<code>_id</code>フィールドは<a href=\"#findOne\"><code>collection.findOne</code></a>で特定のドキュメントを取得するために使用できます。",
  "Modify one or more documents in the collection. Returns the number of affected documents.": "コレクション内の1つまたは複数のドキュメントを修正します。影響を与えたドキュメントの数を返します。",
  "Specifies which documents to modify": "修正したいドキュメントの指定します",
  "Specifies how to modify the documents": "ドキュメントをどのように修正するかを指定します",
  "Optional. If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.": "オプション。存在する場合、コールバック関数の第１引数にエラーオブジェクトが渡されます。もしエラーがなければ、影響を与えたドキュメントの数を第２引数に渡します。",
  "True to modify all matching documents; false to only modify one of the matching documents (the default).": "trueならselectorマッチするドキュメントをすべて修正します。falseならマッチするドキュメントの一つを修正します(デフォルト)。",
  "True to insert a document if no matching documents are found.": "trueならマッチするドキュメントが見つからなかった場合にドキュメントを新たに挿入します。",
  "The selector here is just like the one you would pass to <code>find</code>, and can match multiple documents. The modifier is an object that specifies which changes should be made to the matched documents. Watch out - unless you use an operator like <code>$set</code>, <code>update</code> will simply replace the entire matched document with the modifier.": "selectorは<code>find</code>メソッドに渡すのと同じようなもので、複数のドキュメントにマッチします。modifierはマッチしたドキュメントをどのように修正するかを記述したオブジェクトです。注:modifierで<code>$set</code>オペレーターを指定しない場合、<code>update</code>はマッチしたドキュメントをmodifierとまるごと交換します。",
  "Here&apos;s an example of setting the <code>content</code> field on all posts whose titles contain the word &quot;first&quot;:": "ここで、タイトルに&quot;first&quot;を含むすべてのpostsに、contentフィールドをセットする例を示します:",
  "You can read about all of the different operators that are supported in the <a href=\"http://docs.mongodb.org/manual/reference/operator/update/\">MongoDB documentation</a>.": "updateの各オペレーターについては<a href=\"http://docs.mongodb.org/manual/reference/operator/update/\">MongoDB documentation</a>で知ることができます。",
  "There&apos;s one catch: when you call <code>update</code> on the client, you can only find documents by their <code>_id</code> field. To use all of the possible selectors, you must call <code>update</code> in server code or from a <a href=\"#meteor_methods\">method</a>.": "注:クライアント上でupdateを呼び出した場合、_idフィールドでのみドキュメントを見つけることができます。セレクタに他のものを使用する場合は、サーバーコードか<a href=\"#meteor_methods\">method</a>経由でupdateを呼び出す必要があります。",
  "Remove documents from the collection": "コレクションからドキュメントを削除します",
  "Specifies which documents to remove": "削除するドキュメントを指定します",
  "Optional. If present, called with an error object as its argument.": "オプション。もし存在する場合、引数にエラーオブジェクトが渡されたコールバック関数が呼ばれます。",
  "This method uses the same selectors as <code>find</code> and <code>update</code>, and removes any documents that match the selector from the database. Use <code>remove</code> carefully &#x2014; there&apos;s no way to get that data back.": "このメソッドは<code>find</code>や<code>update</code>と同じセレクタが使用でき、セレクタにマッチしたドキュメントをデータベースから取り除きます。<code>remove</code>を使用するときは気をつけて下さい — 削除されたデータを再び取得する方法はありません。",
  "As with <code>update</code>, client code can only remove documents by <code>_id</code>, whereas server code and <a href=\"#meteor_methods\">methods</a> can remove documents using any selector.": "<code>update</code>と同様に、クライアントコードでは<code>_id</code>でのみドキュメントを削除できます。一方で、サーバーコードや<a href=\"#meteor_methods\">methods</a>であれば他のセレクタを使用してドキュメントを削除することができます。",
  "Allow users to write directly to this collection from client code, subject to limitations you define.": "クライアントコードからこのコレクションに直接書き込みできるユーザの制限を定義します。",
  "Functions that look at a proposed modification to the database and return true if it should be allowed.": "データベースへの変更の提案を見て、許可すべきなら、trueを返す関数です。",
  "In newly created apps, Meteor allows almost any calls to <code>insert</code>, <code>update</code>, and <code>remove</code> from any client or server code. This is because apps started with <code>meteor create</code> include the <code>insecure</code> package by default to simplify development. Obviously, if any user could change the database whenever they wanted it would be bad for security, so it is important to remove the <code>insecure</code> package and specify some permissions rules, in your terminal:": "新しく作成されたアプリでは、Meteorはクライアントまたはサーバーコードからのほとんどの<code>insert</code>、<code>update</code>、<code>remove</code>の呼び出しを許可します。これは<code>meteor create</code>で始めたアプリには、デフォルトでシンプルに開発を行うための<code>insecure</code>パッケージが含まれているためです。当然ながら、誰もがどんな時にもデータベースを変更できるというのはセキュリティ的に良くありません。そこで、<code>insecure</code>パッケージを取り除き、いくつかのアクセス許可ルールを指定することが重要です。ターミナルで:",
  "Once you have removed the <code>insecure</code> package, use the <code>allow</code> and <code>deny</code> methods to control who can perform which operations on the database. By default, all operations on the client are denied, so we need to add some <code>allow</code> rules. Keep in mind that server code and code inside <a href=\"#meteor_methods\">methods</a> are not affected by <code>allow</code> and <code>deny</code> &#x2014; these rules only apply when <code>insert</code>, <code>update</code>, and <code>remove</code> are called from untrusted client code.": "一度<code>insecure</code>を取り除いたら、データベース操作を行えるユーザーをコントロールするために<code>allow</code>と<code>deny</code>メソッドを使用します。デフォルトでは、クライアント上でのすべての操作は拒否されるため、いくつかの許可ルールの追加が必要です。注意すべきは、サーバーコードと<a href=\"#meteor_methods\">methods</a>のコード内では、<code>allow</code>と<code>deny</code>は影響を与えない点です — これらのルールは、信頼されないクライアントコードからの<code>insert</code>、<code>update</code>、<code>remove</code>にのみ適用されます。",
  "For example, we might say that users can only create new posts if the <code>createdBy</code> field matches the ID of the current user, so that users can&apos;t impersonate each other.": "たとえば、現在のユーザーのIDと<code>createdBy</code>フィールドがマッチする場合のみ新しい記事を作成できるようにすると、他のユーザーがなりすましできなくなるでしょう。",
  "The <code>allow</code> method accepts three possible callbacks: <code>insert</code>, <code>remove</code>, and <code>update</code>. The first argument to all three callbacks is the <code>_id</code> of the logged in user, and the remaining arguments are as follows:": "<code>allow</code>メソッドは次の3つのコールバックを受け付けます: <code>insert</code>と<code>remove</code>と<code>update</code>。すべてのコールバックの第１引数には現在ログインしているユーザの<code>_id</code>が渡されます。残りの引数は次の通りです:",
  "<code>document</code> is the document that is about to be inserted into the database. Return <code>true</code> if the insert should be allowed, <code>false</code> otherwise.": "<code>document</code>はデータベースに挿入されようとしているドキュメントです。もし挿入を許可すべきなら<code>true</code>を返し、そうでなければ<code>false</code>を返します。",
  "<code>document</code> is the document that is about to be modified. <code>fieldNames</code> is an array of top-level fields that are affected by this change. <code>modifier</code> is the <a href=\"#mongo_modifiers\">Mongo Modifier</a> that was passed as the second argument of <code>collection.update</code>. It can be difficult to achieve correct validation using this callback, so it is recommended to use <a href=\"#meteor_methods\">methods</a> instead. Return <code>true</code> if the update should be allowed, <code>false</code> otherwise.": "<code>document</code>は変更されようとしているドキュメントです。<code>fieldNames</code>はこの変更によって影響を受ける最上位フィールドの配列です。<code>modifier</code>は<code>collection.update</code>の第２引数に渡された<a href=\"#mongo_modifiers\">Mongo Modifier</a>です。このコールバックを使用して正しい検証を行うのは難しいため、その場合は<a href=\"#meteor_methods\">methods</a>を代わりに使用することをおすすめします。更新を許可すべきなら<code>true</code>を返し、そうでなければ<code>false</code>を返します。",
  "<code>document</code> is the document that is about to be removed from the database. Return <code>true</code> if the document should be removed, <code>false</code> otherwise.": "<code>document</code>はデータベースから削除されようとしているドキュメントです。削除を許可すべきなら<code>true</code>を返し、そうでなければ<code>false</code>を返します。",
  "Override <code>allow</code> rules.": "<code>allow</code>ルールを上書きします。",
  "Functions that look at a proposed modification to the database and return true if it should be denied, even if an <a href=\"#allow\">allow</a> rule says otherwise.": "データベースへの変更の提案を見て、拒否すべきなら、trueを返す関数です。<a href=\"#allow\">allow</a>ルールで許可していても、denyルールで上書きされます",
  "The <code>deny</code> method lets you selectively override your <code>allow</code> rules. While only one of your <code>allow</code> callbacks has to return true to allow a modification, <em>every one</em> of your <code>deny</code> callbacks has to return false for the database change to happen.": "<code>deny</code>メソッドを使用して、<code>allow</code>ルールを選択的に上書きできます。<code>allow</code>コールバックのいずれかがtrueを返し、<em>全ての</em><code>deny</code>コールバックがfalseを返すことでデータベースの変更が許可されます。",
  "For example, if we wanted to override part of our <code>allow</code> rule above to exclude certain post titles:": "たとえば、前にでてきた<code>allow</code>ルールを上書きして、特定のタイトルの記事を除外したい場合は、以下のように記述します:",
  "To get accounts functionality, add one or more of the following packages to your app with <code>meteor add</code>:": "アカウント機能を使うには、下記のパッケージをひとつ以上追加する必要があります。<code>meteor add</code>コマンドを使います:",
  "Include the <code>loginButtons</code> template somewhere in your HTML to use Meteor&apos;s default UI for logging in. To use this, you need to add the <code>accounts-ui</code> package, in your terminal:": "<code>loginButtons</code>のテンプレートをHTMLのどこかに設置すると、MeteorのデフォルトのログインUIが使えます。これを使うには、次のように<code>accounts-ui</code>パッケージを追加する必要があります:",
  "Get the current user record, or <code>null</code> if no user is logged in. A reactive data source.": "現在ログイン中のユーザデータを返します。ログインしていない場合は、<code>null</code>が返ります。これはリアクティブデータです。",
  "Get the logged in user from the <a href=\"#meteor_users\"><code>Meteor.users</code></a> collection. Equivalent to <code>Meteor.users.findOne(Meteor.userId())</code>.": "<a href=\"#meteor_users\"><code>Meteor.users</code></a>コレクションからログインユーザのデータを取得します。<code>Meteor.users.findOne(Meteor.userId())</code>と同等です。",
  "Get the current user id, or <code>null</code> if no user is logged in. A reactive data source.": "現在ログイン中のユーザIDを返します。ログインしていない場合は、<code>null</code>が返ります。これはリアクティブデータです。",
  "A <a href=\"#collections\">Mongo.Collection</a> containing user documents.": "すべてのユーザデータを含む<a href=\"#collections\">Mongo.Collection</a>です。",
  "This collection contains one document per registered user. Here&apos;s an example user document:": "このコレクションは一人のユーザにつき一つのドキュメント(データ)を持ちます。下記がユーザドキュメントの一例です:",
  "A user document can contain any data you want to store about a user. Meteor treats the following fields specially:": "ユーザドキュメントには開発者が任意のデータを格納することができます。Meteorは下記のフィールドを特殊フィールドとして扱います。:",
  "Like all <a href=\"#collections\">Mongo.Collection</a>s, you can access all documents on the server, but only those specifically published by the server are available on the client.": "他のすべての<a href=\"#collections\">Mongo.Collection</a>と同じように、サーバにおいてはすべてのドキュメントにアクセスできる。しかし、クライアントにおいては明示的にpublishされたものしかアクセスできない。",
  "By default, the current user&apos;s <code>username</code>, <code>emails</code> and <code>profile</code> are published to the client. You can publish additional fields for the current user with:": "デフォルトでは、現在のユーザの<code>username</code>と<code>emails</code>と<code>profile</code>はpublishされクライアントからアクセスできる。それ以外のフィールドを現在のユーザにpublishするには次のようにする:",
  "If the autopublish package is installed, information about all users on the system is published to all clients. This includes <code>username</code>, <code>profile</code>, and any fields in <code>services</code> that are meant to be public (eg <code>services.facebook.id</code>, <code>services.twitter.screenName</code>). Additionally, when using autopublish more information is published for the currently logged in user, including access tokens. This allows making API calls directly from the client for services that allow this.": "autopublishパッケージがインストールされている状態ではシステム上のすべてのユーザの情報がすべてのクライアントにpublishされる。これは、<code>username</code>と<code>profile</code>と<code>services</code>内の公開フィールド(例:<code>services.facebook.id</code>と<code>services.twitter.screenName</code>)が含まれる。これに加えて、autopublishパッケージを使った場合は、現在ログインしているユーザにはアクセストークンなどさらに情報がpublishされる。これにより、許可されていれば、クライアントからサービスに直接API呼び出しができるようになる。",
  "Users are by default allowed to specify their own <code>profile</code> field with <a href=\"#accounts_createuser\"><code>Accounts.createUser</code></a> and modify it with <code>Meteor.users.update</code>. To allow users to edit additional fields, use <a href=\"#allow\"><code>Meteor.users.allow</code></a>. To forbid users from making any modifications to their user document:": "デフォルトではユーザは自分で<code>profile</code>フィールドを設定したり修正したりするこができる。設定は<a href=\"#accounts_createuser\"><code>Accounts.createUser</code></a>を使い、修正は<code>Meteor.users.update</code>を使う。ユーザに他のフィールドも追加で編集させるには、<a href=\"#allow\"><code>Meteor.users.allow</code></a>を使う。逆にユーザにドキュメントをまったく修正させないようにするには、次のようにする:",
  "Calls <a href=\"#meteor_user\">Meteor.user()</a>. Use <code>{{#if currentUser}}</code> to check whether the user is logged in.": "<a href=\"#meteor_user\">Meteor.user()</a>を呼び出す。ユーザがログインしていがかだけをチェックする場合は、<code>{{#if currentUser}}</code>を使う。",
  "Methods are server functions that can be called from the client. They are useful in situations where you want to do something more complicated than <code>insert</code>, <code>update</code> or <code>remove</code>, or when you need to do data validation that is difficult to achieve with just <code>allow</code> and <code>deny</code>.": "Methods(メソッド)はクライアントから呼ばれるサーバー関数です. これらは、<code>insert</code>、<code>update</code>や<code>remove</code>よりもっと複雑に何かをしたい状況や、<code>allow</code>と<code>deny</code>だけでは難しいデータバリデーションが必要な状況で便利なものです。",
  "Methods can return values and throw errors.": "Methods(メソッド)は戻り値とエラーを返します。",
  "Defines functions that can be invoked over the network by clients.": "クライアントによってネットワーク越しに呼び出される関数を定義します。",
  "Dictionary whose keys are method names and values are functions.": "辞書のキーはメソッド名で、バリューは関数です。",
  "Calling <code>Meteor.methods</code> on the server defines functions that can be called remotely by clients. Here&apos;s an example of a method that checks its arguments and throws an error:": "サーバー上での<code>Meteor.methods</code>の呼び出しは、クライアント側からリモートで呼び出すことのできる関数を定義します。ここでは、引数のチェックとエラーを返すメソッドの一例を示しています。",
  "The <a href=\"#check\"><code>check</code></a> function is a convenient way to enforce the expected <a href=\"#matchpatterns\">types and structure</a> of method arguments.": "ここでの<a href=\"#check\"><code>check</code></a>関数は、期待されるメソッド引数の<a href=\"#matchpatterns\">typesとstructure</a>を強制実行するための一つの便利な方法です。",
  "Inside your method definition, <code>this</code> is bound to a method invocation object, which has several useful properties, including <code>this.userId</code>, which identifies the currently logged-in user.": "メソッド定義上で、<code>this</code>はメソッド呼び出しにバインドされたオブジェクトです。<code>this</code>はいくつかの便利なプロパティを持ち、その内の<code>this.userId</code>は現状ログインしているユーザーを確認します。",
  "You don&apos;t have to put all your method definitions into a single <code>Meteor.methods</code> call; you may call it multiple times, as long as each method has a unique name.": "ひとつの<code>Meteor.methods</code>呼び出しにメソッド定義全てを置く必要はありません。ユニークな名前を各メソッドが持つ限り、あなたはこれを複数回呼び出すでしょう。",
  "Calling a method on the server requires a round-trip over the network. It would be really frustrating if users had to wait a whole second to see their comment show up due to this delay. That&apos;s why Meteor has a feature called <em>method stubs</em>. If you define a method on the client with the same name as a server method, Meteor will run it to attempt to predict the outcome of the server method. When the code on the server actually finishes, the prediction generated on the client will be replaced with the actual outcome of the server method.": "サーバー上でのメソッド呼び出しは、ネットワーク越しに往復が必要になります。例えば、このネットワークの往復によるディレイによって、ユーザーがコメントを表示させるのに数秒間待たなくてはならないのは非常にストレスになります。なぜならMeteorは<em>method stubs</em>という特徴を持っているからです。もし、あなたがクライアント上で一つのメソッドを一つのサーバーメソッドとして同じ名前で定義した場合、Meteorはサーバーメソッドからの結果を予測して試みる為に実行します。実際にサーバー上でコードが終了すると、クライアント上で生成されたその予測はサーバーメソッドの実際の結果に置き換えられます。",
  "The client versions of <a href=\"#insert\"><code>insert</code></a>, <a href=\"#update\"><code>update</code></a>, and <a href=\"#remove\"><code>remove</code></a>, which are implemented as methods, use this feature to make client-side interactions with the database appear instant.": "メソッドとして実装されたクライアント版の<a href=\"#insert\"><code>insert</code></a>や<a href=\"#update\"><code>update</code></a>や<a href=\"#remove\"><code>remove</code></a>は、クライアント側のインタラクションとデータベースに即時反映させるためにこの特徴を使います。",
  "Invokes a method passing any number of arguments.": "複数の引数を通して呼び出されます。",
  "Name of method to invoke": "呼び出すためのメソッド名",
  "Optional method arguments": "任意のメソッド引数",
  "Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).": "任意のコールバック（このメソッド完了後に結果やエラーと非同期的に呼ばれる）。もし引数が設定されてない場合、このメソッドは可能であれば同期的に実行される。（以下参照）",
  "This is how you call a method.": "以下は、メソッドの呼び出し方です。",
  "Methods called on the client run asynchronously, so you need to pass a callback in order to observe the result of the call. The callback will be called with two arguments, <code>error</code> and <code>result</code>. The <code>error</code> argument will be <code>null</code> unless an exception was thrown. When an exception is thrown, the <code>error</code> argument is a <code>Meteor.Error</code> instance and the <code>result</code> argument is undefined.": "メソッドはクライアント上で非同期的に実行されるので、呼び出し結果を監視するためにコールバックを渡す必要があります。そのコールバックは<code>error</code>と<code>result</code>の２つを引数として持ち、呼びだされます。<code>error</code>引数は、例外が投げられない限り<code>null</code>を返します。例外が投げられた場合、<code>error</code>引数は<code>Meteor.Error</code>インスタンスとなり、<code>result</code>はundefinedとなります。",
  "Here&apos;s an example of calling the <code>commentOnPost</code> method with arguments <code>comment</code> and <code>postId</code>:": "ここでの例では、<code>commentOnPost</code>メソッドを<code>comment</code>と<code>postId</code>の引数と共に呼び出しています。",
  "Meteor tracks the database updates performed as part of a method call, and waits to invoke the client-side callback until all of those updates have been sent to the client.": "Meteorはメソッド呼び出しの一部として機能したデータベースアップデートを追跡し、クライアントサイドのコールバックを呼び出すためにクライアントへそれら全てのアップデートが送られるまで待ちます。",
  "On the server, you don&apos;t have to pass a callback &#x2014; the method call will simply block until the method is complete, returning a result or throwing an exception, just as if you called the function directly:": "サーバー上では、コールバックを渡す必要はありません（ただ単に直接的に関数を呼び出すと、メソッドが結果や例外を返し完了するまでメソッド呼び出しは単純にブロックします）",
  "This class represents a symbolic error thrown by a method.": "このクラスは、何かのメソッドによって投げられたシンボリックエラーを表します。",
  "A string code uniquely identifying this kind of error. This string should be used by callers of the method to determine the appropriate action to take, instead of attempting to parse the reason or details fields. For example:": "文字列はエラーを特定するユニークなものとして表現します。この文字列は、reasonやdetailsをパースしようとする代わりに適切なアクションを決定するためのメソッドの呼び出し元によって使われるべきです。例えば:",
  "For legacy reasons, some built-in Meteor functions such as <code>check</code> throw errors with a number in this field.": "レガシーな理由のため、いくつかのビルトインなMeteorはエラー処理の順番確認のように機能します。",
  "Optional. A short human-readable summary of the error, like &apos;Not Found&apos;.": "任意。人間が読んで理解できるエラーの要約。",
  "Optional. Additional information about the error, like a textual stack trace.": "任意。エラーの追加情報。",
  "If you want to return an error from a method, throw an exception. Methods can throw any kind of exception, but <code>Meteor.Error</code> is the only kind of error that will be sent to the client. If a method function throws a different exception, the client gets <code>Meteor.Error(500, &apos;Internal server error&apos;)</code>.": "もし、メソッドから何かエラーを返してほしいならば、例外を投げてください。メソッドはいくつかの例外の種類を投げることができますが、<code>Meteor.Error</code>は唯一のクライアントへ送信されるエラーの種類です。もし何かのメソッド関数が異なる例外を投げる場合、クライアントは<code>Meteor.Error(500, &apos;Internal server error&apos;)</code>を受け取ります。",
  "Meteor servers can publish sets of documents with <code>Meteor.publish</code>, and clients can subscribe to those publications with <code>Meteor.subscribe</code>. Any documents the client subscribes to will be available through the <code>find</code> method of client collections.": "Meteorのサーバは、<code>Meteor.publish</code>メソッドによりドキュメントのセットを配信し、クライアントでは<code>Meteor.subscribe</code>メソッドで配信されたドキュメントを購読することができます。購読されたドキュメントは、クライアント側の<code>find</code>メソッドにより利用できるようになります。",
  "By default, every newly created Meteor app contains the <code>autopublish</code> package, which automatically publishes all available documents to every client. To exercise finer-grained control over what documents different clients receive, first remove <code>autopublish</code>, in your terminal:": "デフォルトでは、新規作成されたMeteorアプリケーションには<code>autopublish</code>パッケージが予め同梱されており、全ての利用可能なドキュメントは、全てのクライアントに自動で配信されます。クライアントそれぞれに配信するドキュメントをより細やかに制御したい場合、まずターミナル上で以下のコマンドを入力し、<code>autopublish</code>パッケージを削除しましょう。",
  "Now you can use <code>Meteor.publish</code> and <code>Meteor.subscribe</code> to control what documents flow from the server to its clients.": "これで、<code>Meteor.publish</code>と<code>Meteor.subscribe</code>を使って、どのドキュメントをサーバからクライアントへ流すかを制御できるようになります。",
  "Publish a record set.": "レコードのセットを配信します。",
  "Name of the record set. If <code>null</code>, the set has no name, and the record set is automatically sent to all connected clients.": "配信するデータの名称。<code>null</code>がセットされた場合、配信されるデータには名称が設定されず、自動的に接続している全てのクライアントに配信されます。",
  "Function called on the server each time a client subscribes. Inside the function, <code>this</code> is the publish handler object, described below. If the client passed arguments to <code>subscribe</code>, the function is called with the same arguments.": "クライアントから購読されるたびにサーバで実行される関数。関数の処理中で<code>this</code>は、後述する配信を制御するオブジェクトを指し示します。クライアント側で<code>subscribe</code>メソッドの同引数を省略すると、サーバ側と同じ関数が実行されます。",
  "To publish data to clients, call <code>Meteor.publish</code> on the server with two arguments: the name of the record set, and a <em>publish function</em> that will be called each time a client subscribes to this record set.": "クライアントにデータを配信するには、サーバ側で以下の2つの引数をセットして<code>Meteor.publish</code>メソッドを実行します。1つは配信データの名称。もう1つは、クライアント側で配信データへの購読要求が行われるたびに呼び出される<em>配信関数</em>です。",
  "Publish functions typically return the result of calling <code>collection.find(query)</code> on some <code>collection</code> with a <code>query</code> that narrows down the set of documents to publish from that collection:": "配信関数では一般的に、配信するドキュメントのセットを<code>collection.find(query)</code>によって絞りこんで取得し返却します。",
  "You can publish documents from multiple collections by returning an array of <code>collection.find</code> results:": "<code>collection.find</code>の結果を配列として返すことで、複数のコレクションから取得したドキュメントを配信することも可能です。",
  "Inside the publish function, <code>this.userId</code> is the current logged-in user&apos;s <code>_id</code>, which can be useful for filtering collections so that certain documents are visible only to certain users. If the logged-in user changes for a particular client, the publish function will be automatically rerun with the new <code>userId</code>, so the new user will not have access to any documents that were meant only for the previous user.": "配信関数の処理内では、<code>this.userId</code>は現在ログインしているユーザの<code>_id</code>を指し示しており、これは、特定のドキュメントを特定のユーザにのみ表示するよう制限をかけるのに役立ちます。 もし、クライアントのログインユーザが変わると、配信関数は自動的に新しいユーザの<code>userId</code>を元に再実行されるため、新しいユーザは以前のユーザに対してのみ提供されていたドキュメントにはアクセスできなくなります。",
  "Subscribe to a record set. Returns a handle that provides <code>stop()</code> and <code>ready()</code> methods.": "データの購読登録を行います。返却されるオブジェクトは、<code>stop()</code>メソッドと<code>ready()</code>メソッドを提供します。",
  "Name of the subscription. Matches the name of the server&apos;s <code>publish()</code> call.": "購読するデータの名称。サーバ側で同じ名称が設定された<code>publish()</code>メソッドが呼び出されます。",
  "Optional arguments passed to publisher function on server.": "サーバ側の配信関数へ受け渡される引数を任意で設定する。",
  "Optional. May include <code>onStop</code> and <code>onReady</code> callbacks. If there is an error, it is passed as an argument to <code>onStop</code>. If a function is passed instead of an object, it is interpreted as an <code>onReady</code> callback.": "任意で設定可能。<code>onStop</code>メソッドと<code>onReady</code>メソッドを含めることができます。エラーが発生した場合は<code>onStop</code>メソッドの引数となります。オブジェクトの代わりに関数が渡された場合、<code>onReady</code>メソッドのコールバック関数として解釈されます。",
  "Clients call <code>Meteor.subscribe</code> to express interest in document collections published by the server. Clients can further filter these collections of documents by calling <a href=\"#find\"><code>collection.find(query)</code></a>. Whenever any data that was accessed by a publish function changes on the server, the publish function is automatically rerun and the updated document collections are pushed to the subscribed client.": "クライアント側で<code>Meteor.subscribe</code>メソッドを呼び出すことで、サーバから配信されたドキュメントのコレクションに対する関係性を明示します。クライアント側で<a href=\"#find\"><code>collection.find(query)</code></a>を使うと、ドキュメントのコレクションを更に絞り込んで取得することもできます。サーバ側で配信関数が手に入れたデータに変更があった場合、配信関数は自動的に再実行され、更新されたドキュメントのコレクションは購読中のクライアントへと送り出されます。",
  "The <code>onReady</code> callback is called with no arguments when the server has sent all of the initial data for the subscription. The <code>onStop</code> callback is when the subscription is terminated for any reason; it receives a <a href=\"#meteor_error\"><code>Meteor.Error</code></a> if the subscription failed due to a server-side error.": "<code>onReady</code>メソッドは、購読の初期化に必要なデータをサーバが送り終えた時に、引数無しで実行されます。<code>onStop</code>メソッドは、何らかの理由で購読が終了した時に実行されます。サーバ側でのエラーなどにより購読に失敗すると、<a href=\"#meteor_error\"><code>Meteor.Error</code></a>を受け取ります。",
  "<code>Meteor.subscribe</code> returns a subscription handle, which is an object with the following methods:": "<code>Meteor.subscribe</code>メソッドは戻り値として、購読を制御する以下のメソッドを持ったオブジェクトを返します。",
  "Cancel the subscription. This will typically result in the server directing the client to remove the subscription&apos;s data from the client&apos;s cache.": "購読を中止します。通常 購読を中止すると、キャッシュから購読のためのデータを削除するよう、サーバからクライアントへ命令が出されます。",
  "Returns true if the server has <a href=\"#publish_ready\">marked the subscription as ready</a>. A reactive data source.": "<a href=\"#publish_ready\">購読の準備が整った</a>とサーバが判断した場合にTrueが返されます。",
  "If you call <code>Meteor.subscribe</code> inside <a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>, the subscription will be cancelled automatically whenever the computation reruns (so that a new subscription can be created, if appropriate), meaning you don&apos;t have to to call <code>stop</code> on subscriptions made from inside <code>Tracker.autorun</code>.": "<a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>メソッドの内部で<code>Tracker.autorun</code>メソッドが呼ばれた場合、処理が再実行されるたび自動的に購読は中止されます。（結果的に、新規の購読は適切な手順で作成することができます。）つまり、<code>Tracker.autorun</code>メソッドの内部で生成された購読を停止させるために<code>stop</code>メソッドを呼び出す必要はないのです。",
  "Boolean variable. True if running in client environment.": "真偽値。クライアント環境の場合Trueになる。",
  "Boolean variable. True if running in server environment.": "真偽値。サーバ環境の場合Trueになる。",
  "<code>Meteor.isServer</code> can be used to limit where code runs, but it does not prevent code from being sent to the client. Any sensitive code that you don&apos;t want served to the client, such as code containing passwords or authentication mechanisms, should be kept in the <code>server</code> directory.": "<code>Meteor.isServer</code>はそのコードがどこで動くかを制限することには使えますが、そのコードがクライアント側に送られることは阻止しません。クライアントに送りたくない秘密のコード<code>server</code>に格納すべきです。例えば、パスワードや認証のメカニズムが含まれているコードなどが該当します。",
  "Run code when a client or a server starts.": "クライアントやサーバが起動したときにコードを実行する。",
  "A function to run on startup.": "起動時に実行する関数",
  "On the server, the callback function will run as soon as the server process is finished starting up. On the client, the callback function will run as soon as the page is ready.": "サーバ側ではコールバック関数はサーバ起動完了後すぐに実行されます。クライアント側ではコールバック関数はページが準備完了になった後すぐに実行されます。",
  "It&apos;s good practice to wrap all code that isn&apos;t inside template events, template helpers, <code>Meteor.methods</code>, <code>Meteor.publish</code>, or <code>Meteor.subscribe</code> in <code>Meteor.startup</code> so that your application code isn&apos;t executed before the environment is ready.": "ひとつのよい方法として、テンプレートイベント、テンプレートヘルパー、<code>Meteor.methods</code>、<code>Meteor.publish</code>、<code>Meteor.subscribe</code>以外のすべてのコードを<code>Meteor.startup</code>に入れてしまう方法があります。そうすると、環境が準備される前にコードが実行されてしまうことがなくなります。",
  "For example, to create some initial data if the database is empty when the server starts up, you might use the following pattern:": "例えば、サーバ起動時にデータベースが空であれば初期データを作成するためには次のようにします:",
  "If you call <code>Meteor.startup</code> on the server after the server process has started up, or on the client after the page is ready, the callback will fire immediately. <!-- XXX It should still fire asynchronously, though -->": "サーバ起動後やクライアント起動後に<code>Meteor.startup</code>を呼び出した場合はコールバック関数はすぐに実行されます。<!-- XXX ただし非同期に実行されます。 -->",
  "All of Meteor&apos;s functionality is implemented in modular packages. In addition to the core packages documented above, there are many others that you can add to your app to enable useful functionality.": "Meteorの機能のすべては、モジュラーパッケージとして実装されています。上記で説明したコアパッケージに加え、他の多くのパッケージを便利な機能を有効にするために追加することができます。",
  "From the command line, you can add and remove packages with <code>meteor add</code> and <code>meteor remove</code>:": "コマンドラインで、<code>meteor add</code>や<code>meteor remove</code>を実行するとパッケージの追加や削除ができます:",
  "Your app will restart itself automatically when you add or remove a package. An app&apos;s package dependencies are tracked in <code>.meteor/packages</code>, so your collaborators will be automatically updated to the same set of installed packages as you after they pull your source code, because they have the same <code>.meteor/packages</code> file as you.": "パッケージを追加または削除すると、自動的にアプリがリロードされます。アプリのパッケージは<code>.meteor/packages</code>の中で追跡されており、あなたと同じ<code>.meteor/packages</code>ファイルを使用しているコラボレーターは、ソースコードをプルした後に自動的にあなたがインストールしたパッケージと同じセットに更新されます。",
  "You can see which packages are used by your app by running <code>meteor list</code> in the app&apos;s directory.": "アプリディレクトリ内で<code>meteor list</code>コマンドを実行すると、あなたのアプリがどのパッケージを使用しているか確認できます。",
  "Packages that have a <code>:</code> in the name, such as <code>mquandalle:jade</code>, are written and maintained by community members. The prefix before the colon is the name of the user or organization who created that package. Unprefixed packages are maintained by Meteor Development Group as part of the Meteor framework.": "パッケージ名はコロン区切りで記載され、コロンの前はパッケージを作成したユーザーです。記載のないものはMeteor Development Groupによりメンテナンスされています。",
  "There are currently over 2000 packages available on Atmosphere. Below is a small selection of some of the most useful packages.": "現在Atmosphereには2000以上のパッケージが存在します。あなたにあったものが見つかるでしょう。",
  "This is a drop-in user interface to Meteor&apos;s accounts system. After adding the package, include it in your templates with <code>{{&gt; loginButtons}}</code>. The UI automatically adapts to include controls for any added login services, such as <code>accounts-password</code>, <code>accounts-facebook</code>, etc.": "accounts-uiはMeteor上のアカウントシステムです。パッケージを追加したあと、テンプレートに<code>{{&gt; loginButtons}}</code>を追加します。accounts-uiはソーシャルログインやログインのための機能を自動的に追加することができます。",
  "<a href=\"#/basic/accounts\">See the docs about accounts-ui above.</a>.": "<a href=\"#/basic/accounts\">accounts-uiについてのドキュメントを御覧ください。</a>",
  "Use <a href=\"http://coffeescript.org/\">CoffeeScript</a> in your app. With this package, any files with a <code>.coffee</code> extension will be compiled to JavaScript by Meteor&apos;s build system.": "coffeescriptをMeteorで利用するには<a href=\"http://coffeescript.org/\">Coffeescriptパッケージ</a>を追加してください。.coffeeの拡張子を持つファイルがJavaScriptにコンパイルされるようになります。",
  "Send emails from your app. See the <a href=\"#/full/email\">email section of the full API docs</a>.": "emailを送信するには、<a href=\"#/full/email\">Full APIのメール送信の章を御覧ください。</a>",
  "JQuery makes HTML traversal and manipulation, event handling, and animation easy with a simple API that works across most browsers.": "JQueryはシンプルなAPIで簡単にDOM操作が可能にします。",
  "JQuery is automatically included in every Meteor app since the framework uses it extensively. See the <a href=\"http://jquery.com/\">JQuery docs</a> for more details.": "JQueryは自動的にMeteorアプリに含まれています。詳細は<a href=\"http://jquery.com/\">JQueryのドキュメント</a>を御覧ください。",
  "This package allows you to make HTTP requests from the client or server using the same API. See the <a href=\"#/full/http\">http docs</a> to see how to use it.": "このパッケージを利用すると、クライアントまたはサーバーからのHTTPリクエストが可能になります。詳細は<a href=\"#/full/http\">httpのドキュメント</a>を御覧ください。",
  "Add the <a href=\"http://lesscss.org/\">LESS</a> CSS preprocessor to your app to compile any files with a <code>.less</code> extension into standard CSS. If you want to use <code>@import</code> to include other files and not have Meteor automatically compile them, use the <code>.import.less</code> extension.": ".less拡張子を持つファイルをコンパイルするために、CSSプリプロセッサの<a href=\"http://lesscss.org/\">LESS</a>を追加します。Meteorがコンパイルしてもいいファイルには<code>@import</code>を、コンパイルしないファイルには<code>.import.less</code>を使用してください。",
  "Include <a href=\"http://daringfireball.net/projects/markdown/syntax\">Markdown</a> code in your templates. It&apos;s as easy as using the <code>{{# markdown}}</code> helper:": "<a href=\"http://daringfireball.net/projects/markdown/syntax\">Markdown</a>を使用する場合は、<code>{{# markdown}}</code>をご使用ください。",
  "Just make sure to keep your markdown unindented, since whitespace matters.": "Markdownはインデントしないように注意してください。",
  "<a href=\"http://underscorejs.org/\">Underscore</a> provides a collection of useful functions to manipulate arrays, objects, and functions. <code>underscore</code> is included in every Meteor app because the framework itself uses it extensively.": "<a href=\"http://underscorejs.org/\">Underscore</a>は、配列、オブジェクト、functionを操作するためのコレクションを提供します。MeteorはUnderscoreを利用しているため、Meteorには既にincludeされています。",
  "This package gives your app server-side rendering to allow search engine crawlers and other bots see your app&apos;s contents. If you care about SEO, you should add this package.": "このパッケージは、検索エンジンのクローラや他のボットがアプリの内容を参照できるように、アプリケーションのサーバー側のレンダリングを提供します。SEO施策を行う際は、このパッケージをご利用ください。",
  "Congratulations, you&apos;re at the end of the Meteor basic documentation. For more advanced features and more specific explanations, check out the <a href=\"#/full/\">Full API Docs</a>.": "MeteorのBasicドキュメントは終了です。より詳しい説明は、<a href=\"#/full/\">Full API Docs</a>を御覧ください。",
  "Whenever the indicated event happens on the selected element, the corresponding event handler function will be called with the relevant DOM event object and template instance. See the [Event Maps section](#eventmaps) for details.": "対象とした要素に指定したイベントが発生すると、対応するイベントハンドラが呼び出されます。第一引数がDOMイベントオブジェクトで、第二引数がテンプレートインスタンスです。詳しくは、Event Mapsセクションを参照してください。",
  "Meteor is two things:": "Meteorにおける2つのもの",
  "A <em>library of packages</em>: pre-written, self-contained modules that you might need in your app.": "<em>パッケージ化されたライブラリー</em>:すでに書かれていて、自己完結しているモジュールはあなたのアプリケーションに必須のものでしょう。",
  "A <em>command-line tool</em> called <code>meteor</code>.": "<code>Meteor</code> <em>コマンドラインツール</em>",
  "<code>meteor</code> is a build tool analogous to <code>make</code>, <code>rake</code>, or the non-visual parts of Visual Studio. It gathers up all of the source files and assets in your application, carries out any necessary build steps (such as compiling <a href=\"http://coffeescript.org\">CoffeeScript</a>, minifying CSS, building <a href=\"https://npmjs.org/\">npm</a> modules, or generating source maps), fetches the packages used by your app, and outputs a standalone, ready-to-run application bundle. In development mode it can do all of this interactively, so that whenever you change a file you immediately see the changes in your browser. It&apos;s super easy to use out of the box, but it&apos;s also extensible: you can add support for new languages and compilers by adding build plugin packages to your app.": "<code>meteor</code>は<code>make</code>,<code>rake</code>に似たビルドツールです。それかまた、GUIの無いVisual Studioです。<code>meteor</code>はアプリケーション内のソースファイルとアセットをまとめあげ、必要とされるビルドを行います（<a href=\"http://coffeescript.org\">CoffeeScript</a>のコンパイル , minifying CSS, npm module の構築 <a href=\"https://npmjs.org/\">npm</a> ,またsource mapの生成などです。)",
  "The key idea in the Meteor package system is that <em>everything should work identically in the browser and on the server</em> (wherever it makes sense, of course: browsers can&apos;t send email and servers can&apos;t capture mouse events). Our whole ecosystem has been built from the ground up to support this.": "Meteorのパッケージシステムの鍵となるアイデアは、パッケージは<em>ブラウザとサーバー上で全く同じように動くべきだ</em>というものですす。( ブラウザはE-mailをサーバーに送ることができ、サーバーはマウスのイベントを捕捉することができるのです。我々のエコシステムはこれを完全に実現するために作られました。)",
  "A Meteor application is a mix of client-side JavaScript that runs inside a web browser or PhoneGap mobile app, server-side JavaScript that runs on the Meteor server inside a <a href=\"http://nodejs.org/\">Node.js</a> container, and all the supporting HTML templates, CSS rules, and static assets. Meteor automates the packaging and transmission of these different components, and it is quite flexible about how you choose to structure those components in your file tree.": "Meteorのアプリケーションの構成要素はウェブブラウザやモバイルアプリで動くクライアント・サイドJavaScriptと、Node.jsコンテナ内のMeteorサーバーで動くサーバーサイドJavaScript、そしてHTMLテンプレート、CSS、静的アセットなどからできています。Meteorはこれらの様々なコンポーネントを自動的にパッケージング、送信を行っています。そしてそれらのコンポーネントを含むファイル・ツリー内で、どう構造化するかは非常に自由度が高いものになっています。",
  "By default, any JavaScript files in your Meteor folder are bundled and sent to the client and the server. However, the names of the files and directories inside your project can affect their load order, where they are loaded, and some other characteristics. Here is a list of file and directory names that are treated specially by Meteor:": "初期状態では、Meteorフォルダー内にあるJavaScriptファイルはひと固まりであり、クライアントとサーバー双方に送られています。しかしながら、ファイルやディレクトリの名前によって、ファイルのロードのされ方を変えることができます。あるファイルはクライアント側にロードされ、他のはサーバー固有のファイルにできます。Meteorにおいて特別に扱われるファイル名とディレクトリ名は、以下のリストにあるものです。",
  "Any directory named <code>client</code> is not loaded on the server. Similar to wrapping your code in <code>if (Meteor.isClient) { ... }</code>. All files loaded on the client are automatically concatenated and minified when in production mode. In development mode, JavaScript and CSS files are not minified, to make debugging easier. (CSS files are still combined into a single file for consistency between production and development, because changing the CSS file&apos;s URL affects how URLs in it are processed.)": "<code>client</code>ディレクトリはサーバー側には読み込まれません。<code>if(Meteor.isClient){ ... }</code>で囲んだ部分も同様です。クライアントに読み込まれたすべてのファイルは、production モードの時には自動的に結合、縮小化されます。developmentモードではJavaScriptとCSSファイルは、デバッグしやすくするために縮小化は行いません。（CSSファイルの場合は,URL変更がCSS読み込みに影響するので、productionとdevelopmentの双方で単一のファイルに結合されています。)",
  "HTML files in a Meteor application are treated quite a bit differently from a server-side framework. Meteor scans all the HTML files in your directory for three top-level elements: <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, and <code>&lt;template&gt;</code>. The head and body sections are separately concatenated into a single head and body, which are transmitted to the client on initial page load.": "MeteorアプリケーションにおけるHTMLファイルの扱いは、サーバーサイドフレームワークにおけるものと異なっています。Meteorはディレクトリ内のHTMLファイルにおいて、３つのトップレベル要素でスキャンします。:<code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;template&gt;</code>の３つです。headとbodyはそれぞれ分けられて、一つのheadと一つのbodyに結合されます。それらはページの最初のローディングの際にクライアントに転送されます。",
  "Any directory named <code>server</code> is not loaded on the client. Similar to wrapping your code in <code>if (Meteor.isServer) { ... }</code>, except the client never even receives the code. Any sensitive code that you don&apos;t want served to the client, such as code containing passwords or authentication mechanisms, should be kept in the <code>server</code> directory.": "<code>server</code>と名づけられているディレクトリはクライアントにロードされません。<code>if (Meteor.isServer) { ... }</code>で囲まれたコードも同様であり、クライアントが受け取ることがありません。パスワードや認証機能のように、クライアント側に送られたくないコードは<code>server</code>ディレクトリに入れて置かなければなりません。",
  "Meteor gathers all your JavaScript files, excluding anything under the <code>client</code>, <code>public</code>, and <code>private</code> subdirectories, and loads them into a Node.js server instance. In Meteor, your server code runs in a single thread per request, not in the asynchronous callback style typical of Node. We find the linear execution model a better fit for the typical server code in a Meteor application.": "MeteorはすべてのJavaScriptファイルを、<code>client</code>, <code>public</code>, <code>private</code>のディレクトリの例外なくNode.jsサーバーのインスタンスにロードします。Meteorでは、サーバーのコードはNode.jsの非同期コールバック処理内ではなく、各リクエスト当たりに一つのスレッドを割り当てています。Meteorアプリケーションにおいては、典型的な直線的な実行モデルが適していると考えています。",
  "All files inside a top-level directory called <code>public</code> are served as-is to the client. When referencing these assets, do not include <code>public/</code> in the URL, write the URL as if they were all in the top level. For example, reference <code>public/bg.png</code> as <code>&lt;img src=&apos;/bg.png&apos; /&gt;</code>. This is the best place for <code>favicon.ico</code>, <code>robots.txt</code>, and similar files.": "<code>public</code>というディレクトリ名のトップレベルディレクトリの中にあるファイルは、クライアント側にあるかのように扱われます。それらのassetsを参照する場合は、URLに<code>public</code>含めないでください。すべてのファイルがトップレベルにあるものとして書きます。例えば、<code>public/bg.png</code>は<code>&lt;img src=&apos;/bg.png&apos; /&gt;</code>のように書きます。<code>favicon.ico</code> や<code>robots.txt</code>はここに置くのがよいでしょう。",
  "All files inside a top-level directory called <code>private</code> are only accessible from server code and can be loaded via the <a href=\"#assets\"><code>Assets</code></a> API. This can be used for private data files and any files that are in your project directory that you don&apos;t want to be accessible from the outside.": " <code>private</code>というディレクトリ名のトップレベルディレクトリは、サーバーからのみアクセスすることができ、<a href=\"#assets\"><code>Assets</code></a> APIを通してロードできます。プライベートなデータファイルや外部からアクセスされたくないファイルの置き場所として使えます。",
  "This folder is for compatibility JavaScript libraries that rely on variables declared with var at the top level being exported as globals. Files in this directory are executed without being wrapped in a new variable scope. These files are executed before other client-side JavaScript files.": "このフォルダーは互換性のあるJavaScriptライブラリーのファイルのためであり、global変数としてトップレベルでvar宣言している変数を信頼しています。この中のファイルは新しい変数スコープでラップされるることなく実行されます。また、ここにあるファイルは他のクライアント・サイトのJavascriptファイルより以前に実行されます。",
  "Any directory named <code>tests</code> is not loaded anywhere. Use this for any local test code.": "<code>tests</code>という名前のディレクトリはロードされません。ローカル環境のテストコードとして使われます。",
  "For compatibility with node.js tools used alongside Meteor, any directory named <code>node_modules</code> is not loaded anywhere. node.js packages installed into <code>node_modules</code> directories will not be available to your Meteor code. Use <code>Npm.depends</code> in your package <code>package.js</code> file for that.": "Meteorと共に使われるnode.jsツールとの互換性のため、<code>node_modules</code>というディレクトリはどこにもロードされません。<code>node_modules</code>ディレクトリにインストールされたnode.jsパッケージはMeteorのコードからは直接使用できません。<code>package.js</code>のファイルの中で<code>Npm.depends</code>を使用してください。",
  "All of the functionality you&apos;ve read about so far is implemented in standard Meteor packages. This is possible thanks to Meteor&apos;s unusually powerful isomorphic package and build system. Isomorphic means the same packages work in the web browser, in mobile apps, and on the server. Packages can also contain plugins that extend the build process, such as <code>coffeescript</code> (<a href=\"http://coffeescript.org\">CoffeeScript</a> compilation) or <code>templating</code> (compiling HTML templates).": "ここまでところ、あたなが読んだ全ての機能は、標準のMeteorパッケージで実装されています。 ここまでできるのは、Meteorの非常にパワフルでisomorphicなパッケージとビルドシステムのおかげです。 isomorphicとは、同じパッケージが、Webブラウザ、モバイルアプリ、サーバーで動くということです。 パッケージは、<code>coffeescript</code>(<a href=\"http://coffeescript.org\">CoffeeScript</a>のコンパイル)や、 <code>templating</code> ( HTMLテンプレートのコンパイル)のようなビルド・プロセスを拡張するプラグインを含むこともできます",
  "You can add packages to your project with <a href=\"#meteoradd\"><code>meteor add</code></a> and remove them with <a href=\"#meteorremove\"><code>meteor remove</code></a>. Additionally, <a href=\"#meteorlist\"><code>meteor list</code></a> will tell you what packages your project is using, and <a href=\"#meteorupdate\"><code>meteor update</code></a> will update them to the newest versions when possible.": "あなたのプロジェクトには、<a href=\"#meteoradd\"><code>meteor add</code></a>を利用してパッケージを追加することができます。 また、<a href=\"#meteorremove\"><code>meteor remove</code></a>をつかって削除することもできます。 さらに、<a href=\"#meteorlist\"><code>meteor list</code></a>で、あなたのプロジェクトがどのパッケージを利用しているか確認することができます。 <a href=\"#meteorupdate\"><code>meteor update</code></a>をつかうと、利用可能な場合パッケージを最新バージョンに更新することもできます。",
  "By default all apps include the <code>meteor-base</code> package. This pulls in the packages that make up the core of the Meteor stack. Most apps will have this package.": "デフォルトでは、全てのアプリには<code>meteor-base</code>パッケージが含まれています。 これによりMeteorスタックの中核を成すパッケージ群を取り込みます。 ほとんどのアプリをこのパッケージを使うことになるでしょう。",
  "All new apps also start with a set of packages that allow a friendly development experience. For more information about these packages, check out the comments in the <a href=\"https://github.com/meteor/meteor/blob/master/tools/skel/.meteor/packages\">packages file</a>.": "全ての新しいアプリの作成は、心地よいディベロップメント・エクスペリエンスを提供するための一揃いのパッケージと共に開始されます。 これらのパッケージについては、<a href=\"https://github.com/meteor/meteor/blob/master/tools/skel/.meteor/packages\">packages file</a>のコメントを確認してください。",
  "Meteor uses a single-loading packaging system, meaning that it loads just one version of every package. Before adding or upgrading to a particular version of a package, Meteor uses a constraint solver to check if doing so will cause other packages to break. By default, Meteor will choose conservatively. When adding transitive dependencies (packages that other packages, but not the application itself) depend on, Meteor will try to choose the earlier version.": "Meteorは、シングル・ローディング パッケージングシステムを使っています。これは、それぞれのパッケージに対して、唯一のバージョンをロードするという意味です。 特定のバージョンのパッケージを追加や更新する前に、Meteorはconstraint solverをつかって、その操作が他のパッケージを壊さないか確認します。 Meteorはデフォルトでは保守的な選択をします。 間接的な依存パッケージ（そのアプリケーション自身ではなく、そこから他のパッケージを依存パッケージとして取り込む間接的なパッケージ）を追加する時、Meteorは最も古いバージョンを選択します。",
  "In addition to the packages in the official Meteor release being used by your app, <code>meteor list</code> and <code>meteor add</code> also search the <code>packages</code> directory at the top of your app. You can also use the <code>packages</code> directory to break your app into subpackages for your convenience, or to test packages that you might want to publish. See <a href=\"#writingpackages\">Writing Packages</a>. If you wish to add packages outside of your app&apos;s folder structure, set the environment variable <code>PACKAGE_DIRS</code> to a colon-delimited list of paths.": "あなたのアプリに使われているオフィシャルなMeteorリリースに含まれるパッケージに加えて、<code>meteor list</code> と <code>meteor add</code> は、あなたのアプリの直下におかれた<code>packages</code>ディレクトリも同様に検索します。 <code>packages</code> ディレクトリはあなたのアプリをサブパッケージに分解するための便利な方法です。公開したいパッケージをテストするためにも使うことができます。 <a href=\"#writingpackages\">Writing Packages</a>を参考にしてください。 もしパッケージをあなたのアプリのフォルダ構成の外側で追加したいのであれば、コロン区切りのパスのリストを環境変数<code>PACKAGE_DIRS</code>に設定してください。",
  "Meteor&apos;s namespacing support makes it easy to write large applications in JavaScript. Each package that you use in your app exists in its own separate namespace, meaning that it sees only its own global variables and any variables provided by the packages that it specifically uses. Here&apos;s how it works.": "Meteorの名前空間サポートはJavaScriptでの大規模アプリケーションの作成を容易にします。\nあなたのアプリで利用するそれぞれのパッケージは、それぞれ独自に分けられた名前空間の中に存在しています。\nつまり、各パッケージは自分のグローバル変数と、そこから明示的に利用しているパッケージの変数のみを参照するということです。\n以下、どのように動くかという説明です。",
  "When you declare a top-level variable, you have a choice. You can make the variable File Scope or Package Scope.": "トップレベルの変数を宣言するとき、あなたには選択肢があります。\nファイル・スコープにするか、またはパッケージ・スコープにするかです。",
  "Notice that this is just the normal JavaScript syntax for declaring a variable that is local or global. Meteor scans your source code for global variable assignments and generates a wrapper that makes sure that your globals don&apos;t escape their appropriate namespace.": "これはJavaScriptの通常の、ローカルまたは\nグローバル変数を宣言するシンタックスであるということに注意をしてください。\nMeteorはあなたのソースコードをスキャンして、グローバル変数の割当てを探し、\nあなたのグローバル変数が正しい名前空間から漏れないようにするためのラッパーを生成します。",
  "In addition to File Scope and Package Scope, there are also Exports. An export is a variable that a package makes available to you when you use it. For example, the <code>email</code> package exports the <code>Email</code> variable. If your app uses the <code>email</code> package (and <em>only</em> if it uses the <code>email</code> package!) then your app can see <code>Email</code> and you can call <code>Email.send</code>. Most packages have only one export, but some packages might have two or three (for example, a package that provides several classes that work together).": "\nファイルスコープとパッケージスコープに加えて、エクスポートもあります。\nエクスポートとは、パッケージがあなたがつかえるように、ある変数を提供するための仕組みです。\nたとえば、<code>email</code>パッケージは<code>Email</code>変数をエクスポートします。\nもしあなたのアプリが<code>email</code>パッケージを使う(そして、\nあなたが<code>email</code>パッケージ<em>だけ</em>を使う!)のなら、\nあなたのアプリは<code>Email</code>を参照でき、<code>Email.send</code>を呼ぶことができます。\nほとんどのパッケージはエクスポートを１つだけ持っていますが、\nいくつかのパッケージはエクスポートを２つか３つもっていることもあります。\n（例えば、互いに動作する幾つかのクラスを提供するパッケージなど）\n",
  "You see only the exports of the packages that you use directly. If you use package A, and package A uses package B, then you only see package A&apos;s exports. Package B&apos;s exports don&apos;t &quot;leak&quot; into your namespace just because you used package A. This keeps each namespace nice and tidy. Each app or package only sees their own globals plus the APIs of the packages that they specifically asked for.": "\nあなたは、直接つかうパッケージのエクスポートだけ見ることができます。\nもしあなたがパッケージAを使い、パッケージAがパッケージBを使っているとき、\n見えるのはパッケージAのエクスポートだけです。\nパッケージBのエクスポートはあなたがパッケージAをつかっているからといって、\nあなたの名前空間に&quot;漏れ&quot;たりしません。\nこうして、それぞれの名前空間はきれいに保たれます。\n各アプリまたはパッケージは、それぞれ各自のグローバル変数と、明示的に指定したパッケージのAPIのみ、見ることができるのです。\n",
  "When debugging your app, your browser&apos;s JavaScript console behaves as if it were attached to your app&apos;s namespace. You see your app&apos;s globals and the exports of the packages that your app uses directly. You don&apos;t see the variables from inside those packages, and you don&apos;t see the exports of your transitive dependencies (packages that aren&apos;t used directly by your app, but that are used by packages that are used by your app).": "\nあなたのアプリをデバッグするとき、ブラウザのJavaScriptコンソールは、あたかもあなたのアプリの名前空間に接続されたかのように振る舞います。\nあなたのアプリのグローバル変数とあなたのアプリが直接使うパッケージのエクスポート変数を見ることができます。\nこれら直接利用するパッケージの内側の変数や、間接的な依存性\n（直接あなたのアプリから利用していないが、あなたのアプリが使うパッケージがつかっているパッケージ）のエクスポート変数は見ることができません。\n",
  "If you want to look inside packages from inside your in-browser debugger, you&apos;ve got two options:": "\nもし、ブラウザの中のデバッガからパッケージの中身が見たいのなら、２つのオプションがあります:",
  "Set a breakpoint inside package code. While stopped on that breakpoint, the console will be in the package&apos;s namespace. You&apos;ll see the package&apos;s package-scope variables, imports, and also any file-scope variables for the file you&apos;re stopped in.": "パッケージのコードにブレークポイントをセットする。ブレークポイントで止まっている間は、コンソールはパッケージの名前空間にいます。\nパッケージスコープの変数、インポート、それに止めたファイル内の全てのファイルスコープ変数を見ることができます。\n",
  "If a package <code>foo</code> is included in your app, regardless of whether your app uses it directly, its exports are available in <code>Package.foo</code>. For example, if the <code>email</code> package is loaded, then you can access <code>Package.email.Email.send</code> even from namespaces that don&apos;t use the <code>email</code> package directly.": "もし、パッケージ<code>foo</code>があなたのアプリに入っていたら、あなたのアプリがそれを直接つかうかどうかに関わらず、\nそれのエクスポートは<code>Package.foo</code>の中で利用可能です。例えば、<code>email</code> パッケージが読み込まれたら、\nたとえ、<code>email</code>パッケージを直接使わない名前空間からでも、<code>Package.email.Email.send</code> にアクセス可能です。\n",
  "When declaring functions, keep in mind that <code>function x () {}</code> is just shorthand for <code>var x = function x () {}</code> in JavaScript. Consider these examples:": "\nfunctionを宣言する時、JavaScriptでは、<code>function x () {}</code>は、\n単に<code>var x = function x () {}</code>の省略形であるということに注意してください。\nこれらの例を考えてみてください。\n",
  "Technically speaking, globals in an app (as opposed to in a package) are actually true globals. They can&apos;t be captured in a scope that is private to the app code, because that would mean that they wouldn&apos;t be visible in the console during debugging! This means that app globals actually end up being visible in packages. That should never be a problem for properly written package code (since the app globals will still be properly shadowed by declarations in the packages). You certainly shouldn&apos;t depend on this quirk, and in the future Meteor may check for it and throw an error if you do.": "厳密にいうと、アプリの中（パッケージとは違い）のグローバル変数は、実際のところ、本当にグローバル変数です。\nこれらの変数をアプリのコードに対してプライベートなスコープに閉じ込めることができません。\nなぜなら、デバッグするときにコンソールから見えなくなってしまうからです。\nこれはつまり、アプリのグローバル変数は他のパッケージに見えてしまうということです。\nこのことは正しく書かれたパッケージのコードには、決して問題になるようなことはありません。\n（なぜなら、アプリのグローバル変数は、パッケージの中の変数宣言によって正しくシャドーイングされるからです）\n当然のことながら、この変わった挙動に依存するべきではありません。\nMeteorは将来、チェックをしてもしあなたがそんなことをしていたらエラーを投げるかも知れません。\n",
  "Meteor is a full application server. We include everything you need to deploy your application on the internet: you just provide the JavaScript, HTML, and CSS.": "Meteorはフル・アプリケーションサーバーです。\nあなたのアプリケーションをインターネット上にデプロイするために必要な全てのものが既に入っています。\nあなたは単に、JavaScript、HTML、CSSを入れればいいのです。",
  "The easiest way to deploy your application is to use <code>meteor deploy</code>. We provide it because it&apos;s what, personally, we&apos;ve always wanted: an easy way to take an app idea, flesh it out over a weekend, and put it out there for the world to use, with nothing getting in the way of creativity.": "あなたのアプリケーションをデプロイするための最も簡単な方法は、<code>meteor deploy</code> コマンドを使うことです。\n私達がこれを提供するのは、個人的に、ずっと欲しいとおもってたものだからです。\nそれは、アイディアが浮かんだら、週末で形にして、創造性を妨げずに世界中でつかってもらうようにするということです。",
  "Your application is now available at myapp.meteor.com. If this is the first time deploying to this hostname, Meteor creates a fresh empty database for your application. If you want to deploy an update, Meteor will preserve the existing data and just refresh the code.": "あなたのアプリケーションは、myapp.meteor.comで使えるようになりました。\nもし、これがこのホスト名にデプロイする初回であれば、Meteorあなたのアプリケーションに新しい空のデータベースを作ります。\nもし、変更をデプロイしたいのであれば、Meteorは既存のデータを保存して、単にコードをリフレッシュします。\n",
  "You can also deploy to your own domain. Just set up the hostname you want to use as a CNAME to <code>origin.meteor.com</code>, then deploy to that name.": "自分のドメインへもデプロイすることができます。\n使いたいホスト名のCNAMEを、<code>origin.meteor.com</code>にセットし、その名前でdeployしてください。",
  "We provide this as a free service so you can try Meteor. It is also helpful for quickly putting up internal betas, demos, and so on. For more information, see <a href=\"#meteordeploy\">meteor deploy</a>.": "あなたがMeteorを試せるように、我々はこれを無料のサービスとして提供しています。\nこれは内部ベータや、デモなどを簡単に立ち上げるのにも役に立ちます。\n詳細は<a href=\"#meteordeploy\">meteor deploy</a>を見てください。",
  "You can also run your application on your own infrastructure or any hosting provider that can run Node.js apps.": "あなたのアプリケーションをあなた自身のインフラの上で走らせることができます。\nまた、Node.jsアプリを実行できるどんなホスティングサービスの上でも走らせることができます。",
  "To get started, run": "開始するために、以下を実行してください",
  "This command will generate a fully-contained Node.js application in the form of a tarball. To run this application, you need to provide Node.js 0.10 and a MongoDB server. (The current release of Meteor has been tested with Node 0.10.40.) You can then run the application by invoking node, specifying the HTTP port for the application to listen on, and the MongoDB endpoint.": "\nこのコマンドは、全てを含んだNode.jsアプリケーションをtarアーカイブ形式で生成します。\nこのアプリケーションを走らせるには、Node.js 0.10とMongoDBサーバーが必要です。\n(最新リリースのMeteorは、Node 0.10.40でテストされています。)\nnodeを起動し、アプリケーションのHTTPポートとMongoDBのエンドポイントを指定することでこのアプリケーションを実行することができます。",
  "Some packages might require other environment variables. For example, the <code>email</code> package requires a <code>MAIL_URL</code> environment variable.": "\nいくつかのパッケージは他の環境変数を必要とするかもしれません。\n例えば、<code>email</code> パッケージは、環境変数<code>MAIL_URL</code> を必要とします。",
  "Writing Meteor packages is easy. To initialize a meteor package, run <code>meteor create --package username:packagename</code>, where <code>username</code> is your Meteor Developer username. This will create a package from scratch and prefill the directory with a package.js control file and some javascript. By default, Meteor will take the package name from the name of the directory that contains the package.js file. Don&apos;t forget to run <code>meteor add [packagename]</code>, even if the package is internal to the app, in order to use it.": "\nMeteorのパッケージを書くのは簡単です。\nmeteorパッケージを初期化するには、<code>meteor create --package username:packagename</code>を実行してください。\n<code>username</code> は、あなたのMeteor Developer usernameです。\nこれはパッケージをスクラッチで作成し、ディレクトリーに、package.jsコントロールファイルといくつかのJavaScriptを生成します。\nデフォルトでは、Meteorはpackage.jsファイルが入っているディレクトリーの名前をパッケージ名として使います。\nパッケージを使うためには、仮にそのパッケージがアプリに内部的なものであっても、\n利用するためには<code>meteor add [packagename]</code>を実行するのをわすれないでください。",
  "Meteor promises repeatable builds for both packages and applications. This means that, if you built your package on a machine, then checked the code into a repository and checked it out elsewhere, you should get the same result. In your package directory, you will find an automatically generated <code>.versions</code> file. This file specifies the versions of all packages used to build your package and is part of the source. Check it into version control to ensure repeatable builds across machines.": "\nMeteorはパッケージとアプリケーションの両方に繰り返し実行可能なビルドを保証します。 \nこれはつまり、あなたがパッケージをあるコンピューターでつくり、リポジトリに入れ、そしてどこかでチェックアウトしたとして、同じ結果になるということです。\nあなたのパッケージ・ディレクトリに自動生成された<code>.versions</code>ファイルがつくられます。\nこのファイルはソースの一部であり、あなたのパッケージをビルドするために使われるパッケージを指定します。\nコンピューターをまたいで繰り返し可能なビルドが出来るよう、このファイルをバージョン管理システムにチェックインしてください。",
  "Sometimes, packages do not just stand on their own, but function in the context of an app (specifically, packages in the packages directory of an app). In that case, the app&apos;s context will take precedence. Rather than using the <code>.versions</code> file as a guide, we will build the package with the same dependencies as used by the app (we think that, in practice, it would be confusing to find your local packages built with different versions of things).": "\nパッケージは、時としてそれ自体では成立せず、アプリのコンテキストの中で機能します。（具体的には、アプリのpackagesディレクトリ内のパッケージ）\nこの場合、アプリのコンテキストが優先されます。<code>.versions</code> ファイルをガイドとして使うのではなく、アプリに使われるのと同じ依存性をつかってパッケージをビルドします。\n（異なったバージョンをつかってビルドされたパッケージがローカルパッケージにあったら、実際問題として、混乱を招くと思います。）",
  "Meteor uses extended semver versioning for its packages: that means that the version number has three parts separated by dots: major version, minor version and patch version (for example: 1.2.3) with an optional pre-release version. You can read more about it on <a href=\"http://www.semver.org\">semver.org</a>. Additionally, because some meteor packages wrap external libraries, Meteor supports the convention of using <code>_</code> to denote a wrap number.": "\nMeteorは、拡張されたsemverバージョニングをMeteorのパッケージに対して使います。\nこれは、バージョン番号にドットで句切られた３つの部分があるということです。\nメジャーバジョン、マイナーバージョン、パッチバージョン（例えば、1.2.3）と、オプションでプレリリースバージョンが付きます。\n詳細は<a href=\"http://www.semver.org\">semver.org</a>を読んで下さい。\nさらに、いくつかのmeteorパッケージは外部ライブラリを包含しているので、Meteorは、ラップバージョンを示すため、 <code>_</code> をつかうという規約をサポートしています。",
  "You can read more about <a href=\"#packagejs\"><code>package.js</code></a> files in the API section.": "<a href=\"#packagejs\"><code>package.js</code></a>ファイルについて、APIのセクションで詳細を確認してください。",
  "A word on testing: since testing is an important part of the development process, there are two common ways to test a package:": "テストは開発プロセスのなかの重要な部分なため、テストについて一言いっておきます。\nパッケージをテストするのに、二つの一般的な方法があります：",
  "Integration tests (putting a package directly into an application, and writing tests against the application) is the most common way to test a package. After creating your package, add it to your app&apos;s /packages directory and run <code>meteor add</code>. This will add your package to your app as a local package. You can then test and run your app as usual. Meteor will detect and respond to changes to your local package, just as it does to your app files.": "インテグレーションテスト（パッケージ・ディレクトリをアプリケーションに入れ、テストをアプリケーションに対して書く）は最も一般的な、パッケージをテストする方法です。\nあなたのパッケージを作った後、それをあなたのアプリの/packagesディレクトリに加え、<code>meteor add</code>を実行してください。\nこの操作はパッケージをアプリのローカルパッケージに追加します。その後あなたのアプリのテストや実行をいつものようにすることができます。\nMeteorはあなたのローカルパッケージへの変更を、アプリのファイルに対して行われたのと同じように、検出し、応答します。\n",
  "Unit tests are run with the command <a href=\"#meteortestpackages\"><code>meteor test-packages package-name</code></a>. As described in the <a href=\"#packagejs\"><code>package.js</code></a> section, you can use the <code>package.js</code> file to specify where your unit tests are located. If you have a repository that contains only the package source, you can test your package by specifying the path to the package directory (which must contain a slash), such as <code>meteor test-packages ./</code>.": "ユニットテストは、<a href=\"#meteortestpackages\"><code>meteor test-packages package-name</code></a>コマンドで実行されます。\n<a href=\"#packagejs\"><code>package.js</code></a>セクションで説明されているように、<code>package.js</code>ファイルはあなたのユニットテストの場所を指定するために使えます。\nもし、パッケージのソースだけを含むリポジトリがあるなら、パッケージのディレクトリ（スラッシュを含んでいなければいけません）を指定することでパッケージをテストすることができます。\nたとえば、<code>meteor test-packages ./</code>のようにしてください。",
  "To publish a package, run <a href=\"#meteorpublish\"><code>meteor publish</code></a> from the package directory. There are some extra restrictions on published packages: they must contain a version (Meteor packages are versioned using strict <a href=\"http://www.semver.org\">semver</a> versioning) and their names must be prefixed with the username of the author and a colon, like so: <code>iron:router</code>. This namespacing allows for more descriptive and on-topic package names.": "パッケージを公開するためには、パッケージディレクトリから、<a href=\"#meteorpublish\"><code>meteor publish</code></a> を実行してください。\nパッケージを公開するためにはいくつか追加の制限があります。それは、パッケージはバージョン (Meteorパッケージは<a href=\"http://www.semver.org\">semver</a> バージョニングを使って厳格にバージョニングされています) を持っていなければいけません。また、<code>iron:router</code>のように、作者のユーザー名とコロンがパッケージ名の前についていなければいけません。\nこの名前付けルールににより、より描写的でまとまりのあるパッケージ名にすることができます。",
  "Boolean variable. True if running in a Cordova mobile environment.": "真偽値。Cordovaモバイル環境の場合Trueになる",
  "On a server, the function will run as soon as the server process is finished starting. On a client, the function will run as soon as the DOM is ready.": "サーバー上では、サーバーの開始が完了すると同時に関数が実行される。クライアント上では、DOMが完了すると同時に関数が実行される。",
  "The <code>startup</code> callbacks are called in the same order as the calls to <code>Meteor.startup</code> were made.": "<code>startup</code>のコールバック関数は<code>Meteor.startup</code>の呼びだされた順番によって実行される。",
  "Wrap a function that takes a callback function as its final parameter. The signature of the callback of the wrapped function should be <code>function(error, result){}</code>. On the server, the wrapped function can be used either synchronously (without passing a callback) or asynchronously (when a callback is passed). On the client, a callback is always required; errors will be logged if there is no callback. If a callback is provided, the environment captured when the original function was called will be restored in the callback.": "コールバック関数を引数の最後に受け取る関数をラップします。ラップされた関数に代入されるコールバック関数に特徴的な書き方は<code>function(error, result){}</code>です。サーバー上では、ラップされた関数は同期的（コールバック関数を設定しない）にも非同期的（コールバック関数を設定する）にも使えます。",
  "A function that takes a callback as its final parameter": "引数の最後にコールバック関数を受け取る関数",
  "Optional <code>this</code> object against which the original function will be invoked": "ラップされる前の関数オブジェクトが代入される<code>this</code>",
  "The following directories are also not loaded as part of your app code:": "以下のディレクトリもアプリケーションのコードとしてロードされません。",
  "Meteor makes writing distributed client code as simple as talking to a local database. It&apos;s a clean, simple, and secure approach that removes the need to implement individual RPC endpoints, manually cache data on the client to avoid slow roundtrips to the server, and carefully orchestrate invalidation messages to every client as data changes.": "Meteorでは分散クライアントのコードを書くは、ローカルデータベースと話すくらい簡単です。\nクリーンで、シンプルで、セキュアなアプローチで、個別のRPCエンドポイントを実装する必要がありません。\nまた、サーバーとのラウンドトリップに時間がかかるのを避けるためにクライアントに手動でデータをキャッシュしたり、\n全てのクライアントに、データが変更される度に注意深く無効化メッセージを配信したりする必要がありません。",
  "In Meteor, the client and server share the same database API. The same exact application code &#x2014; like validators and computed properties &#x2014; can often run in both places. But while code running on the server has direct access to the database, code running on the client does <em>not</em>. This distinction is the basis for Meteor&apos;s data security model.": "Meteorではクライアントとサーバーは同じデータベースAPIを共有します。\nほとんどの場合、同一のアプリケーションコード（バリデータや計算されたプロパティなど）を両方の場所で実行できます。\nただし、コードがサーバーで走っている時は、データベースに直接アクセスしますが、コードがクライアントで走っている時はデータベースに直接アクセス<em>しません</em>。\nこの相違がMeteorのデータセキュリティモデルの根幹です。",
  "By default, a new Meteor app includes the <code>autopublish</code> and <code>insecure</code> packages, which together mimic the effect of each client having full read/write access to the server&apos;s database. These are useful prototyping tools, but typically not appropriate for production applications. When you&apos;re ready, just remove the packages.": "新しく作ったMeteorのアプリにはデフォルトで、<code>autopublish</code>と、<code>insecure</code>パッケージが入っています。\nこれらのパッケージは、各クライアントがあたかもフルで読み出し/書き込み権限をサーバーのデータベースに対してもっているように振る舞います。\nこれらは有用なプロトタイピングツールですが、プロダクション用としてはほとんどの場合適切ではありません。\n準備がととのったら、これらのパッケージを取り除いてください。",
  "Every Meteor client includes an in-memory database cache. To manage the client cache, the server <em>publishes</em> sets of JSON documents, and the client <em>subscribes</em> to those sets. As documents in a set change, the server patches each client&apos;s cache.": "それぞれのMeteorクライアントは、インメモリ データベースキャッシュを持っています。\nクライアントキャッシュを管理するため、サーバーはJSONドキュメントのセットを<em>publish</em>し、\nクライアントはそのセットを<em>subscribe</em>します。\nセット内のドキュメントが変わるたび、サーバーはクライアントキャッシュにパッチを送ります。",
  "Today most Meteor apps use MongoDB as their database because it is the best supported, though support for other databases is coming in the future. The <a href=\"#mongo_collection\"><code>Mongo.Collection</code></a> class is used to declare Mongo collections and to manipulate them. Thanks to <code>minimongo</code>, Meteor&apos;s client-side Mongo emulator, <code>Mongo.Collection</code> can be used from both client and server code.": "現在、ほとんどのMeteorアプリはMongoDBをデータベースとして使います。\nなぜならそれが一番サポートされているからです。とはいえ、他のデータベースのサポートも将来提供される予定です。\n<a href=\"#mongo_collection\"><code>Mongo.Collection</code></a> クラスはMongoコレクションを宣言し、操作するために使われます。\nMeteorのクライアントサイドのMongoエミュレーターである<code>minimongo</code>のおかげで、<code>Mongo.Collection</code>はクライアントとサーバーの両方から使うことができます。",
  "Each document set is defined by a publish function on the server. The publish function runs each time a new client subscribes to a document set. The data in a document set can come from anywhere, but the common case is to publish a database query.": "各ドキュメントセットはサーバーのpublish関数により定義されます。\npublish関数は新たなクライアントがドキュメントセットをsubscribする度に実行されます。\nドキュメントセットのデータはどこからでも持ってこれますが、データベースのクエリをpublishすることが通常のケースです。",
  "Publish functions can provide different results to each client. In the last example, a logged in user can only see <code>Party</code> documents that are public, that the user owns, or that the user has been invited to.": "publish関数は各クライアントに異なる結果を提供することができます。\n上の最後の例では、ログインしたユーザーが参照できるのは、publicであり、そのユーザーが所有(owner)するか招待(invited)されている、<code>Party</code>ドキュメントのみです。",
  "Once subscribed, the client uses its cache as a fast local database, dramatically simplifying client code. Reads never require a costly round trip to the server. And they&apos;re limited to the contents of the cache: a query for every document in a collection on a client will only return documents the server is publishing to that client.": "\n一旦subscribeすると、クライアントは自身のキャッシュを高速なローカルデータベースとして利用し、クライアントコードを劇的にシンプルにします。\n読み出しは決してコストのかかるサーバーへのラウンドトリップを必要としません。\nまた読み出し処理は、キャッシュ内のコンテンツに限定されています。\nつまり、クライアントにあるコレクション内の全てのドキュメントへのクエリは、サーバーがクライアントにpublishしたドキュメントだけを返します。",
  "Sophisticated clients can turn subscriptions on and off to control how much data is kept in the cache and manage network traffic. When a subscription is turned off, all its documents are removed from the cache unless the same document is also provided by another active subscription.": "洗練されたクライアントは、キャッシュへのデータ保持量とネットワーク上のトラフィックを制御するため、サブスクリプションのオンとオフを切り替えられます。\nサブスクリプションがオフにされた場合、同じドキュメントが別のアクティブなサブスクリプションから提供されない限り、全てのドキュメントがキャッシュから取り除かれます。",
  "When the client <em>changes</em> one or more documents, it sends a message to the server requesting the change. The server checks the proposed change against a set of allow/deny rules you write as JavaScript functions. The server only accepts the change if all the rules pass.": "クライアントが1つまたは複数のドキュメントを<em>変更</em>すると、サーバーへ変更要求のメッセージを1回送ります。\nサーバーは提案された変更を、あなたがJavaScript関数として書いた、allow/denyルールのセットに対してチェックをします。\nサーバーは全てのルールをパスした変更のみを受け入れます。",
  "If the server accepts the change, it applies the change to the database and automatically propagates the change to other clients subscribed to the affected documents. If not, the update fails, the server&apos;s database remains untouched, and no other client sees the update.": "もしサーバーが変更を受け入れると、サーバーはその変更をデータベースに適用し、自動的にそのドキュメントをsubscribeしている他のクライアントに変更を伝播します。\nもしサーバーが変更を受け入れないと、その更新は失敗し、サーバーのデータベースは変更されないままとなり、他のどのクライアントもその変更を見ることはありません",
  "Meteor has a cute trick, though. When a client issues a write to the server, it also updates its local cache immediately, without waiting for the server&apos;s response. This means the screen will redraw right away. If the server accepted the update &#x2014; what ought to happen most of the time in a properly behaving client &#x2014; then the client got a jump on the change and didn&apos;t have to wait for the round trip to update its own screen. If the server rejects the change, Meteor patches up the client&apos;s cache with the server&apos;s result.": "\nただ、Meteorはちょっとした技を持っています。\nクライアントがサーバーに書き込みをする行うとき、クライアントはサーバーからの応答を待たず、ローカルキャッシュを瞬時に更新します。\nこれは、画面が即座に書き換わるということです。\nもしサーバーがその変更を受け入れたら、（これは正しく振る舞うクライアントでほとんどの場合にそうなるはずですが）\nクライアントはすでに変更を取り込んでしまっていて、画面を書き換えるためにサーバーとのラウンドトリップを待つ必要がないのです。\nもしサーバーが変更を拒否したら、Meteorはクライアントのキャッシュにサーバーからの結果を反映させて直します。\n",
  "Putting it all together, these techniques accomplish latency compensation. Clients hold a fresh copy of the data they need, and never need to wait for a roundtrip to the server. And when clients modify data, those modifications can run locally without waiting for the confirmation from the server, while still giving the server final say over the requested change.": "\nまとめると、これらの技術は遅延補正（レイテンシー・コンペンセイション）を果たします。\nクライアントは必要とする最新データを保持し、決してサーバーへのラウンドトリップを待つ必要がありません。\nまた、クライアントがデータを変更する時、その変更操作はサーバーからの確認を待たずにローカルで実施可能です。\n一方で、サーバーには依然として、要求した変更に関しての最終的な発言権を与えています。\n",
  "The current release of Meteor supports MongoDB, the popular document database, and the examples in this section use the <a href=\"http://www.mongodb.org/display/DOCS/Manual\">MongoDB API</a>. Future releases will include support for other databases.": "現在リリースされているのMeteorは人気のドキュメント型データベースであるMongoDBをサポートしています。\nまた、このセクションの例は<a href=\"http://www.mongodb.org/display/DOCS/Manual\">MongoDB API</a>をつかっています。\n将来のリリースでは、他のデータベースのサポートも含まれる予定です。",
  "Meteor includes <a href=\"#accounts_api\">Meteor Accounts</a>, a state-of-the-art authentication system. It features secure password login using the <a href=\"http://en.wikipedia.org/wiki/Bcrypt\">bcrypt</a> algorithm, and integration with external services including Facebook, GitHub, Google, Meetup, Twitter, and Weibo. Meteor Accounts defines a <a href=\"#meteor_users\"><code>Meteor.users</code></a> collection where developers can store application-specific user data.": "Meteorは<a href=\"#accounts_api\">Meteor Accounts</a>を持っています。\nこれは最新の認証システムです。\n<a href=\"http://en.wikipedia.org/wiki/Bcrypt\">bcrypt</a>アルゴリズムをつかったセキュアなパスワードログインと、\nFacebook、GitHub、Google、Meetup、Twitter、Weiboなど外部サービスとの連携を機能として備えています。\nMeteor Accountsは<a href=\"#meteor_users\"><code>Meteor.users</code></a>コレクションを定義します。 \nここには開発者がアプリケーションに特有のユーザーデータを保存することができます。",
  "Meteor also includes pre-built forms for common tasks like login, signup, password change, and password reset emails. You can add <a href=\"#accountsui\">Accounts UI</a> to your app with just one line of code. The <code>accounts-ui</code> package even provides a configuration wizard that walks you through the steps to set up the external login services you&apos;re using in your app.": "Meteorは、ログイン、サインアップ、パスワード変更、パスワードリセットのemailなど、共通のタスクにために、ビルド済みのフォームも持っています。\n<a href=\"#accountsui\">Accounts UI</a>をたったの一行のコードであなたのアプリに追加することができます。\n<code>accounts-ui</code>パッケージはあなたのアプリで使っている外部ログインサービスのセットアップを順番に手助けしてくれる設定ウィザードまで提供しています。",
  "Meteor allows your methods and publish functions to take arguments of any <a href=\"http://json.org/\">JSON</a> type. (In fact, Meteor&apos;s wire protocol supports <a href=\"#ejson\">EJSON</a>, an extension of JSON which also supports other common types like dates and binary buffers.) JavaScript&apos;s dynamic typing means you don&apos;t need to declare precise types of every variable in your app, but it&apos;s usually helpful to ensure that the arguments that clients are passing to your methods and publish functions are of the type that you expect.": "Meteorはあなたのメソッドとpublish関数に任意の<a href=\"http://json.org/\">JSON</a> 型の引数を受け取れるようにします。\n（じっさいのところ、Meteorの伝送プロトコルは、JSONの拡張で日付やバイナリバッファなども利用可能な<a href=\"#ejson\">EJSON</a>をサポートしています。）\nJavaScriptの動的型付けでは、あなたはアプリで全ての変数に正確な型を宣言する必要がありません、\nしかしクライアントがあなたのメソッドとpublish関数に渡す引数が、あなたが想定している型のものか確認するのは大抵の場合において有用です。",
  "Meteor provides a <a href=\"#check_package\">lightweight library</a> for checking that arguments and other values are the type you expect them to be. Simply start your functions with statements like <code>check(username, String)</code> or <code>check(office, {building: String, room: Number})</code>. The <code>check</code> call will throw an error if its argument is of an unexpected type.": "Meteorは、引数とそのほかの変数の型があなたが想定しているものかチェックするための<a href=\"#check_package\">軽量ライブラリ</a>を提供しています。\n単に、あなたの関数の冒頭に<code>check(username, String)</code> または、<code>check(office, {building: String, room: Number})</code>のように書いてください。\n<code>check</code>の呼び出しは、引数の型が予想と異なっていた場合エラーを投げます。",
  "Meteor also provides an easy way to make sure that all of your methods and publish functions validate all of their arguments. Just run <code>meteor add <a href=\"#auditargumentchecks\">audit-argument-checks</a></code> and any method or publish function which skips <code>check</code>ing any of its arguments will fail with an exception.": "Meteorはあなたの全てのメソッドとpublish関数がその引数を検証することを確実にする簡単な方法も提供しています。\n<code>meteor add <a href=\"#auditargumentchecks\">audit-argument-checks</a></code>を実行するだけです。\nこれで全てのメソッドとpublish関数が引数に対して<code>check</code>をし忘れると、例外が発生して失敗します。",
  "Meteor embraces the concept of <a href=\"http://en.wikipedia.org/wiki/Reactive_programming\">reactive programming</a>. This means that you can write your code in a simple imperative style, and the result will be automatically recalculated whenever data changes that your code depends on.": "Meteorは<a href=\"http://en.wikipedia.org/wiki/Reactive_programming\">リアクティブプログラミング</a>のコンセプトを大切にしています。\nこれは、シンプルな命令形(imperative)のスタイルで書けて、その結果はコードが依存しているデータに変更があった場合はいつでも自動的に再計算されるという意味です。",
  "This example (taken from a chat room client) sets up a data subscription based on the session variable <code>currentRoomId</code>. If the value of <code>Session.get(&quot;currentRoomId&quot;)</code> changes for any reason, the function will be automatically re-run, setting up a new subscription that replaces the old one.": "この例（チャットルールクライアントからもってきました）はセッション変数<code>currentRoomId</code>をもとにデータのサブスクリプションを設定しています。\nどんな理由であれ、もし<code>Session.get(&quot;currentRoomId&quot;)</code>の値がかわると、この関数は自動的に再実行され、古いサブスクリプションの入れ替えになる新しいサブスクリプションを設定します。",
  "This automatic recomputation is achieved by a cooperation between <code>Session</code> and <code>Tracker.autorun</code>. <code>Tracker.autorun</code> performs an arbitrary &quot;reactive computation&quot; inside of which data dependencies are tracked, and it will re-run its function argument as necessary. Data providers like <code>Session</code>, on the other hand, make note of the computation they are called from and what data was requested, and they are prepared to send an invalidation signal to the computation when the data changes.": "この自動再計算は、<code>Session</code> と <code>Tracker.autorun</code>の連携で実現しています。\n<code>Tracker.autorun</code>は、内部でデータ依存性が追跡されている、任意の「リアクティブな計算」を実行します。また、必要に応じて、渡された関数引数を再実行します。\n<code>Session</code>のようなデータプロバイダーは、この他に、それが呼びだされた計算とどのようなデータが要求されたかということを記録し、データが変わった時、無効化のシグナルをその計算へ送り出す準備をします。",
  "This simple pattern (reactive computation + reactive data source) has wide applicability. Above, the programmer is saved from writing unsubscribe/resubscribe calls and making sure they are called at the right time. In general, Meteor can eliminate whole classes of data propagation code which would otherwise clog up your application with error-prone logic.": "このシンプルなパターン（リアクティブ計算 + リアクティブデータソース）は、幅広い適用可能性を持っています。\nプログラマーは、サブスクライブの停止/再開の呼び出しを書くこと、それが正しいタイミングで実行されるようにすることから開放されます。\n通常、Meteorは、あなたのアプリケーションをエラーが起こりやすいロジックだらけにしてしまう、データの伝播（プロパゲーション）クラスを取り除くことができます。",
  "These Meteor functions run your code as a reactive computation:": "これらのMeteor関数はあなたのコードをリアクティブ計算として実行します：",
  "And the reactive data sources that can trigger changes are:": "また、変更をトリガーできるリアクティブ・データソースは以下のものです：",
  "In addition, the following functions which return an object with a <code>stop</code> method, if called from a reactive computation, are stopped when the computation is rerun or stopped:": "加えて、<code>stop</code>メソッド付きでオブジェクトを返す以下の関数は、リアクティブ計算から呼ばれたとき、そのリアクティブ計算が再実行または停止された場合に、停止されます：",
  "Meteor&apos;s <a href=\"https://github.com/meteor/meteor/blob/master/packages/tracker/tracker.js\">implementation</a> is a package called <a href=\"#tracker\"><code>Tracker</code></a> that is fairly short and straightforward. You can use it yourself to implement new reactive data sources.": "Meteorの<a href=\"https://github.com/meteor/meteor/blob/master/packages/tracker/tracker.js\">実装</a>は、\n<a href=\"#tracker\"><code>Tracker</code></a>という、かなり短くてわかりやすいパッケージです。\nこれをつかって、あなた自身でリアクティブなデータソースを実装することができます。",
  "HTML templating is central to web applications. With Blaze, Meteor&apos;s live page update technology, you can render your HTML <em>reactively</em>, meaning that it will update automatically to track changes in the data used to generate it.": "HTMLテンプレートは、ウェブアプリケーションにとって中心的な存在です。\nBlazeを用いると、Meteorのライブページアップデート技術により、リアクティブにあなたのHTMLを描画できます。\nこれは、描画するのに使ったデータの変更を追跡し、自動的に更新するということです。",
  "Meteor makes it easy to use your favorite HTML templating language along with Meteor&apos;s live page update technology. Just write your template as you normally would, and Meteor will take care of making it update in realtime.": "\nMeteorではあなたのお気に入りのHTMLテンプレート言語と一緒にMeteorのライブページアップデート技術を簡単に使えるようにしています。\nいつものようにあなたのテンプレートを書いてください。Meteorがリアルタイムに更新する作業を引き受けます。",
  "Meteor ships with a templating language called <a href=\"https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md\">Spacebars</a>, inspired by <a href=\"http://handlebarsjs.com/\">Handlebars</a>. It shares some of the spirit and syntax of Handlebars, but it has been tailored to produce reactive Meteor templates when compiled.": "\nMeteorは<a href=\"http://handlebarsjs.com/\">Handlebars</a>にインスパイアされた、\n<a href=\"https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md\">Spacebars</a>というテンプレート言語を提供しています。\nこれはある程度、Handlebarsの考え方とシンタックスを共有したものですが、コンパイル時にリアクティブなMeteorテンプレートを生成するよう作りこまれています。",
  "Today, the only templating system that ships with Meteor is Spacebars, though our community has created packages for other languages such as <a href=\"https://atmospherejs.com/mquandalle/jade?__hstc=256467284.449a70e519594323315e9234a679e4a7.1451206053709.1451206053709.1451206053709.1&amp;__hssc=256467284.1.1451206053709&amp;__hsfp=1614345591\">Jade</a>.": "\n現在、Meteorと一緒に提供されている唯一のテンプレートシステムはSpacebarsですが、我々のコミュニティは他の言語に関してもパッケージを作っています。\nたとえば、<a href=\"https://atmospherejs.com/mquandalle/jade?__hstc=256467284.449a70e519594323315e9234a679e4a7.1451206053709.1451206053709.1451206053709.1&amp;__hssc=256467284.1.1451206053709&amp;__hsfp=1614345591\">Jade</a>です。",
  "To define templates, create a file in your project with the <code>.html</code> extension. In the file, make a <code>&lt;template&gt;</code> tag and give it a <code>name</code> attribute. Put the template contents inside the tag. Meteor will precompile the template, ship it down to the client, and make it available as on the global <code>Template</code> object.": "\nテンプレートを定義するには、あなたのプロジェクトに拡張子<code>.html</code>のファイルを作ってください。\nそのファイルの中に、<code>&lt;template&gt;</code>タグを作り、<code>name</code>アトリビュートを付けてください。\nそのタグのなかにコンテンツを入れてください。\nMeteorはプリコンパイルして、クライアント側に送り、グローバルな<code>Template</code> オブジェクトの中で使えるようにします。",
  "When your app is loaded, it automatically renders the special template called <code>&lt;body&gt;</code>, which is written using the <code>&lt;body&gt;</code> element instead of a <code>&lt;template&gt;</code>. You insert a template inside another template by using the <code>{{&gt; inclusion}}</code> operator.": "あなたのアプリが読み込まれるとき、<code>&lt;body&gt;</code>という特別なテンプレートを描画します。\nこれは、<code>&lt;template&gt;</code>の代わりに、<code>&lt;body&gt;</code> 要素を使って書かれたテンプレートです。\nあなたは、<code>{{&gt; inclusion}}</code>オペレーターを使って、あるテンプレートを別のテンプレートの中に挿入できます。",
  "The easiest way to get data into templates is by defining helper functions in JavaScript. Define helpers with the <code>Template.templateName.helpers({ ... })</code> function. Putting it all together:": "テンプレートの中にデータを取り込む最も簡単な方法は、JavaScriptにhelper \u0010functionを定義することです。\nヘルパーは<code>Template.templateName.helpers({ ... })</code>関数をつかって定義します。\n全て並べると:",
  "To iterate over an array or database cursor, use <code>{{#each}}</code>:": "配列またはデータベースのカーソルをイテレートするには、<code>{{#each}}</code> をつかいます:",
  "In this case, the data is coming from a database query. When the database cursor is passed to <code>{{#each}}</code>, it will wire up all of the machinery to efficiently add and move DOM nodes as new results enter the query.": "この場合、データはデータベースのクエリーからやってきます。\nデータベースのカーソルが<code>{{#each}}</code>に渡されると、全ての仕掛けが連動し、新しい結果がクエリに入るたびに、効果的にDOMノードを追加、移動させます。",
  "Helpers can take arguments, and they receive the current template context data in <code>this</code>. Note that some block helpers change the current context (notably <code>{{#each}}</code> and <code>{{#with}}</code>):": "ヘルパーは引数を取ることができます。また、現在のテンプレートのコンテキスト・データを<code>this</code>で受け取ります。\nいくつかのブロック・ヘルパーはカレント・コンテキストが変わります。（特に、<code>{{#each}}</code> と <code>{{#with}}</code>です）：",
  "Helpers can also be used to pass in constant data.": "ヘルパーは、定数値を渡すためにも使われます。",
  "Finally, you can use the <code>events</code> function on a template to attach event handlers. The object passed into <code>events</code> is documented at <a href=\"#eventmaps\">Event Maps</a>. The <code>this</code> argument to the event handler will be the data context of the element that triggered the event.": "最後に、<code>events</code> 関数をつかって、テンプレートにイベントハンドラを設置することができます。\n<code>events</code>に渡されるオブジェクトは、<a href=\"#eventmaps\">Event Maps</a>に記述されています。\nイベントハンドラの変数<code>this</code> はイベントを起動した要素のデータコンテキストになります。",
  "For more details about Spacebars, read <a href=\"https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md\">the Spacebars README</a>.": "Spacebarsに関する詳細は、<a href=\"https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md\">the Spacebars\nREADME</a>をよんでください。",
  "Anyone can publish a Meteor package, and thousands of community-written packages have been published to date. The easiest way to browse these packages is <a href=\"http://www.atmospherejs.com/?__hstc=256467284.449a70e519594323315e9234a679e4a7.1451206053709.1451206053709.1451206053709.1&amp;__hssc=256467284.1.1451206053709&amp;__hsfp=1614345591\">Atmosphere</a>, by Percolate Studio. You can also use the <a href=\"#meteorsearch\"><code>meteor search</code></a> and <a href=\"#meteorshow\"><code>meteor show</code></a> commands.": "Meteorパッケージはだれでも公開することができ、今日まで何千ものコミュニティによって書かれたパッケージが公開されています。 \nこれらのパッケージを閲覧する最も簡単な方法は、Percolate Studioによって運営されている、<a href=\"\\&quot;http://www.atmospherejs.com/?__hstc=256467284.eff58f8bcd24d01de0c0c49f3422de0d.1445924524567.1445924524567.1445924524567.1&amp;__hssc=256467284.1.1445924524568&amp;__hsfp=1614345591\\&quot;\">Atmosphere</a>です。 \n<a href=\"\\&quot;#meteorsearch\\&quot;\"><code>meteor search</code></a>と<a href=\"\\&quot;#meteorshow\\&quot;\"><code>meteor show</code></a>コマンドを使うこともできます。\n",
  "Generate an absolute URL pointing to the application. The server reads from the <code>ROOT_URL</code> environment variable to determine where it is running. This is taken care of automatically for apps deployed with <code>meteor deploy</code>, but must be provided when using <code>meteor build</code>.": "アプリケーションを指す絶対URLを生成します。サーバーは実行されている場所を特定するために環境変数<code>ROOT_URL</code>を参照します。\nこれは、<code>meteor deploy</code>をつかってデプロイされたアプリには自動的に設定されますが、<code>meteor build</code>を使う時は設定しなければなりません。",
  "A path to append to the root URL. Do not include a leading &quot;<code>/</code>&quot;.": "ルートURLにつなげるパス。先頭に&quot;<code>/</code>&quot;を付けないでください。",
  "Create an HTTPS URL.": "HTTPS URLを作ります。",
  "Replace localhost with 127.0.0.1. Useful for services that don&apos;t recognize localhost as a domain name.": "localhostを127.0.0.1に置き換えます。localhostをドメイン名として認識しないサービスに便利です。",
  "Override the default ROOT_URL from the server environment. For example: &quot;<code>http://foo.example.com</code>&quot;": "サーバーの環境変数のROOT_URLを上書きします。例: &quot;<code>http://foo.example.com</code>&quot;",
  "<code>Meteor.settings</code> contains deployment-specific configuration options. You can initialize settings by passing the <code>--settings</code> option (which takes the name of a file containing JSON data) to <code>meteor run</code> or <code>meteor deploy</code>. When running your server directly (e.g. from a bundle), you instead specify settings by putting the JSON directly into the <code>METEOR_SETTINGS</code> environment variable. If the settings object contains a key named <code>public</code>, then <code>Meteor.settings.public</code> will be available on the client as well as the server. All other properties of <code>Meteor.settings</code> are only defined on the server. You can rely on <code>Meteor.settings</code> and <code>Meteor.settings.public</code> being defined objects (not undefined) on both client and server even if there are no settings specified. Changes to <code>Meteor.settings.public</code> at runtime will be picked up by new client connections.": "\n<code>Meteor.settings</code>は、デプロイメント固有の設定オプションが入っています。\nsettingsは<code>meteor run</code>または<code>meteor deploy</code>に<code>--settings</code>オプション（JSONデータを含んだファイルの名前をセットします）で渡して初期化することができます。\nあなたのサーバーを直接実行するとき（たとえば bundleからの実行時）、代わりに環境変数<code>METEOR_SETTINGS</code>に直接JSONをセットすることで、settingsを設定します。\nsettingsオブジェクトに<code>public</code>という名前のキーが含まれている場合は、<code>Meteor.settings.public</code>がサーバーだけでなくクライアントでも利用可能になります。\nその他全ての<code>Meteor.settings</code>のプロパティは、サーバーでのみ利用可能です。\n例えsettingsを指定しなくても、クライアントとサーバーの両方に<code>Meteor.settings</code>と<code>Meteor.settings.public</code>が（undefinedにならず）オブジェクトとして利用可能であるということに依存して大丈夫です。\n<code>Meteor.settings.public</code>への実行時の変更は、新たなクライアントの接続時に拾われます。",
  "<code>Meteor.release</code> is a string containing the name of the <a href=\"#meteorupdate\">release</a> with which the project was built (for example, <code>&quot;1.2.3&quot;</code>). It is <code>undefined</code> if the project was built using a git checkout of Meteor.": "\n<code>Meteor.release</code>は、プロジェクトがビルドにつかった<a href=\"#meteorupdate\">リリース</a>名を含んだ文字列です。(例えば、<code>&quot;1.2.3&quot;</code>)\n これは、もしプロジェクトがMeteorをgitからチェックアウトしてビルドすると<code>undefined</code>になります。",
  "The <code>check</code> package includes pattern checking functions useful for checking the types and structure of variables and an <a href=\"#matchpatterns\">extensible library of patterns</a> to specify which types you are expecting.": "<code>check</code>パッケージは、簡単に変数の型や構造をチェックすることができるパターンチェック関数と、\nその型や構造を指定する<a href=\"#matchpatterns\">拡張ライブラリ</a>を提供します。",
  "Check that a value matches a <a href=\"#matchpatterns\">pattern</a>. If the value does not match the pattern, throw a <code>Match.Error</code>.": "値が<a href=\"#matchpatterns\">パターン</a>にマッチするかをチェックする。\nもしパターンにマッチしない場合、<code>Match.Error</code>をスローする。",
  "Particularly useful to assert that arguments to a function have the right types and structure.": "特に、関数の引数が正しい型や構造をしているか確認するのに役立つ。",
  "The value to check": "確認する値",
  "The pattern to match <code>value</code> against": "<code>value</code>に対するパターン",
  "Meteor methods and publish functions take arbitrary <a href=\"#ejson\">EJSON</a> types as arguments, but most arguments are expected to be of a particular type. <code>check</code> is a lightweight function for checking that arguments and other values are of the expected type. For example:": "Meteorメソッドとpublish関数は任意の<a href=\"#ejson\">EJSON</a>型を引数としてとるが、\n多くの引数は特定の型を期待します。<code>check</code>\nは、関数の引数やその他の値をチェックするための軽量の関数です。\n例えば:",
  "If the match fails, <code>check</code> throws a <code>Match.Error</code> describing how it failed. If this error gets sent over the wire to the client, it will appear only as <code>Meteor.Error(400, &quot;Match Failed&quot;)</code>. The failure details will be written to the server logs but not revealed to the client.": "マッチしない場合、<code>check</code>は失敗の原因を記述した<code>Match.Error</code>の例外をスローします。もし\nこのエラーがクライアント側に送られた場合、単に\n<code>Meteor.Error(400, &quot;Match Failed&quot;)</code>となります。失敗の原因はサーバのログに書かれクライアントには開示されません。",
  "Returns true if the value matches the pattern.": "パターンにマッチした場合、trueを返す。",
  "<code>Match.test</code> can be used to identify if a variable has a certain structure.": "<code>Match.test</code>は値の構造を判定するのに使います。",
  "This can be useful if you have a function that accepts several different kinds of objects, and you want to determine which was passed in.": "これは、関数が複数の種類のオブジェクトを受け取る場合にどれが渡されたかを確認するのに使えます。",
  "The following patterns can be used as pattern arguments to <a href=\"#check\"><code>check</code></a> and <code>Match.test</code>:": "下記は\n<a href=\"#check\"><code>check</code></a>と<code>Match.test</code>の引数に使えるパターンです:",
  "Matches any value.": "任意の値にマッチします。",
  "Matches a primitive of the given type.": "与えられたプリミティブタイプにマッチします。",
  "Matches a signed 32-bit integer. Doesn&apos;t match <code>Infinity</code>, <code>-Infinity</code>, or <code>NaN</code>.": "符号付32bit整数にマッチします。<code>Infinity</code>や<code>-Infinity</code>や<code>NaN</code>にはマッチしません。",
  "A one-element array matches an array of elements, each of which match <em>pattern</em>. For example, <code>[Number]</code> matches a (possibly empty) array of numbers; <code>[Match.Any]</code> matches any array.": "要素が一つの配列はすべての要素が<em>pattern</em>にマッチする配列にマッチします。例えば、<code>[Number]</code>は数値の配列(もしくは空の配列)にマッチします。また、<code>[Match.Any]</code>は任意の配列にマッチします。",
  "Matches an Object with the given keys, with values matching the given patterns. If any <em>pattern</em> is a <code>Match.Optional</code>, that key does not need to exist in the object. The value may not contain any keys not listed in the pattern. The value must be a plain Object with no special prototype.": "与えられたキーとそのパターンのオブジェクトにマッチします。\nもし<em>pattern</em>が<code>Match.Optional</code>の場合、そのキーはオブジェクトに存在する必要がはありません。\n対象の値はパターン載っていないキーを含むことはできません。\n対象の値はプロトタイプを持たない単純なオブジェクトである必要があります。",
  "Matches an Object with the given keys; the value may also have other keys with arbitrary values.": "与えられたキーを含むオブジェクトにマッチします。対象の値は他の任意の値をもつキーを持つことができます。",
  "Matches any plain Object with any keys; equivalent to <code>Match.ObjectIncluding({})</code>.": "与えられたキーを含むオブジェクトにマッチします。<code>Match.ObjectIncluding({})</code>と同等です。",
  "Matches either <code>undefined</code> or something that matches pattern. If used in an object this matches only if the key is not set as opposed to the value being set to <code>undefined</code>.": "<code>undefined</code>もしくはパターンにマッチする何かにマッチします。もしオブジェクトの中で使われる場合は、キーが存在しない場合のみマッチし、値が<code>undefined</code>の場合は該当しません。",
  "Matches any value that matches at least one of the provided patterns.": "複数のパターンのいずれか一つにマッチする任意の値にマッチします。",
  "Matches any element that is an instance of that type.": "コンストラクタのインスタンスにマッチします。",
  "Calls the function <em>condition</em> with the value as the argument. If <em>condition</em> returns true, this matches. If <em>condition</em> throws a <code>Match.Error</code> or returns false, this fails. If <em>condition</em> throws any other error, that error is thrown from the call to <code>check</code> or <code>Match.test</code>. Examples:": "<em>condition</em>関数を対象の値を引数として呼び出し、もしtrueが返されればマッチします。もし<em>condition</em>関数が<code>Match.Error</code>をスローしたりfalseを返す場合はマッチしません。もし<em>condition</em>関数がそれ以外の例外をスローする場合はその例外がは<code>check</code>や<code>Match.test</code>にスローされます。例えば:",
  "Meteor has a simple dependency tracking system which allows it to automatically rerun templates and other computations whenever <a href=\"#session\"><code>Session</code></a> variables, database queries, and other data sources change.": "\nMeteorは、<a href=\"#session\"><code>Session</code></a>変数、データベースクエリ、またその他のデータソースが変化した時はいつでもテンプレートとその他のコンポーネントを自動的に再実行させるための、シンプルな依存性トラッキングシステムを持っています。",
  "Unlike most other systems, you don&apos;t have to manually declare these dependencies &#x2014; it &quot;just works&quot;. The mechanism is simple and efficient. When you call a function that supports reactive updates (such as a database query), it automatically saves the current Computation object, if any (representing, for example, the current template being rendered). Later, when the data changes, the function can &quot;invalidate&quot; the Computation, causing it to rerun (rerendering the template).": "\n多くの他のシステムとは違い、これらの依存性を手動で宣言する必要はありません。\nなにもしなくてもちゃんと動くのです。\nメカニズムはシンプルで効果的です。\nあなたがリアクティブな更新をサポートする関数（たとえばデータベースクエリなどです）を呼び出す時、\n現在の演算（コンピュテーション）オブジェクト（たとえば、レンダリングされている現在のテンプレートなどを表すものです）があれば、それを自動的に保存します。\nあとになってデータに変更があった時、その関数は、コンピューテーションを &quot;インバリデート（無効化）&quot; することができ、それはコンピューテーションを再実行させます（テンプレートのレンダリング）",
  "Applications will find <a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a> useful, while more advanced facilities such as <code>Tracker.Dependency</code> and <code>onInvalidate</code> callbacks are intended primarily for package authors implementing new reactive data sources.": "\nアプリケーションから見ると、<a href=\"#tracker_autorun\"><code>Tracker.autorun</code></a>が有用です。\n一方、より高度な<code>Tracker.Dependency</code> や <code>onInvalidate</code>コールバックなどの機能は、\n主に新たなリアクティブ・データソースを実装するパッケージの作者達に使われることを意図しています。",
  "<code>Tracker.autorun</code> allows you to run a function that depends on reactive data sources, in such a way that if there are changes to the data later, the function will be rerun.": "\n<code>Tracker.autorun</code>はリアクティブ・データソースに依存する関数を実行できます。\nこの方法をつかうと、データに後で変化があると、関数は再実行されます。",
  "For example, you can monitor a cursor (which is a reactive data source) and aggregate it into a session variable:": "\n例えば、カーソル（リアクティブ・データソースです）をモニターし、Session変数の中に集計結果を入れる事ができます：",
  "Or you can wait for a session variable to have a certain value, and do something the first time it does, calling <code>stop</code> on the computation to prevent further rerunning:": "または、session変数がある値になるのを待ち、最初にその値になったとき何かをし、\n演算オブジェクト（コンピューテーション）の<code>stop</code>を呼び、将来の再実行を防ぐことができます：",
  "The function is invoked immediately, at which point it may alert and stop right away if <code>shouldAlert</code> is already true. If not, the function is run again when <code>shouldAlert</code> becomes true.": "\n関数はすぐに実行され、その時点で、もし<code>shouldAlert</code>がtrueであれば、alertとstopをその場で呼び出すかも知れません。\nもしtrueでなければ、<code>shouldAlert</code>がtrueになった時、この関数はもう一度実行されます。",
  "A change to a data dependency does not cause an immediate rerun, but rather &quot;invalidates&quot; the computation, causing it to rerun the next time a flush occurs. A flush will occur automatically as soon as the system is idle if there are invalidated computations. You can also use <a href=\"#tracker_flush\"><code>Tracker.flush</code></a> to cause an immediate flush of all pending reruns.": "\nデータ依存性への変更は即座に再実行を引き起こしません。\nそうではなく、コンピューテーション（演算）を&quot;無効化&quot; します。\nすると、次回フラッシュが起きた時に、コンピューテーションを再実行させます。\nフラッシュは、無効化されたコンピューテーションが有れば、システムがアイドル状態になるとすぐ自動的に発生します。\n<a href=\"#tracker_flush\"><code>Tracker.flush</code></a>をつかって即座にフラッシュを引き起こして、全ての未実施の再実行をフラッシュさせることもできます。",
  "If you nest calls to <code>Tracker.autorun</code>, then when the outer call stops or reruns, the inner call will stop automatically. Subscriptions and observers are also automatically stopped when used as part of a computation that is rerun, allowing new ones to be established. See <a href=\"#meteor_subscribe\"><code>Meteor.subscribe</code></a> for more information about subscriptions and reactivity.": "\nもし<code>Tracker.autorun</code>をネストして呼び出して、外側の実行が停止、または再実行する時、\n内側の実行は自動的に停止します。\nサブスクリプションとオブザーバーも、再実行するコンピューテーションの一部として使われた場合、新しいものを確立できるように、同様に自動的に停止します。\nサブスクリプションとリアクティビティに関しての詳細は、<a href=\"#meteor_subscribe\"><code>Meteor.subscribe</code></a>を御覧ください。"
}
<html manifest="/app.manifest"><head>
  <link rel="stylesheet" type="text/css" class="__meteor-css__" href="http://docs.meteor.com/4378b230b3427032028d881c2bb2e508762a7eab.css?meteor_css_resource=true">




  


  
    
  


<meta name="fragment" content="!">
<title>Documentation - Meteor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="Description" content="Meteor is an open-source JavaScript platform for building top-quality web apps in a fraction of the time, whether you&apos;re an expert developer or just getting started.">
  <link rel="icon" href="http://docs.meteor.com/favicon.png" type="image/png">

  <!-- Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-M2CMWR" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <!-- End Google Tag Manager -->

  <!-- Start of Async HubSpot Analytics Code -->
    
  <!-- End of Async HubSpot Analytics Code -->
<style>.original{display:none}</style></head>
<body>



<div class="body sidebar-closed">
    
    <div id="nav">
      <div id="nav-inner">
    <h1>
      <a href="#/basic/">
        <img src="http://docs.meteor.com/logo.png" class="logo" alt="Meteor">
        <div>1.2.0.2 Documentation</div>
      </a>
    </h1>

    <select class="basic-or-full">
    <option value="basic">Basic Docs</option>
    
  </select>

    
    <div class="basic-toc">
    
      <section>
        
          <h2 class="original"><a href="#/basic/quickstart" class="">Quick Start
          </a></h2>
<h2 class="translation"><a href="#/basic/quickstart" class="">クイックスタート</a></h2>
        
          <h2 class="original"><a href="#/basic/sevenprinciples" class="">Principles
          </a></h2>
<h2 class="translation"><a href="#/basic/sevenprinciples" class="">Meteorの特徴</a></h2>
        
          <h2 class="original"><a href="#/basic/learning-resources" class="">Learning Resources
          </a></h2>
<h2 class="translation"><a href="#/basic/learning-resources" class="">学習リソース</a></h2>
        
          <h2 class="original"><a href="#/basic/command-line" class="">Command Line Tool
          </a></h2>
<h2 class="translation"><a href="#/basic/command-line" class="">コマンドラインツール</a></h2>
        
          <h2 class="original"><a href="#/basic/filestructure" class="">File Structure
          </a></h2>
<h2 class="translation"><a href="#/basic/filestructure" class="">ファイル構造</a></h2>
        
          <h2 class="original"><a href="#/basic/buildingmobileapps" class="">Building Mobile Apps
          </a></h2>
<h2 class="translation"><a href="#/basic/buildingmobileapps" class="">モバイルアプリのビルド</a></h2>
        
        
        

        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/templates" class="">Templates
          </a></h2>
        
        
          <p class="subtitle original">Create views that update automatically when data changes</p>
<p class="subtitle translation">自動的にデータ変更を更新するビューを作成</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/defining-templates" class="">Defining templates in HTML</a>
              </li>
            
              <li>
                <a href="#/basic/Template-helpers" class="">Template.<em>name</em>.helpers</a>
              </li>
            
              <li>
                <a href="#/basic/Template-events" class="">Template.<em>name</em>.events</a>
              </li>
            
              <li>
                <a href="#/basic/Template-onRendered" class="">Template.<em>name</em>.onRendered</a>
              </li>
            
              <li>
                <a href="#/basic/Blaze-TemplateInstance-findAll" class=""><em>template</em>.findAll</a>
              </li>
            
              <li>
                <a href="#/basic/Blaze-TemplateInstance-find" class=""><em>template</em>.find</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/session" class="">Session
          </a></h2>
        
        
          <p class="subtitle original">Store temporary data for the user interface</p>
<p class="subtitle translation">ユーザーインターフェースのための一時的なデータ保存</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Session-set" class="">Session.set</a>
              </li>
            
              <li>
                <a href="#/basic/Session-get" class="">Session.get</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/tracker" class="">Tracker
          </a></h2>
        
        
          <p class="subtitle original">Re-run functions when data changes</p>
<p class="subtitle translation">データ変更時の再実行</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Tracker-autorun" class="">Tracker.autorun</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/collections" class="">Collections
          </a></h2>
        
        
          <p class="subtitle original">Store persistent data</p>
<p class="subtitle translation">永続データを格納</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Mongo-Collection" class="">Mongo.Collection</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-findOne" class=""><em>collection</em>.findOne</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-find" class=""><em>collection</em>.find</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-insert" class=""><em>collection</em>.insert</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-update" class=""><em>collection</em>.update</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-remove" class=""><em>collection</em>.remove</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-allow" class=""><em>collection</em>.allow</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-deny" class=""><em>collection</em>.deny</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/accounts" class="">Accounts
          </a></h2>
        
        
          <p class="subtitle original">Let users log in with passwords, Facebook, Google, GitHub, etc.</p>
<p class="subtitle translation">SNSを利用したソーシャルログイン</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/loginButtons" class="">{{&gt; loginButtons}}</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-user" class="">Meteor.user</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-userId" class="">Meteor.userId</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-users" class="">Meteor.users</a>
              </li>
            
              <li>
                <a href="#/basic/currentUser" class="">{{currentUser}}</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/methods" class="">Methods
          </a></h2>
        
        
          <p class="subtitle original">Call server functions from the client</p>
<p class="subtitle translation">クライアントからの実行</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Meteor-methods" class="">Meteor.methods</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-call" class="">Meteor.call</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-Error" class="">Meteor.Error</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/pubsub" class="">Publish / Subscribe
          </a></h2>
        
        
          <p class="subtitle original">Sync part of your data to the client</p>
<p class="subtitle translation">クライアント側へのデータ同期</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Meteor-publish" class="">Meteor.publish</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-subscribe" class="">Meteor.subscribe</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/environment" class="">Environment
          </a></h2>
        
        
          <p class="subtitle original">Control when and where your code runs</p>
<p class="subtitle translation">スクリプトの実行をコントロール</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Meteor-isClient" class="">Meteor.isClient</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-isServer" class="">Meteor.isServer</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-startup" class="">Meteor.startup</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/packages" class="">Packages
          </a></h2>
        
        
          <p class="subtitle original">Choose from thousands of community packages</p>
<p class="subtitle translation">コミュニティパッケージ</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/searchingforpackages" class="">Searching for packages</a>
              </li>
            
              <li>
                <a href="#/basic/accountsui" class="">accounts-ui</a>
              </li>
            
              <li>
                <a href="#/basic/coffeescript" class="">coffeescript</a>
              </li>
            
              <li>
                <a href="#/basic/email" class="">email</a>
              </li>
            
              <li>
                <a href="#/basic/jade" class="">jade</a>
              </li>
            
              <li>
                <a href="#/basic/jquery" class="">jquery</a>
              </li>
            
              <li>
                <a href="#/basic/http" class="">http</a>
              </li>
            
              <li>
                <a href="#/basic/less" class="">less</a>
              </li>
            
              <li>
                <a href="#/basic/markdown" class="">markdown</a>
              </li>
            
              <li>
                <a href="#/basic/underscore" class="">underscore</a>
              </li>
            
              <li>
                <a href="#/basic/spiderable" class="">spiderable</a>
              </li>
            
          </ul>
        
      </section>
    
  </div>
  </div>
    </div>
    <div class="overlay close-sidebar"></div>
    <div class="top-bar">
    <div class="hamburger-menu-target open-sidebar">
      <div class="hamburger-menu"></div>
    </div>
    <h1>
      <img src="http://docs.meteor.com/logo.png" class="logo" alt="Meteor"> 1.2.0.2 Docs
    </h1>
  </div>
    <div class="main-content">
      <div id="main">
        <div><div id="top"></div></div>
        
        <div class="">
          <div id="introduction">
<!-- clicking this anchor in the left bar should scroll to top of doc,
not here -->

<p><em><strong class="original">Meteor is an ultra-simple environment for building modern websites.
What once took weeks, even with the best tools, now takes hours with
Meteor.</strong>
<strong class="translation">MeteorはモダンなWebサイトを作るためのとてもシンプルな環境です。従来、優れたツールを使っても何週間もかかっていたものがMeteorでは数時間になります。</strong></em></p>

<p class="original">The web was originally designed to work in the same way that mainframes
worked in the 70s.  The application server rendered a screen and sent it
over the network to a dumb terminal. Whenever the user did anything,
that server rerendered a whole new screen. This model served the Web
well for over a decade. It gave rise to LAMP, Rails, Django, PHP.</p>
<p class="translation">Webはもともとは70年代のメインフレームと同じように動くように設計されました。アプリケーションサーバが描画した画面をネットワーク経由で端末に表示させます。ユーザが何かしたらサーバが画面全体を再描画します。このモデルは10年にわたってWebに残りました。そのため、LAMPやRailsやDjangoやPHPが伸びたのです。</p>

<p class="original">But the best teams, with the biggest budgets and the longest schedules,
now build applications in JavaScript that run on the client.  These apps
have stellar interfaces.  They don&apos;t reload pages.  They are reactive:
changes from any client immediately appear on everyone&apos;s screen.</p>
<p class="translation">しかし、優れたチームが大きな予算と長い開発期間をかけて、今ではクライアントで動作するJavaScriptアプリケーションを開発するようになりました。そのアプリケーションはすばらしいインタフェースを備えました。ページをリロードする必要がないのです。それらはリアクティブであり、あるクライアントでの変更が瞬時にすべての人の画面に反映されます。</p>

<p class="original">They&apos;ve built them the hard way.  Meteor makes it an order of
magnitude simpler, and a lot more fun.  You can build a complete
application in a weekend, or a sufficiently caffeinated hackathon.  No
longer do you need to provision server resources, or deploy API
endpoints in the cloud, or manage a database, or wrangle an ORM layer,
or swap back and forth between JavaScript and Ruby, or broadcast data
invalidations to clients.</p>
<p class="translation">開発者はとても苦労して作りあげたことでしょう。Meteorはそれを桁違いに簡単にし、楽しくします。ひとつの完全なアプリケーションを一週間で作ることができるでしょう。もしくは、一回の充実したハッカソンでも可能でしょう。サーバの準備もすることなく、クラウドにAPIを用意することもなく、データベースを管理することもなく、ORMレイヤーの論争をすることもなく、JavaScriptとRubyをいったりきたりすることもなく、データ形式のエラーをクライアントに伝搬することもありません。</p>

<h2 id="/basic/quickstart" class="original">Quick start!</h2>
<h2 id="/basic/quickstart" class="translation">クイックスタート！</h2>

<p class="original">Meteor supports <a href="https://github.com/meteor/meteor/wiki/Supported-Platforms">OS X, Windows, and Linux</a>.</p>
<p class="translation">Meteorは<a href="https://github.com/meteor/meteor/wiki/Supported-Platforms">OS X、Windows、Linux</a>をサポートしています。</p>

<p class="original">On Windows?  <a href="https://install.meteor.com/windows">Download the official Meteor installer here</a>.</p>
<p class="translation">Windows用のMeteorインストーラは<a href="https://install.meteor.com/windows">ここからダウンロードできます。</a></p>

<p class="original">On OS X or Linux?  Install the latest official Meteor release from your terminal:</p>
<p class="translation">OS XまたはLinuxならMeteor最新版をターミナルからインストールできます。</p>

<pre><code class="hljs bash">$ curl https://install.meteor.com/ | sh
</code></pre>

<p class="original">The Windows installer supports Windows 7, Windows 8.1, Windows Server
2008, and Windows Server 2012.  The command line installer supports Mac OS X
10.7 (Lion) and above, and Linux on x86 and x86_64 architectures.</p>
<p class="translation">WindowsインストーラはWindows 7、Windows 8.1、Windows Server 2008、Windows Server 2012をサポートしています。コマンドインストーラはMac OS X 10.7 (Lion)以上、またx86とx86_64アーキテクチャ上で動くLinuxをサポートしています。</p>

<p class="original">Once you&apos;ve installed Meteor, create a project:</p>
<p class="translation">Meteorをインストールしたら、プロジェクトを作成しましょう。</p>

<pre><code class="hljs bash">meteor create myapp
</code></pre>

<p class="original">Run it locally:</p>
<p class="translation">ローカルで動かします:</p>

<pre><code class="hljs bash"><span class="hljs-built_in">cd</span> myapp
meteor
<span class="hljs-comment"># Meteor server running on: http://localhost:3000/</span>
</code></pre>

<p class="original">Then, open a new terminal tab and unleash it on the world (on a free server we provide):</p>
<p class="translation">さらに、新しいターミナルタブを開き、以下のコマンドを実行して世界中に公開しましょう(Meteorが提供している無料のサーバー上で動きます):</p>

<pre><code class="hljs bash">meteor deploy myapp.meteor.com
</code></pre>

<h2 id="/basic/sevenprinciples" class="original">Principles of Meteor</h2>
<h2 id="/basic/sevenprinciples" class="translation">Meteorの特徴</h2>

<ul>
<li><p class="original"><em>Data on the Wire</em>. Meteor doesn&apos;t send HTML over the network. The server sends data and
lets the client render it.</p>
<p class="translation"><em>ネットワークを流れるデータ</em>. MeteorはネットワークでHTMLを送りません。サーバはデータを送り、クライアントがそれを描画します。</p></li>
<li><p class="original"><em>One Language.</em> Meteor lets you write both the client and the server parts of your
application in JavaScript.</p>
<p class="translation"><em>単一の言語.</em> Meteorでは、アプリケーションのクライアントサイドもサーバサイドも両方JavaScriptで記述します。</p></li>
<li><p class="original"><em>Database Everywhere</em>. You can use the same methods to access your
database from the client or the server.</p>
<p class="translation"><em>どこでもデータベース</em>. クライアントサイドでもサーバサイドでもデータベースにアクセスするのに同じメソッドを使うことができます。</p></li>
<li><p class="original"><em>Latency Compensation</em>. On the client, Meteor prefetches data and simulates models to make it look like server method calls return instantly.</p>
<p class="translation"><em>遅延の補償</em>. クライアントサイドではデータを事前取得しモデル変化を追従することにより、サーバのメソッド呼び出しの応答が瞬時にあったかのように見せかけます。</p></li>
<li><p class="original"><em>Full Stack Reactivity</em>. In Meteor, realtime is the default. All layers, from
database to template, update themselves automatically when necessary.</p>
<p class="translation"><em>フルスタックリアクティビティ</em>. Meteorでは、標準でリアルタイムです。データベースからテンプレートまでのすべてのレイヤーで必要に応じて自動で更新されます。</p></li>
<li><p class="original"><em>Embrace the Ecosystem</em>. Meteor is open source and integrates with existing open source tools and frameworks.</p>
<p class="translation"><em>エコシステムの採用</em>. Meteorはオープンソースであり、既存のオープンソースのツールやフレームワークと統合します。</p></li>
<li><p class="original"><em>Simplicity Equals Productivity</em>. The best way to make something
seem simple is to have it actually <em>be</em> simple. Meteor&apos;s main functionality has
clean, classically beautiful APIs.</p>
<p class="translation"><em>単純さによる生産性</em>. 何かを簡単に見せるための一番の方法は「単純」にすることです。Meteorの中心機能はクリーンできれいなAPIになっています。</p></li>
</ul>

<h2 id="/basic/learning-resources" class="original">Learning Resources</h2>
<h2 id="/basic/learning-resources" class="translation">学習リソース</h2>

<!-- https://github.com/blog/273-github-ribbons -->

<p><a href="http://github.com/meteor/meteor"><img class="github-ribbon visible-desktop" style="position: absolute; top: 0; right: 0; border: 0;" src="/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a></p>

<p class="original">There are many community resources for getting help with your app. If Meteor
catches your interest, we hope you&apos;ll get involved with the project!</p>
<p class="translation">Meteorには様々なコミュニティがあります。もしよろしければ、プロジェクトにご参加ください！</p>

<dl class="involved">
<dt class="original"><span>Tutorial</span></dt>
<dt class="translation">チュートリアル</dt>
<dd class="original">Get started fast with the <a href="https://www.meteor.com/install">official Meteor tutorial</a>!
</dd>
<dd class="translation"><a href="https://www.meteor.com/install">Meteor公式チュートリアル</a></dd>

<dt class="original"><span>Stack Overflow</span></dt>
<dt class="translation">スタック・オーバーフロー</dt>
<dd class="original">The best place to ask (and answer!) technical questions is on <a href="http://stackoverflow.com/questions/tagged/meteor">Stack
  Overflow</a>.  Be sure to add
  the <code>meteor</code> tag to your question.
</dd>
<dd class="translation">技術的な質問と回答に最適な場所は<a href="http://stackoverflow.com/questions/tagged/meteor">Stack Overflow</a>です。質問の際はMeteorタグを追加してください。</dd>

<dt class="original"><span>Forums</span></dt>
<dt class="translation">フォーラム</dt>
<dd class="original">Visit the <a href="https://forums.meteor.com">Meteor discussion
    forums</a> to announce projects, get help, talk about the community,
  or discuss changes to core.
</dd>
<dd class="translation">質問をする、プロジェクトを発表するまたは、コアへの変更を議論する際は<a href="https://forums.meteor.com">Meteorディスカッションフォーラム</a>へアクセスしてください。</dd>

<dt><span>GitHub</span></dt>
<dd class="original">The core code is on <a href="http://github.com/meteor/meteor">GitHub</a>.  If you&apos;re able to write code or file issues, we&apos;d love to have your help.  Please read <a href="https://github.com/meteor/meteor/wiki/Contributing-to-Meteor">Contributing to Meteor</a> for how to get started.
</dd>
<dd class="translation">コアコードは<a href="http://github.com/meteor/meteor">Github</a>上にあります。あなたの貢献をお待ちしています。貢献の際は、<a href="https://github.com/meteor/meteor/wiki/Contributing-to-Meteor">Contributing to Meteor</a>をお読みください。</dd>
</dl>
</div>

<h2 id="/basic/command-line" class="original">Command Line Tool</h2>
<h2 id="/basic/command-line" class="translation">コマンドラインツール</h2>

<h4 id="/basic/meteorhelp"><code>meteor help</code></h4>

<p class="original">Get help on <code>meteor</code> command line usage. Running <code>meteor help</code> by itself
will list the common <code>meteor</code> commands. Running <code>meteor help &lt;command&gt;</code>
will print detailed help about <code>meteor &lt;command&gt;</code>.</p>
<p class="translation"><code>meteor</code>コマンドラインツールのヘルプを見ます。<code>meteor help</code>を実行するとよく使うコマンドのリストが表示されます。<code>meteor help &lt;command&gt;</code>を実行すると<code>meteor &lt;command&gt;</code>の詳しい使い方が表示されます。</p>

<h4 id="/basic/meteorcreatename"><code>meteor create &lt;name&gt;</code></h4>

<p class="original">Make a subdirectory called <code>&lt;name&gt;</code> and create a new Meteor app there.</p>
<p class="translation"><code>&lt;name&gt;</code>という名前のディレクトリを作り、そこにMeteorアプリを新しく作ります。</p>

<h4 id="/basic/meteorrun"><code>meteor run</code></h4>

<p class="original">Serve the current app at <a href="http://localhost:3000">http://localhost:3000</a>
using Meteor&apos;s local development server.</p>
<p class="translation">アプリを起動し、<a href="http://localhost:3000">http://localhost:3000</a>にローカル開発サーバを用意します。</p>

<h4 id="/basic/meteordebug"><code>meteor debug</code></h4>

<p class="original">Run the project with Node Inspector attached, so that you can step through your server code line by line. See <a href="#/full/meteordebug"><code>meteor debug</code></a> in the full docs for more information.</p>
<p class="translation">Nodeインスペクタでアプリを起動します。これにより、サーバサイドのコードをステップ実行できます。詳しくはFull APIのドキュメントを参照してください。</p>

<h4 id="/basic/meteordeploysite"><code>meteor deploy &lt;site&gt;</code></h4>

<p class="original">Bundle your app and deploy it to <code>&lt;site&gt;</code>. Meteor provides free hosting if
you deploy to <code>&lt;your app&gt;.meteor.com</code> as long as <code>&lt;your app&gt;</code> is a name
that has not been claimed by someone else.</p>
<p class="translation">アプリを<code>&lt;site&gt;</code>にデプロイします。<code>&lt;your app&gt;.meteor.com</code>にデプロイした場合、Meteorは無料のホスティングを提供します。ただし、<code>&lt;your app&gt;</code>が既に他に人にとられていない場合です。</p>

<h4 id="/basic/meteorupdate"><code>meteor update</code></h4>

<p class="original">Update your Meteor installation to the latest released version and then
(if <code>meteor update</code> was run from an app directory) update the packages
used by the current app to the latest versions that are compatible with
all other packages used by the app.</p>
<p class="translation">インストールされたMeteorを最新のバージョンにします。さらに、コマンドがアプリのディレクトリから実行された場合には、そのアプリで使用しているパッケージのバージョンを互換性を保てる範囲でアップデートします。</p>

<h4 id="/basic/meteoradd"><code>meteor add</code></h4>

<p class="original">Add a package (or multiple packages) to your Meteor project. To query for
available packages, use the <code>meteor search</code> command.</p>
<p class="translation">パッケージをMeteorアプリに追加します。使えるパッケージを検索するには、<code>meteor search</code>コマンドを使います。</p>

<h4 id="/basic/meteorremove"><code>meteor remove</code></h4>

<p class="original">Remove a package previously added to your Meteor project. For a list of
the packages that your application is currently using, use the
<code>meteor list</code> command.</p>
<p class="translation">以前Meteorアプリに追加されたパッケージを削除します。現在使っているパッケージの一覧を表示するには、<code>meteor list</code>コマンドを使います。</p>

<h4 id="/basic/meteormongo"><code>meteor mongo</code></h4>

<p class="original">Opens a MongoDB shell for viewing and/or manipulating collections stored
in the database. Note that you must already be running a server for the
current app (in another terminal window) in order for <code>meteor mongo</code> to
connect to the app&apos;s database.</p>
<p class="translation">データベースに格納されているコレクションを閲覧もしくは操作するためのMongoDBシェルを開きます。<code>meteor mongo</code>でアプリのデータベースに接続するためには、あらかじめ(別のターミナルで)アプリを起動しておく必要があります。</p>

<h4 id="/basic/meteorreset"><code>meteor reset</code></h4>

<p class="original">Reset the current project to a fresh state. Removes all local data.</p>
<p class="translation">現在のアプリを完全に新しい状態にします。すべてのローカルデータが削除されます。</p>

<p class="original">If you use <code>meteor reset</code> often, but you have some initial data that you don&apos;t
want to discard, consider using <a href="#/basic/Meteor-startup"><code>Meteor.startup</code></a> to
recreate that data the first time the server starts up:</p>
<p class="translation"><code>meteor reset</code>をよく使う場合で、初期データを入れたい場合は、<a href="#/basic/Meteor-startup"><code>Meteor.startup</code></a>を使って次のようにサーバ起動時にデータを再生成するようにできます。</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (Meteor.isServer) {
  Meteor.startup(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (Rooms.find().count() === <span class="hljs-number">0</span>) {
      Rooms.insert({name: <span class="hljs-string">&quot;Initial room&quot;</span>});
    }
  });
}
</code></pre>
<h2 id="/basic/filestructure" class="original">File Structure</h2>
<h2 id="/basic/filestructure" class="translation">ファイル構造</h2>

<p class="original">Meteor is very flexible about how you structure the files in your app. It
automatically loads all of your files, so there is no need to use <code>&lt;script&gt;</code> or
<code>&lt;link&gt;</code> tags to include JavaScript or CSS.</p>
<p class="translation">Meteorはとても柔軟なファイル構造をしており、どこにファイルを置いても自動的に読み込まれます。そのため、CSSやJavaScriptを読み込むための<code>&lt;script&gt;</code>や<code>&lt;link&gt;</code>タグは必要ありません。</p>

<h3 id="/basic/defaultfileloading" class="original">Default file loading</h3>
<h3 id="/basic/defaultfileloading" class="translation">デフォルトのファイル読み込み</h3>

<p class="original">If files are outside of the special directories listed below, Meteor does the following:</p>
<p class="translation">もし特別なディレクトリ以外にファイルを置いた場合、Meteorは次の動きをします:</p>

<ol>
<li class="original">HTML templates are compiled and sent to the client. See <a href="#/basic/templates">the templates section</a> for more details.</li>
<li class="translation">HTMLテンプレートはコンパイルされクライアントに送られます。詳細は<a href="#/basic/templates">テンプレート</a>をご確認ください。</li>
<li class="original">CSS files are sent to the client. In production mode they are automatically concatenated and minified.</li>
<li class="translation">CSSファイルはクライアントに送られます。プロダクションモードでは、それらは自動的に結合されミニファイされます。</li>
<li class="original">JavaScript is loaded on the client and the server. You can use <code>Meteor.isClient</code> and <code>Meteor.isServer</code> to control where certain blocks of code run.</li>
<li class="translation">JavaScriptはクライアントとサーバーの両方で読み込まれます。<code>Meteor.isClient</code>と<code>Meteor.isServer</code>を使うと、クライアントまたはサーバーでのみコードを実行できます。</li>
</ol>

<p class="original">If you want more control over which JavaScript code is loaded on the client and
the server, you can use the special directories listed below.</p>
<p class="translation">クライアントやサーバー上でもっとJavaScriptコードの制御を行いたい場合は、以下の特別なディレクトリを使うこともできます。</p>

<h3 id="/basic/specialdirectories" class="original">Special directories</h3>
<h3 id="/basic/specialdirectories" class="translation">特別なディレクトリ</h3>

<h4 id="/basic/client"><code>/client</code></h4>

<p class="original">Any files here are only served to the client. This is a good place to keep your
HTML, CSS, and UI-related JavaScript code.</p>
<p class="translation">ここに置いたファイルはクライアントにのみ提供されます。ここはHTMLやCSS、UI関連のJavaScriptコードを保管するのに良い場所です。</p>

<h4 id="/basic/server"><code>/server</code></h4>

<p class="original">Any files in this directory are only used on the server, and are never sent to
the client. Use <code>/server</code> to store source files with sensitive logic or data
that should not be visible to the client.</p>
<p class="translation">このディレクトリに置いたファイルはサーバーでのみ使用され、クライアントには送られません。クライアントに見られたくない極秘のロジックやデータの入ったファイルは<code>/server</code>ディレクトリを使用してください。</p>

<h4 id="/basic/public"><code>/public</code></h4>

<p class="original">Files in <code>/public</code> are served to the client as-is. Use this to store assets such
as images. For example, if you have an image located at
<code>/public/background.png</code>, you can include it in your HTML with <code>&lt;img src=&apos;/background.png&apos;/&gt;</code> or in your CSS with <code>background-image:
url(/background.png)</code>. Note that <code>/public</code> is not part of the image URL.</p>
<p class="translation"><code>/public</code>に置いたファイルはそのままクライアントに提供されます。画像などのアセットを保管するために使用します。例えば、<code>/public/background.png</code>にイメージファイルを置くと、HTMLで<code>&lt;img src=&apos;/background.png&apos;/&gt;</code>もしくはCSSで<code>background-image: url(/background.png)</code>と記述することでそのファイルを読み込むことができます。注:<code>/public</code>は画像のURLに含まれません。</p>

<h4 id="/basic/private"><code>/private</code></h4>

<p class="original">These files can only be accessed by server code through <a href="#assets"><code>Assets</code></a> API and are not accessible to the client.</p>
<p class="translation">ここに置いたファイルはサーバーからは<a href="#assets"><code>Assets</code></a> API経由でのみアクセス可能で、クライアントからはアクセスできません。</p>

<p class="original">Read more about file load order and special directories in the <a href="#/full/structuringyourapp">Structuring Your
App section</a> of the full API documentation.</p>
<p class="translation">ファイルの読み込み順番と特別なディレクトリの詳細は、full API の<a href="#/full/structuringyourapp">Structuring Your App section</a>をお読みください。</p>
<h2 id="/basic/buildingmobileapps" class="original">Building Mobile Apps</h2>
<h2 id="/basic/buildingmobileapps" class="translation">モバイルアプリのビルド</h2>

<p class="original">Once you&apos;ve built your web app with Meteor, you can easily build a native
wrapper for your app and publish it to the Google Play Store or iOS App Store
with just a few commands. We&apos;ve put a lot of work into making the same packages
and APIs work on desktop and mobile, so that you don&apos;t have to worry about a lot
of the edge cases associated with mobile app development.</p>
<p class="translation">ウェブアプリをMeteorで構築すると、簡単にネイティブラッパーを作成でき、わずか数コマンドでGoogle Play StoreやiOS App Storeにそのアプリを配信できます。我々はデスクトップとモバイルで同一のパッケージとAPIが動くように、多くの努力をしており、モバイルアプリ開発に関連した多くの特殊なケースについて心配する必要はありません。</p>

<h3 id="/basic/installingmobilesdks" class="original">Installing mobile SDKs</h3>
<h3 id="/basic/installingmobilesdks" class="translation">モバイルSDKのインストール</h3>

<p class="original">Install the development tools for Android or iOS with one command:</p>
<p class="translation">1コマンドでAndroidまたはiOSの開発ツールをインストール:</p>

<pre><code class="hljs bash">meteor install-sdk android     <span class="hljs-comment"># for Android</span>
meteor install-sdk ios         <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/addingplatforms" class="original">Adding platforms</h3>
<h3 id="/basic/addingplatforms" class="translation">プラットフォームの追加</h3>

<p class="original">Add the relevant platform to your app:</p>
<p class="translation">あなたのアプリに関連するプラットフォームを追加:</p>

<pre><code class="hljs bash">meteor add-platform android    <span class="hljs-comment"># for Android</span>
meteor add-platform ios        <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/runningonasimulator" class="original">Running on a simulator</h3>
<h3 id="/basic/runningonasimulator" class="translation">シミュレータで動作確認</h3>

<pre><code class="hljs bash">meteor run android             <span class="hljs-comment"># for Android</span>
meteor run ios                 <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/runningonadevice" class="original">Running on a device</h3>
<h3 id="/basic/runningonadevice" class="translation">実機で動作確認</h3>

<pre><code class="hljs bash">meteor run android-device      <span class="hljs-comment"># for Android</span>
meteor run ios-device          <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/configuringappiconsandmetadata" class="original">Configuring app icons and metadata</h3>
<h3 id="/basic/configuringappiconsandmetadata" class="translation">アプリのアイコンとメタデータの設定</h3>

<p class="original">You can configure your app&apos;s icons, title, version number, splash screen, and other metadata with the special <a href="#/full/mobileconfigjs"><code>mobile-config.js</code> file</a>.</p>
<p class="translation">特別なファイルの<a href="#/full/mobileconfigjs"><code>mobile-config.js</code></a>でアプリのアイコン、タイトル、バージョン番号、スプラッシュスクリーン、その他のメタデータを設定することができます。</p>

<p class="original">Learn more about Meteor&apos;s mobile support on the <a href="https://github.com/meteor/meteor/wiki/Meteor-Cordova-Phonegap-integration">GitHub wiki page</a>.</p>
<p class="translation"><a href="https://github.com/meteor/meteor/wiki/Meteor-Cordova-Phonegap-integration">GitHub wiki ページ</a>でモバイルサポートについて詳しく学ぶことができます。</p>
  <h1 id="api">The Meteor API</h1>

<p class="original">Your JavaScript code can run in two environments: the <em>client</em> (browser), and
the <em>server</em> (a <a href="http://nodejs.org/">Node.js</a> container on a server).  For each
function in this API reference, we&apos;ll indicate if the function is available just
on the client, just on the server, or <em>Anywhere</em>.</p>
<p class="translation">JavaScriptコードは2つの環境で動きます。一つは<em>client</em>すなわちブラウザです。もう一つは、<em>server</em>すなわちサーバ上の<a href="http://nodejs.org/">Node.js</a>の中です。このAPI仕様書ではそれぞれの関数がどちらで動くものか明記されます。クライアントとサーバの両方で動く場合は<em>Anywhere</em>と示されます。</p>

<p></p><h2 id="/basic/templates"><span>Templates</span></h2>

<p class="original">In Meteor, views are defined in <em>templates</em>. A template is a snippet of HTML
that can include dynamic data. You can also interact with your templates from
JavaScript code to insert data and listen to events.</p>
<p class="translation">Meteorではビューは<em>templates</em>内に定義されます。一つのテンプレートは動的なデータを含むことのできるHTMLのスニペットです。テンプレートにはJavaScriptコードからアクセスでき、データを挿入したりイベントを待ち受けたりできます。</p>

<h3 class="api-title" id="/basic/defining-templates">Defining Templates in HTML</h3>

<p class="original">Templates are defined in <code>.html</code> files that can be located anywhere in your
Meteor project folder except the <code>server</code>, <code>public</code>, and <code>private</code> directories.</p>
<p class="translation">テンプレートは<code>.html</code>ファイルに定義されます。ファイルは複数でもよくMeteorプロジェクトディレクトリのどこにあっても構いません。ただし、次の3つのディレクトリは除きます。<code>server</code>と<code>public</code>と<code>private</code>。</p>

<p class="original">Each <code>.html</code> file can contain any number of the following top-level elements:
<code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, or <code>&lt;template&gt;</code>. Code in the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags is
appended to that section of the HTML page, and code inside <code>&lt;template&gt;</code> tags can
be included using <code>{{&gt; templateName}}</code>, as shown in the example below.
Templates can be included more than once — one of the main purposes of
templates is to avoid writing the same HTML multiple times by hand.</p>
<p class="translation"><code>.html</code>ファイルには次のトップレベル要素をいくつでも含むことができます。<code>&lt;head&gt;</code>や<code>&lt;body&gt;</code>や<code>&lt;template&gt;</code>。<code>&lt;head&gt;</code>と<code>&lt;body&gt;</code>タグのコードはすべて連結されHTMLページの所定の位置に入れられます。<code>&lt;template&gt;</code>タグのコードは<code>{{&gt; templateName}}</code>を使ってインクルードすることができます。次の例を参照してください。テンプレートは複数回インクルードすることができます。テンプレートは同じHTMLを複数回記述しなくすむためのものです。</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- add code to the &lt;head&gt; of the page --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>My website!<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>

<span class="hljs-comment">&lt;!-- add code to the &lt;body&gt; of the page --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  {{&gt; welcomePage}}
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>

<span class="hljs-comment">&lt;!-- define a template called welcomePage --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;welcomePage&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Welcome to my website!<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p class="original">The <code>{{ ... }}</code> syntax is part of a language called Spacebars that
Meteor uses to add functionality to HTML. As shown above, it lets you include
templates in other parts of your page. Using Spacebars, you can also display
data obtained from <em>helpers</em>. Helpers are written in JavaScript, and can be
either simple values or functions.</p>
<p class="translation"><code>{{ ... }}</code>という文法はMeteorがHTMLを拡張するためのSpacebarsという言語の一部です。上記の例ように、テンプレートをページの任意の位置にインクルードすることができます。Spacebarsを使うと<em>helpers</em>からのデータを表示することもできます。ヘルパーはJavaScriptで記述し、単なる値もしくは関数で書きます。</p>


<div class="api new-api-box">
  <h3 id="/basic/Template-helpers" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Template-helpers"><em>Template.myTemplate</em>.helpers(helpers)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Specify template helpers available to this template.</p>
<p class="translation">このテンプレート用のテンプレートヘルパーを指定する。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">helpers</span>
          <span class="type">Object</span>
        </dt>
        <dd>
          <p class="original">Dictionary of helper functions by name.</p>
<p class="translation">名前とヘルパー関数の辞書</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">Here&apos;s how you might define a helper called <code>name</code> for a template called
<code>nametag</code> (in JavaScript):</p>
<p class="translation">下記の例は、<code>nametag</code>というテンプレートに<code>name</code>とうヘルパー関数を定義するものです。(JavaScriptで)</p>

<pre><code class="hljs css"><span class="hljs-tag">Template</span><span class="hljs-class">.nametag</span><span class="hljs-class">.helpers</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">name</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Ben Bitdiddle&quot;</span>
</span></span></span>});
</code></pre>

<p class="original">And here is the <code>nametag</code> template itself (in HTML):</p>
<p class="translation">そしてこちらが<code>nametag</code>テンプレートそのものです。(HTMLで)</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- In an HTML file, display the value of the helper --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;nametag&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>My name is {{name}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p class="original">Spacebars also has a few other handy control structures that can be used
to make your views more dynamic:</p>
<p class="translation">Spacebarsには他にもビューを動的にする便利な制御構造が用意されています。</p>

<ul>
<li class="original"><code>{{#each data}} ... {{/each}}</code> - Iterate over the items in
<code>data</code> and display the HTML inside the block for each one.</li>
<li class="translation"><code>{{#each data}} ... {{/each}}</code> - <code>data</code>の要素について繰り返し、それぞれについてブロック内のHTMLを表示する</li>
<li class="original"><code>{{#if data}} ... {{else}} ... {{/if}}</code> - If <code>data</code>
is <code>true</code>, display the first block; if it is false, display the second one.</li>
<li class="translation"><code>{{#if data}} ... {{else}} ... {{/if}}</code> - もし<code>data</code>が<code>true</code>ならば、ひとつ目のブロックを表示する; falseならば、ふたつ目のブロックを表示する</li>
<li class="original"><code>{{#with data}} ... {{/with}}</code> - Set the data context of
the HTML inside, and display it.</li>
<li class="translation"><code>{{#with data}} ... {{/with}}</code> - ブロック内のHTMLをデータコンテキストを設定して、表示する</li>
</ul>

<p class="original">Each nested <code>#each</code> or <code>#with</code> block has its own <em>data context</em>, which is
an object whose properties can be used as helpers inside the block. For
<code>#with</code> blocks, the data context is simply the value that appears after
the <code>#with</code> and before the <code>}}</code> characters. For <code>#each</code> blocks, each
element of the given array becomes the data context while the block is
evaluated for that element.</p>
<p class="translation"><code>#each</code>や<code>#with</code>で囲まれたブロックは独自の<em>data context</em>を持ち、そのプロパティをブロック内で使うことができます。<code>#with</code>ブロックの場合は、<code>#with</code>と<code>}}</code>の間にある値が単にデータコンテキストになります。<code>#each</code>ブロックの場合は、与えられた配列のそれぞれの要素が、そのブロックを評価する際のデータコンテキストになります。</p>

<p class="original">For instance, if the <code>people</code> helper has the following value</p>
<p class="translation">例えば、<code>people</code>ヘルパーが次のような値を持つ場合</p>

<pre><code class="hljs css"><span class="hljs-tag">Template</span><span class="hljs-class">.welcomePage</span><span class="hljs-class">.helpers</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">people</span>:<span class="hljs-value"> [{name: <span class="hljs-string">&quot;Bob&quot;</span></span></span></span>}, <span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">name</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Frank&quot;</span></span></span></span>}, <span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">name</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Alice&quot;</span></span></span></span>}]
});
</code></pre>

<p class="original">then you can display every person&apos;s name as a list of <code>&lt;p&gt;</code> tags:</p>
<p class="translation">この場合は次のようにしてすべての人の名前を<code>&lt;p&gt;</code>タグのリストで表示することができます:</p>

<pre><code class="hljs html">{{#each people}}
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{{name}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
{{/each}}
</code></pre>

<p class="original">or use the &quot;nametag&quot; template from above instead of <code>&lt;p&gt;</code> tags:</p>
<p class="translation">もしくは<code>&lt;p&gt;</code>タグの代わりに上記の&quot;nametag&quot;テンプレートを使うこともできます:</p>

<pre><code class="hljs html">{{#each people}}
  {{&gt; nametag}}
{{/each}}
</code></pre>

<p class="original">Remember that helpers can be functions as well as simple values. For
example, to show the logged in user&apos;s username, you might define a
function-valued helper called <code>username</code>:</p>
<p class="translation">ヘルパーは単純な値だけでなく関数を指定することもできます。例えば、ログインユーザのユーザ名を表示するには、<code>username</code>というヘルパーに関数を指定することができます:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// in your JS file</span>
Template.profilePage.helpers({
  username: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Meteor.user() &amp;&amp; Meteor.user().username;
  }
});
</code></pre>

<p class="original">Now, each time you use the <code>username</code> helper, the helper function above
will be called to determine the user&apos;s name:</p>
<p class="translation">このとき、<code>username</code>ヘルパーを使う度に、上記のヘルパー関数が呼び出されユーザ名を決定することになります:</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- in your HTML --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;profilePage&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Profile page for {{username}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p class="original">Helpers can also take arguments. For example, here&apos;s a helper that pluralizes
a word:</p>
<p class="translation">ヘルパー関数は引数をとることもできます。例えば、下記は単語を複数形にする関数です:</p>

<pre><code class="hljs js">Template.post.helpers({
  commentCount: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(numComments)</span> </span>{
    <span class="hljs-keyword">if</span> (numComments === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1 comment&quot;</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> numComments + <span class="hljs-string">&quot; comments&quot;</span>;
    }
  }
});
</code></pre>

<p class="original">Pass in arguments by putting them inside the curly braces after the name of the
helper:</p>
<p class="translation">引数は{{}}ブロック内のヘルパー名の後に指定します:</p>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>There are {{commentCount 3}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>

<p class="original">The helpers above have all been associated with specific templates, but
you can also make a helper available in all templates by using
<a href="#template_registerhelper"><code>Template.registerHelper</code></a>.</p>
<p class="translation">上記のヘルパーはすべて特定のテンプレートに関連づけられていましたが、すべてのテンプレートで使えるヘルパーを作ることもできます。これには、<a href="#template_registerhelper"><code>Template.registerHelper</code></a>を使います。</p>

<p class="original">You can find detailed documentation for Spacebars in the
<a href="https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md">README on GitHub</a>.
Later in this documentation, the sections about <code>Session</code>, <code>Tracker</code>,
<code>Collections</code>, and <code>Accounts</code> will talk more about how to add dynamic data
to your templates.</p>
<p class="translation">Spacebarsに関する詳細ドキュメントは<a href="https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md">README on GitHub</a>にあります。本ドキュメント後半では、<code>Session</code>や<code>Tracker</code>や<code>Collections</code>や<code>Accounts</code>の説明があり、テンプレートに動的にデータを渡す方法についてさらに解説します。</p>


<div class="api new-api-box">
  <h3 id="/basic/Template-events" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Template-events"><em>Template.myTemplate</em>.events(eventMap)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Specify event handlers for this template.</p>
<p class="translation">テンプレートのイベントハンドラを指定する</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">eventMap</span>
          <span class="type"><a href="#eventmaps">Event Map</a></span>
        </dt>
        <dd>
          <p class="original">Event handlers to associate with this template.</p>
<p class="translation">テンプレートに関係づけるイベントハンドラ</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">The event map passed into <code>Template.myTemplate.events</code> has event descriptors as
its keys and event handler functions as the values. Event handlers get two
arguments: the event object and the template instance. Event handlers can also
access the data context of the target element in <code>this</code>.</p>
<p class="translation"><code>Template.myTemplate.events</code>に渡されるイベントハンドラはイベントディスクリプタをキーとしイベントハンドラの関数を値にしたオブジェクトです。イベントハンドラ関数は2つの引数をとります: イベントオブジェクトとテンプレートインスタンスです。また、イベントハンドラはターゲット要素のデータコンテキストに<code>this</code>でアクセスできます。</p>

<p class="original">To attach event handlers to the following template</p>
<p class="translation">次のテンプレートにイベントハンドラを指定するには</p>

<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;example&quot;</span>&gt;</span>
  {{#with myHelper}}
    <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;my-button&quot;</span>&gt;</span>My button<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;myInput&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&quot;submit&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">&quot;Submit Form&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
  {{/with}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p class="original">you might call <code>Template.example.events</code> as follows:</p>
<p class="translation">次のように<code>Template.example.events</code>を呼び出します。</p>

<pre><code class="hljs javascript">Template.example.events({
  <span class="hljs-string">&quot;click .my-button&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event, template)</span> </span>{
    alert(<span class="hljs-string">&quot;My button was clicked!&quot;</span>);
  },
  <span class="hljs-string">&quot;submit form&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event, template)</span> </span>{
    <span class="hljs-keyword">var</span> inputValue = event.target.myInput.value;
    <span class="hljs-keyword">var</span> helperValue = <span class="hljs-keyword">this</span>;
    alert(inputValue, helperValue);
  }
});
</code></pre>

<p class="original">The first part of the key (before the first space) is the name of the
event being captured. Pretty much any DOM event is supported. Some common
ones are: <code>click</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseenter</code>, <code>mouseleave</code>,
<code>keydown</code>, <code>keyup</code>, <code>keypress</code>, <code>focus</code>, <code>blur</code>, and <code>change</code>.</p>
<p class="translation">キーの前半(スペースの前)はイベント名です。ほとんどのDOMイベントがサポートされています。よく使うものは、<code>click</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseenter</code>, <code>mouseleave</code>, <code>keydown</code>, <code>keyup</code>, <code>keypress</code>, <code>focus</code>, <code>blur</code>, <code>change</code>です。</p>

<p class="original">The second part of the key (after the first space) is a CSS selector that
indicates which elements to listen to. This can be almost any selector
<a href="http://api.jquery.com/category/selectors/">supported by JQuery</a>.</p>
<p class="translation">キーの後半(スペースの後ろ)はどの要素を対象とするかを示すCSSセレクタです。これはほとんどすべての<a href="http://api.jquery.com/category/selectors/">supported by JQuery</a>のセレクタが使えます。</p>

Whenever the indicated event happens on the selected element, the
corresponding event handler function will be called with the relevant DOM
event object and template instance. See the [Event Maps section](#eventmaps)
for details.
<!-- TODO Update the link to full docs for Event Maps -->


<div class="api new-api-box">
  <h3 id="/basic/Template-onRendered" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Template-onRendered"><em>Template.myTemplate</em>.onRendered</a>

    
  </h3>

  <div class="desc">
    <p class="original">Register a function to be called when an instance of this template is inserted into the DOM.</p>
<p class="translation">テンプレートがDOMに追加されたときに呼び出される関数を登録する。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">A function to be added as a callback.</p>
<p class="translation">コールバック関数</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">The functions added with this method are called once for every instance of
<em>Template.myTemplate</em> when it is inserted into the page for the first time.</p>
<p class="translation">このメソッドにより追加された関数は、<em>Template.myTemplate</em>のすべてのインスタンスが初めてページに挿入されるときに、一度だけ呼び出されます。</p>

<p class="original">These callbacks can be used to integrate external libraries that
aren&apos;t familiar with Meteor&apos;s automatic view rendering, and need to be
initialized every time HTML is inserted into the page.
You can perform initialization or clean-up on any objects in
<a href="#template_oncreated"><code>onCreated</code></a> and <a href="#template_ondestroyed"><code>onDestroyed</code></a>
callbacks.</p>
<p class="translation">これらのコールバック関数は外部ライブラリを使うことに利用できます。外部ライブラリはMeteorの自動ビューレンダリングをそのままでは使えず、HTMLがページに挿入されるたびに初期化する必要があります。初期化や終了の処理は<a href="#template_oncreated"><code>onCreated</code></a>と<a href="#template_ondestroyed"><code>onDestroyed</code></a>のコールバック内で行うことができます。</p>

<p class="original">For example, to use the HighlightJS library to apply code highlighting to
all <code>&lt;pre&gt;</code> elements inside the <code>codeSample</code> template, you might pass
the following function to <code>Template.codeSample.onRendered</code>:</p>
<p class="translation">例えば、<code>codeSample</code>テンプレート内のすべての<code>&lt;pre&gt;</code>要素をハイライトするためにHighlightJSライブラリを使う場合は、次の関数を<code>Template.codeSample.onRendered</code>に渡すでしょう:</p>

<pre><code class="hljs javascript">Template.codeSample.onRendered(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  hljs.highlightBlock(<span class="hljs-keyword">this</span>.findAll(<span class="hljs-string">&apos;pre&apos;</span>));
});
</code></pre>

<p class="original">In the callback function, <code>this</code> is bound to a <a href="#template_inst">template
instance</a> object that is unique to this inclusion of the
template and remains across re-renderings. You can use methods like
<a href="#template_find"><code>this.find</code></a> and
<a href="#template_findAll"><code>this.findAll</code></a> to access DOM nodes in the template&apos;s
rendered HTML.</p>
<p class="translation">コールバック関数の中では、<code>this</code>は<a href="#template_inst">template instance</a>オブジェクトになります。このオブジェクトはこのテンプレートに固有のもので再描画されても変わりません。テンプレートHTMLのDOMにアクセスするために<a href="#template_find"><code>this.find</code></a>や<a href="#template_findAll"><code>this.findAll</code></a>などのメソッドを使うことができます。</p>

<h2 id="/basic/template_inst"><span>Template instances</span></h2>

<p class="original">A template instance object represents a single inclusion of a template in the
document.  It can be used to access the HTML elements inside the template and it
can be assigned properties that persist as the template is reactively updated.</p>
<p class="translation">テンプレートインスタンスオブジェクトはドキュメント中の一つのテンプレートの挿入に相当します。このオブジェクトはテンプレート内のHTML要素へのアクセスやプロパティ保持に使われます。プロパティはテンプレートがリアクティブに更新されても変化しません。</p>

<p class="original">Template instance objects can be found in several places:</p>
<p class="translation">テンプレートインスタンスオブジェクトは複数の所で使用されます:</p>

<ol>
<li class="original">The value of <code>this</code> in the <code>created</code>, <code>rendered</code>,
and <code>destroyed</code> template callbacks</li>
<li class="translation"><code>created</code>や<code>rendered</code>や<code>destroyed</code>のコールバック内の<code>this</code>の値</li>
<li class="original">The second argument to event handlers</li>
<li class="translation">イベントハンドラの第二引数</li>
<li class="original">As <a href="#template_instance"><code>Template.instance()</code></a> inside helpers</li>
<li class="translation">ヘルパー関数内での<a href="#template_instance"><code>Template.instance()</code></a></li>
</ol>

<p class="original">You can assign additional properties of your choice to the template instance to
keep track of any state relevant to the template. For example, when using the
Google Maps API you could attach the <code>map</code> object to the current template
instance to be able to refer to it in helpers and event handlers. Use the
<a href="#template_onCreated"><code>onCreated</code></a> and <a href="#template_onDestroyed"><code>onDestroyed</code></a>
callbacks to perform initialization or clean-up.</p>
<p class="translation">テンプレートには追加で開発者が任意のプロパティを設定することができます。このプロパティはテンプレートの状態を保持することに使えます。例えば、Google Maps APIを使う場合に、<code>map</code>オブジェクトをテンプレートインスタンスに設定し、ヘルパー関数やイベントハンドラ関数から参照することができます。初期化や終了の処理には、<a href="#template_onCreated"><code>onCreated</code></a>や<a href="#template_onDestroyed"><code>onDestroyed</code></a>のコールバックを使いましょう。</p>


<div class="api new-api-box">
  <h3 id="/basic/Blaze-TemplateInstance-findAll" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Blaze-TemplateInstance-findAll"><em>template</em>.findAll(selector)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Find all elements matching <code>selector</code> in this template instance.</p>
<p class="translation">テンプレート内で<code>selector</code>にマッチする要素をすべて見つける</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">The CSS selector to match, scoped to the template contents.</p>
<p class="translation">マッチするCSSセレクタ。テンプレート内に限定される。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original"><code>template.findAll</code> returns an array of DOM elements matching <code>selector</code>. You can
also use <code>template.$</code>, which works exactly like the JQuery <code>$</code> function but only
returns elements within <code>template</code>.</p>
<p class="translation"><code>template.findAll</code>は、<code>selector</code>にマッチするDOM要素の配列を返します。また、<code>template.$</code>はJQueryの<code>$</code>と同じように使える関数です。ただし、<code>template</code>内の要素しか返しません。</p>


<div class="api new-api-box">
  <h3 id="/basic/Blaze-TemplateInstance-find" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Blaze-TemplateInstance-find"><em>template</em>.find(selector)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Find one element matching <code>selector</code> in this template instance.</p>
<p class="translation">テンプレート内で<code>selector</code>にマッチする要素をひとつ見つける</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">The CSS selector to match, scoped to the template contents.</p>
<p class="translation">マッチするCSSセレクタ。テンプレート内に限定される。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<!-- XXX Why is this not findOne? -->

<p class="original"><code>find</code> is just like <code>findAll</code> but only returns the first element found. Like
<code>findAll</code>, <code>find</code> only returns elements from inside the template.</p>
<p class="translation"><code>find</code>は<code>findAll</code>とほぼ同じですが、最初に見つかったひとつの要素だけを返します。<code>findAll</code>と同じく、<code>find</code>はテンプレート内の要素だけを返します。</p>
<h2 id="/basic/session"><span>Session</span></h2>

<p class="original"><code>Session</code> provides a global object on the client that you can use to
store an arbitrary set of key-value pairs. Use it to store things like
the currently selected item in a list.</p>
<p class="translation">Session(セッション)はクライアント上のグローバルオブジェクトとして提供され、キーと値のペアのセットを格納するために使用できます。それは、リストで現在選択している項目のようなものを一時的に保持するのに使用します。</p>

<p class="original">What&apos;s special about <code>Session</code> is that it&apos;s <em>reactive</em>. If you call
<code>Session.get(&quot;myKey&quot;)</code> in a <a href="#template_helpers">template helper</a> or inside
<a href="#tracker_autorun"><code>Tracker.autorun</code></a>, the relevant part of the template will
be re-rendered automatically whenever <code>Session.set(&quot;myKey&quot;, newValue)</code> is
called.</p>
<p class="translation"><code>Session</code>が特別なのは<em>リアクティブ</em>であるところです。<a href="#template_helpers">template helper</a>や<a href="#tracker_autorun"><code>Tracker.autorun</code></a>の中で、<code>Session.get(&quot;myKey&quot;)</code>と記述しておくと、どこかで<code>Session.set(&quot;myKey&quot;, newValue)</code>を呼び出した時に、テンプレートの関連する部分が自動的に再描画されます。</p>


<div class="api new-api-box">
  <h3 id="/basic/Session-set" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Session-set">Session.set(key, value)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Set a variable in the session. Notify any listeners that the value
has changed (eg: redraw templates, and rerun any
<a href="#tracker_autorun"><code>Tracker.autorun</code></a> computations, that called
<a href="#session_get"><code>Session.get</code></a> on this <code>key</code>.)</p>
<p class="translation">セッションに変数をセットします。また、リスナーに値が変更されたことが通知されます(例: <code>Session.get</code>でこのキーを呼び出しているテンプレートを再描画したり、<a href="#tracker_autorun"><code>Tracker.autorun</code></a>処理を再実行します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">key</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">The key to set, eg, <code>selectedItem</code></p>
<p class="translation">セッションのキー、例: <code>selectedItem</code></p>
        </dd>
      
        <dt>
          <span class="name">value</span>
          <span class="type"><a href="#ejson">EJSON-able Object</a> or undefined</span>
        </dt>
        <dd>
          <p class="original">The new value for <code>key</code></p>
<p class="translation"><code>key</code>の新しい値</p>
        </dd>
      
    </dl>
  

  

  
</div>

<!-- XXX The Session.set API box is a little wonky -->


<div class="api new-api-box">
  <h3 id="/basic/Session-get" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Session-get">Session.get(key)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Get the value of a session variable. If inside a <a href="#reactivity">reactive
computation</a>, invalidate the computation the next time the
value of the variable is changed by <a href="#session_set"><code>Session.set</code></a>. This
returns a clone of the session value, so if it&apos;s an object or an array,
mutating the returned value has no effect on the value stored in the
session.</p>
<p class="translation">セッション変数の値を取得します。もしリアクティブ処理の中では、Session.setにより変数の値が変更になった場合に処理が無効化（再計算）されます。これはセッション値のクローンを返します。そのため、それがオブジェクトまたは配列の場合、返された値を変更したとしても、セッションに格納されている値には影響を与えません。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">key</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">The name of the session variable to return</p>
<p class="translation">値を取得したいセッション変数名</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Example:</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- In your template --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;main&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>We&apos;ve always been at war with {{theEnemy}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// In your JavaScript</span>
Template.main.helpers({
  theEnemy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Session.get(<span class="hljs-string">&quot;enemy&quot;</span>);
  }
});

Session.set(<span class="hljs-string">&quot;enemy&quot;</span>, <span class="hljs-string">&quot;Eastasia&quot;</span>);
<span class="hljs-comment">// Page will say &quot;We&apos;ve always been at war with Eastasia&quot;</span>

Session.set(<span class="hljs-string">&quot;enemy&quot;</span>, <span class="hljs-string">&quot;Eurasia&quot;</span>);
<span class="hljs-comment">// Page will change to say &quot;We&apos;ve always been at war with Eurasia&quot;</span>
</code></pre>

<p class="original">Using <code>Session</code> gives us our first taste of <em>reactivity</em>, the idea that the view
should update automatically when necessary, without us having to call a <code>render</code>
function manually. In the next section, we will learn how to use Tracker, the
lightweight library that makes this possible in Meteor.</p>
<p class="translation"><code>Session</code>を使うと、<code>render</code>ファンクションを手動で呼び出すことなく、必要に応じて自動でビューを更新する<em>リアクティビティ</em>の一端に触れることができます。次のセクションでは、Meteorでこれを可能にしている軽量ライブラリTrackerの使い方を学習します。</p>
<h2 id="/basic/tracker"><span>Tracker</span></h2>

<p class="original">Meteor has a simple dependency tracking system which allows it to
automatically rerun templates and other functions whenever
<a href="#session"><code>Session</code></a> variables, database queries, and other data
sources change.</p>
<p class="translation">Meteorはシンプルな依存関係のトラッキングシステムをもっており、<a href="#session"><code>Session</code></a>変数やデータベースクエリ、その他データソースを変更を検知して、自動的にテンプレートを再描画したり関数を再実行します。</p>

<p class="original">Unlike most other systems, you don&apos;t have to manually declare these dependencies
— it &quot;just works.&quot; The mechanism is simple and efficient. Once you&apos;ve
initialized a computation with <code>Tracker.autorun</code>, whenever you call a Meteor function that returns data, <code>Tracker</code> automatically records which data were
accessed. Later, when this data changes, the computation is rerun automatically.
This is how a template knows how to re-render whenever its <a href="#template_helpers">helper
functions</a> have new data to return.</p>
<p class="translation">他のほとんどのシステムとは異なり、手動でこれらの依存関係を宣言する必要はありません。特に何もしなくても動きます。そのメカニズムはシンプルかつ効率的です。<code>Tracker.autorun</code>で処理を初期化すると、データを返すMeteor関数を呼び出した場合に、どのデータにアクセスしたかが自動で記録されます。その後、そのデータが変更されると、処理が自動的に再実行されます。このようにして、<a href="#template_helpers">ヘルパー関数</a>が新しいデータを返すとテンプレートは再レンダリングが必要なことを検知できます。</p>


<div class="api new-api-box">
  <h3 id="/basic/Tracker-autorun" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Tracker-autorun">Tracker.autorun(runFunc, [options])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Run a function now and rerun it later whenever its dependencies
change. Returns a Computation object that can be used to stop or observe the
rerunning.</p>
<p class="translation">関数を直ちに実行し、また依存関係にあるものが変更されるたびに、後でそれを実行します。停止または再実行を観察するために使用することができる演算オブジェクトを返します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">runFunc</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">The function to run. It receives
one argument: the Computation object that will be returned.</p>
<p class="translation">実行する関数。1つの引数を取る: 演算オブジェクトを返します。</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">onError</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Optional. The function to run when an error
happens in the Computation. The only argument it recieves is the Error
thrown. Defaults to the error being logged to the console.</p>
<p class="translation">オプション。runFuncでエラーが発生した時にこの関数を実行します。この関数は1つの引数を取り、発生したエラーを受け取ります。省略した場合、デフォルトではコンソールにエラーを出力します。</p>
        </dd>
      
    </dl>
  

  
</div>


<p class="original"><code>Tracker.autorun</code> allows you to run a function that depends on reactive
data sources. Whenever those data sources are updated with new data, the
function will be rerun.</p>
<p class="translation"><code>Tracker.autorun</code>はリアクティブデータソースに依存した関数を実行できるようにします。これらのデータソースが新しいデータで更新されるたびに、その関数は再実行されます。</p>

<p class="original">For example, you can monitor one <code>Session</code> variable and set another:</p>
<p class="translation">例えば、1つの<code>Session</code>変数を監視し、それを別のものにセットすることができます:</p>

<pre><code class="hljs javascript">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> celsius = Session.get(<span class="hljs-string">&quot;celsius&quot;</span>);
  Session.set(<span class="hljs-string">&quot;fahrenheit&quot;</span>, celsius * <span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>);
});
</code></pre>

<p class="original">Or you can wait for a session variable to have a certain value, and do
something the first time it does. If you want to prevent further rerunning
of the function, you can call <code>stop</code> on the computation object that is
passed as the first parameter to the callback function:</p>
<p class="translation">また、Session変数が特定の値になった時に初めて処理を実行するようにもできます。もし、これ以上関数を再実行させたくなければ、コールバック関数の第１引数に渡される演算オブジェクトの<code>stop</code>を呼び出すことで、再実行しないようにできます。</p>

<pre><code class="hljs cs"><span class="hljs-comment">// Initialize a session variable called &quot;counter&quot; to 0</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// The autorun function runs but does not alert (counter: 0)</span>
Tracker.autorun(function (computation) {
  <span class="hljs-keyword">if</span> (Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) === <span class="hljs-number">2</span>) {
    computation.stop();
    alert(<span class="hljs-string">&quot;counter reached two&quot;</span>);
  }
});

<span class="hljs-comment">// The autorun function runs but does not alert (counter: 1)</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) + <span class="hljs-number">1</span>);

<span class="hljs-comment">// The autorun function runs and alerts &quot;counter reached two&quot;</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) + <span class="hljs-number">1</span>);

<span class="hljs-comment">// The autorun function no longer runs (counter: 3)</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) + <span class="hljs-number">1</span>);
</code></pre>

<p class="original">The first time <code>Tracker.autorun</code> is called, the callback function is
invoked immediately, at which point it alerts and stops right away if
<code>counter === 2</code> already. In this example, <code>Session.get(&quot;counter&quot;) === 0</code>
when <code>Tracker.autorun</code> is called, so nothing happens the first time, and
the function is run again each time <code>counter</code> changes, until
<code>computation.stop()</code> is called after <code>counter</code> reaches <code>2</code>.</p>
<p class="translation">初めて<code>Tracker.autorun</code>が呼ばれると、コールバック関数はすぐに実行され、もしすでに <code>counter === 2</code> の場合は、アラートを表示してすぐに停止します。上の例では、<code>Tracker.autorun</code>が呼ばれた時は <code>Session.get(&quot;counter&quot;) === 0</code> なので、初めは何も起きません。そして、<code>counter</code>が<code>2</code>になり<code>computation.stop()</code>が呼ばれるまでは、<code>counter</code>が変更されるたびに関数が実行されます。</p>

<p class="original">If the initial run of an autorun throws an exception, the computation
is automatically stopped and won&apos;t be rerun.</p>
<p class="translation">もし、autorunの初期実行で例外が発生すると、自動的に処理は停止し、再実行されることはありません。</p>

<p class="original">To learn more about how <code>Tracker</code> works and to explore advanced ways to
use it, visit the <a href="http://manual.meteor.com/#tracker">Tracker</a>
chapter in the <a href="http://manual.meteor.com/">Meteor Manual</a>,
which describes it in much more detail.</p>
<p class="translation"><code>Tracker</code>の動きについてもっと学習したり、高度な使い方を知りたい場合は、<a href="http://manual.meteor.com/">Meteor Manual</a>の<a href="http://manual.meteor.com/#tracker">Tracker</a>チャプターにより詳細な説明があります。</p>
<h2 id="/basic/collections"><span>Collections</span></h2>

<p class="original">Meteor stores data in <em>collections</em>. JavaScript objects stored in collections
are called <code>documents</code>.  To get started, declare a collection with
<code>new Mongo.Collection</code>.</p>
<p class="translation">Meteorは<em>コレクション</em>の中にデータを保存します。コレクションの中に保存されたJavaScriptオブジェクトは<code>documents</code>(ドキュメント)と呼ばれます。開始するには、<code>new Mongo.Collection</code> でコレクションを宣言します。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection">new Mongo.Collection(name, [options])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Constructor for a Collection</p>
<p class="translation">コレクションのコンストラクタ</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.</p>
<p class="translation">コレクション名。もしnullを指定した場合、管理されない(同期されない)ローカルコレクションを作ります。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">Calling the <code>Mongo.Collection</code> constructor creates a collection object
which acts just like a MongoDB collection. If you pass a name when you
create the collection, then you are declaring a persistent collection
— one that is stored on the server and can be published to clients.</p>
<p class="translation"><code>Mongo.Collection</code>コンストラクタを呼び出すと、ちょうどMongoDBコレクションのように動作するコレクション・オブジェクトを作成します。コレクションを作成する時に名前を渡すと、永続的なコレクションの宣言になります。それはサーバーに保存され、クライアントに配信することができます。</p>

<p class="original">To allow both client code and server code to access the same collection
using the same API, it&apos;s usually best to declare collections as global
variables in a JavaScript file that&apos;s present on both client and server.</p>
<p class="translation">クライアントコードとサーバーコードの両方が同じAPIを使用して同じコレクションにアクセスできるようにするには、クライアントとサーバーの両方で使用されるJavaScriptファイル内で、グローバル変数としてコレクションを宣言します。</p>

<p class="original">Here&apos;s an example of declaring two named, persistent collections as global
variables:</p>
<p class="translation">ここで、グローバル変数として永続的なコレクションを2つ宣言する例を示します:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// In a JS file that&apos;s loaded on the client and the server</span>
Posts = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">&quot;posts&quot;</span>);
Comments = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">&quot;comments&quot;</span>);
</code></pre>

<p class="original">If you pass <code>null</code> as the name, then you&apos;re creating a local
collection. Local collections are not synchronized between the client and
the server; they are just temporary collections of JavaScript objects that
support Mongo-style <code>find</code>, <code>insert</code>, <code>update</code>, and <code>remove</code> operations.</p>
<p class="translation">もしnullを名前に渡すと、ローカルコレクションを作成します。ローカルコレクションはクライアントとサーバー間で同期されません。これらはMongoスタイルの<code>find</code>、<code>insert</code>、<code>update</code>、<code>remove</code>をサポートしたJavaScriptオブジェクトの一時的なコレクションとなります。</p>

<p class="original">By default, Meteor automatically publishes every document in your
collection to each connected client. To disable this behavior, you must
remove the <code>autopublish</code> package, in your terminal:</p>
<p class="translation">デフォルトでは、Meteorは自動的にあなたのコレクションのすべてのドキュメントを接続しているクライアントに配信します。この振る舞いを止めるには、ターミナルで以下のコマンドを実行して、<code>autopublish</code>パッケージを取り除く必要があります:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> remove autopublish
</code></pre>

<p class="original">Then, use <a href="#meteor_publish"><code>Meteor.publish</code></a> and
<a href="#meteor_subscribe"><code>Meteor.subscribe</code></a> to specify which parts of your
collection should be published to which clients.</p>
<p class="translation">それから、コレクションの一部をどのクライアントに配信するかを指定するため、<a href="#meteor_publish"><code>Meteor.publish</code></a>と<a href="#meteor_subscribe"><code>Meteor.subscribe</code></a>を使用します。</p>

<p class="original">Use <code>findOne</code> or <code>find</code> to retrieve documents from a collection.</p>
<p class="translation">コレクションからドキュメントを取得するには、<code>findOne</code>や<code>find</code>を使用します。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-findOne" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-findOne"><em>collection</em>.findOne([selector], [options])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Finds the first document that matches the selector, as ordered by sort and skip options.</p>
<p class="translation">selectorにマッチする初めのドキュメントを検索します。sortやskipオプションで順序を指定できます。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p class="original">A query describing the documents to find</p>
<p class="translation">ドキュメントを検索するためのクエリ</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">sort</span>
          <span class="type"><a href="#sortspecifiers">Mongo Sort Specifier</a></span>
        </dt>
        <dd>
          <p class="original">Sort order (default: natural order)</p>
<p class="translation">ソート順 (デフォルト: 自然な順序)</p>
        </dd>
      
        <dt>
          <span class="name">skip</span>
          <span class="type">Number</span>
        </dt>
        <dd>
          <p class="original">Number of results to skip at the beginning</p>
<p class="translation">結果の先頭からスキップする数</p>
        </dd>
      
        <dt>
          <span class="name">fields</span>
          <span class="type"><a href="#fieldspecifiers">Mongo Field Specifier</a></span>
        </dt>
        <dd>
          <p class="original">Dictionary of fields to return or exclude.</p>
<p class="translation">取得する or 除外するフィールド</p>
        </dd>
      
    </dl>
  

  
</div>


<p class="original">This method lets you retrieve a specific document from your
collection. The <code>findOne</code> method is most commonly called with a specific
document <code>_id</code>:</p>
<p class="translation">このメソッドは特定のドキュメントをコレクションから取得します。<code>findOne</code>メソッドは特定のドキュメント<code>_id</code>と共に呼び出されるのが最も一般的です:</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> post = Posts.findOne(postId);
</code></pre>

<p class="original">However, you can also call <code>findOne</code> with a Mongo selector, which is an
object that specifies a required set of attributes of the desired
document. For example, this selector</p>
<p class="translation">しかしながら、ドキュメントの属性のセットを細かく指定したMongoセレクタで<code>findOne</code>を呼び出すこともできます。たとえば、このセレクタは:</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> post = Posts.findOne({
  createdBy: <span class="hljs-string">&quot;12345&quot;</span>,
  title: {$regex: <span class="hljs-regexp">/first/</span>}
});
</code></pre>

<p class="original">will match this document</p>
<p class="translation">このドキュメントにマッチします</p>

<pre><code class="hljs css"><span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">createdBy</span>:<span class="hljs-value"> <span class="hljs-string">&quot;12345&quot;</span>,
  title: <span class="hljs-string">&quot;My first post!&quot;</span>,
  content: <span class="hljs-string">&quot;Today was a good day.&quot;</span>
</span></span></span>}
</code></pre>

<p class="original">You can read about MongoDB query operators such as <code>$regex</code>, <code>$lt</code> (less than),
<code>$text</code> (text search), and more in the <a href="http://docs.mongodb.org/manual/reference/operator/query/">MongoDB
documentation</a>.</p>
<p class="translation"><code>$regex</code> (正規表現)、<code>$lt</code> (より小さい)、<code>$text</code> (テキスト検索)など多くのMongoDBクエリ操作について、詳しくは<a href="http://docs.mongodb.org/manual/reference/operator/query/">MongoDBドキュメント</a>をご覧ください。</p>

<p class="original">One useful behavior that might not be obvious is that Mongo selectors also
match items in arrays. For example, this selector</p>
<p class="translation">明確ではないかもしれませんが、ひとつの便利な動作として、Mongoセレクタは配列内の要素にもマッチします。たとえば、このセレクタは</p>

<pre><code class="hljs css"><span class="hljs-tag">Post</span><span class="hljs-class">.findOne</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">tags</span>:<span class="hljs-value"> <span class="hljs-string">&quot;meteor&quot;</span>
</span></span></span>});
</code></pre>

<p class="original">will match this document</p>
<p class="translation">このドキュメントにマッチします</p>

<pre><code class="hljs css"><span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">title</span>:<span class="hljs-value"> <span class="hljs-string">&quot;I love Meteor&quot;</span>,
  createdBy: <span class="hljs-string">&quot;242135223&quot;</span>,
  tags: [<span class="hljs-string">&quot;meteor&quot;</span>, <span class="hljs-string">&quot;javascript&quot;</span>, <span class="hljs-string">&quot;fun&quot;</span>]
</span></span></span>}
</code></pre>

<p class="original">The <code>findOne</code> method is reactive just like <a href="#session_get"><code>Session.get</code></a>,
meaning that, if you use it inside a <a href="#template_helpers">template helper</a>
or a <a href="#tracker_autorun"><code>Tracker.autorun</code></a> callback, it will automatically
rerender the view or rerun the computation if the returned document
changes.</p>
<p class="translation"><code>findOne</code>メソッドは<a href="#session_get"><code>Session.get</code></a>のようにリアクティブです。すなわち、<a href="#template_helpers">テンプレートヘルパー</a>の中や<a href="#tracker_autorun"><code>Tracker.autorun</code></a>のコールバックで使用すると、ドキュメントが更新された時に自動的に表示が再描画されたり、計算処理が再実行されます。</p>

<p class="original">Note that <code>findOne</code> will return <code>null</code> if it fails to find a matching document,
which often happens if the document hasn&apos;t been loaded yet or has been removed
from the collection, so you should be prepared to handle <code>null</code> values.</p>
<p class="translation">注:<code>findOne</code>はマッチするドキュメントが見つからなかった時に<code>null</code>を返します。それはドキュメントがまだ読み込まれていなかったり、コレクションからドキュメントを取り除いた時に頻繁に起こります。そのため<code>null</code>値の場合の処理を用意する必要があります。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-find" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-find"><em>collection</em>.find([selector], [options])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Find the documents in a collection that match the selector.</p>
<p class="translation">コレクションの中からselectorにマッチしたドキュメントを検索します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p class="original">A query describing the documents to find</p>
<p class="translation">ドキュメントを検索するためのクエリ</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">sort</span>
          <span class="type"><a href="#sortspecifiers">Mongo Sort Specifier</a></span>
        </dt>
        <dd>
          <p class="original">Sort order (default: natural order)</p>
<p class="translation">ソート順 (デフォルト: 自然な順序)</p>
        </dd>
      
        <dt>
          <span class="name">skip</span>
          <span class="type">Number</span>
        </dt>
        <dd>
          <p class="original">Number of results to skip at the beginning</p>
<p class="translation">結果の先頭からスキップする数</p>
        </dd>
      
        <dt>
          <span class="name">limit</span>
          <span class="type">Number</span>
        </dt>
        <dd>
          <p class="original">Maximum number of results to return</p>
<p class="translation">結果の最大数</p>
        </dd>
      
        <dt>
          <span class="name">fields</span>
          <span class="type"><a href="#fieldspecifiers">Mongo Field Specifier</a></span>
        </dt>
        <dd>
          <p class="original">Dictionary of fields to return or exclude.</p>
<p class="translation">取得する or 除外するフィールド</p>
        </dd>
      
    </dl>
  

  
</div>


<p class="original">The <code>find</code> method is similar to <code>findOne</code>, but instead of returning a
single document it returns a MongoDB <em>cursor</em>. A cursor is a special
object that represents a list of documents that might be returned from a
query. You can pass a cursor into a template helper anywhere you could
pass an array:</p>
<p class="translation"><code>find</code>メソッドは<code>findOne</code>と似ていますが、一つのドキュメントの代わりに、MongoDB<em>カーソル</em>を返します。カーソルは、クエリから返される可能性があるドキュメントのリストを表す特別なオブジェクトです。テンプレートヘルパーの中で配列を渡すことができる場所ならどこでもカーソルを渡すことができます:</p>

<pre><code class="hljs javascript">Template.blog.helpers({
  posts: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// this helper returns a cursor of</span>
    <span class="hljs-comment">// all of the posts in the collection</span>
    <span class="hljs-keyword">return</span> Posts.find();
  }
});
</code></pre>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a template that renders multiple posts --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;blog&quot;</span>&gt;</span>
  {{#each posts}}
    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{{content}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  {{/each}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p class="original">When you want to retrieve the current list of documents from a cursor,
call the cursor&apos;s <code>.fetch()</code> method:</p>
<p class="translation">カーソルからドキュメントのリストを取り出すには、カーソルの<code>.fetch()</code>メソッドを呼び出します:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// get an array of posts</span>
<span class="hljs-keyword">var</span> postsArray = Posts.find().fetch();
</code></pre>

<p class="original">Keep in mind that while the computation in which you call <code>fetch</code> will rerun
when the data changes, the resulting array will not be reactive if it is
passed somewhere else.</p>
<p class="translation">注意すべきは、データが更新されたときに<code>fetch</code>自体の計算は再実行されますが、その結果の配列はリアクティブではないため別のところに渡した場合は更新されなくなる点です。</p>

<p class="original">You can modify the data stored in a <code>Mongo.Collection</code> by calling <code>insert</code>,
<code>update</code>, or <code>remove</code>.</p>
<p class="translation"><code>Mongo.Collection</code>の中に保存されたデータは<code>insert</code>や<code>update</code>、<code>remove</code>を呼ぶことで変更できます。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-insert" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-insert"><em>collection</em>.insert(doc, [callback])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Insert a document in the collection.  Returns its unique _id.</p>
<p class="translation">コレクションにドキュメントを挿入します。そして一意の_idを返します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">doc</span>
          <span class="type">Object</span>
        </dt>
        <dd>
          <p class="original">The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.</p>
<p class="translation">挿入するドキュメント。_id属性が持っていない場合、Meteorは_idを生成します。</p>
        </dd>
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.</p>
<p class="translation">オプション。存在した場合、コールバック関数の第１引数にエラーオブジェクトを渡します。もしエラーがなければ、_idを第２引数に渡します。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">Here&apos;s how you insert a document into a collection:</p>
<p class="translation">コレクションにドキュメントを挿入する方法は次の通りです:</p>

<pre><code class="hljs css"><span class="hljs-tag">Posts</span><span class="hljs-class">.insert</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">createdBy</span>:<span class="hljs-value"> Meteor.<span class="hljs-function">userId</span>(),
  createdAt: new <span class="hljs-function">Date</span>(),
  title: <span class="hljs-string">&quot;My first post!&quot;</span>,
  content: <span class="hljs-string">&quot;Today was a good day.&quot;</span>
</span></span></span>});
</code></pre>

<p class="original">Every document in every <code>Mongo.Collection</code> has an <code>_id</code> field. It must be
unique, and is automatically generated if you don&apos;t provide one. The <code>_id</code>
field can be used to retrieve a specific document using
<a href="#findOne"><code>collection.findOne</code></a>.</p>
<p class="translation">すべての<code>Mongo.Collection</code>のすべてのドキュメントは、_idフィールドを持っています。それは一意であり、<code>_id</code>を指定しなかった時は自動的に生成されます。<code>_id</code>フィールドは<a href="#findOne"><code>collection.findOne</code></a>で特定のドキュメントを取得するために使用できます。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-update" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-update"><em>collection</em>.update(selector, modifier, [options], [callback])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Modify one or more documents in the collection. Returns the number of affected documents.</p>
<p class="translation">コレクション内の1つまたは複数のドキュメントを修正します。影響を与えたドキュメントの数を返します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p class="original">Specifies which documents to modify</p>
<p class="translation">修正したいドキュメントの指定します</p>
        </dd>
      
        <dt>
          <span class="name">modifier</span>
          <span class="type"><a href="#modifiers">Mongo Modifier</a></span>
        </dt>
        <dd>
          <p class="original">Specifies how to modify the documents</p>
<p class="translation">ドキュメントをどのように修正するかを指定します</p>
        </dd>
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</p>
<p class="translation">オプション。存在する場合、コールバック関数の第１引数にエラーオブジェクトが渡されます。もしエラーがなければ、影響を与えたドキュメントの数を第２引数に渡します。</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">multi</span>
          <span class="type">Boolean</span>
        </dt>
        <dd>
          <p class="original">True to modify all matching documents; false to only modify one of the matching documents (the default).</p>
<p class="translation">trueならselectorマッチするドキュメントをすべて修正します。falseならマッチするドキュメントの一つを修正します(デフォルト)。</p>
        </dd>
      
        <dt>
          <span class="name">upsert</span>
          <span class="type">Boolean</span>
        </dt>
        <dd>
          <p class="original">True to insert a document if no matching documents are found.</p>
<p class="translation">trueならマッチするドキュメントが見つからなかった場合にドキュメントを新たに挿入します。</p>
        </dd>
      
    </dl>
  

  
</div>


<p class="original">The selector here is just like the one you would pass to <code>find</code>, and can
match multiple documents. The modifier is an object that specifies which
changes should be made to the matched documents. Watch out - unless you use
an operator like <code>$set</code>, <code>update</code> will simply replace the entire matched
document with the modifier.</p>
<p class="translation">selectorは<code>find</code>メソッドに渡すのと同じようなもので、複数のドキュメントにマッチします。modifierはマッチしたドキュメントをどのように修正するかを記述したオブジェクトです。注:modifierで<code>$set</code>オペレーターを指定しない場合、<code>update</code>はマッチしたドキュメントをmodifierとまるごと交換します。</p>

<p class="original">Here&apos;s an example of setting the <code>content</code> field on all posts whose titles
contain the word &quot;first&quot;:</p>
<p class="translation">ここで、タイトルに&quot;first&quot;を含むすべてのpostsに、contentフィールドをセットする例を示します:</p>

<pre><code class="hljs css"><span class="hljs-tag">Posts</span><span class="hljs-class">.update</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">title</span>:<span class="hljs-value"> {$regex: /first/</span></span></span>}
}, <span class="hljs-rules">{
  <span class="hljs-rule">$<span class="hljs-attribute">set</span>:<span class="hljs-value"> {content: <span class="hljs-string">&quot;Tomorrow will be a great day.&quot;</span></span></span></span>}
});
</code></pre>

<p class="original">You can read about all of the different operators that are supported in the
<a href="http://docs.mongodb.org/manual/reference/operator/update/">MongoDB documentation</a>.</p>
<p class="translation">updateの各オペレーターについては<a href="http://docs.mongodb.org/manual/reference/operator/update/">MongoDB documentation</a>で知ることができます。</p>

<p class="original">There&apos;s one catch: when you call <code>update</code> on the client, you can only find
documents by their <code>_id</code> field. To use all of the possible selectors, you
must call <code>update</code> in server code or from a <a href="#meteor_methods">method</a>.</p>
<p class="translation">注:クライアント上でupdateを呼び出した場合、_idフィールドでのみドキュメントを見つけることができます。セレクタに他のものを使用する場合は、サーバーコードか<a href="#meteor_methods">method</a>経由でupdateを呼び出す必要があります。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-remove" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-remove"><em>collection</em>.remove(selector, [callback])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Remove documents from the collection</p>
<p class="translation">コレクションからドキュメントを削除します</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p class="original">Specifies which documents to remove</p>
<p class="translation">削除するドキュメントを指定します</p>
        </dd>
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Optional.  If present, called with an error object as its argument.</p>
<p class="translation">オプション。もし存在する場合、引数にエラーオブジェクトが渡されたコールバック関数が呼ばれます。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">This method uses the same selectors as <code>find</code> and <code>update</code>, and removes
any documents that match the selector from the database. Use <code>remove</code>
carefully — there&apos;s no way to get that data back.</p>
<p class="translation">このメソッドは<code>find</code>や<code>update</code>と同じセレクタが使用でき、セレクタにマッチしたドキュメントをデータベースから取り除きます。<code>remove</code>を使用するときは気をつけて下さい — 削除されたデータを再び取得する方法はありません。</p>

<p class="original">As with <code>update</code>, client code can only remove documents by <code>_id</code>, whereas
server code and <a href="#meteor_methods">methods</a> can remove documents using any
selector.</p>
<p class="translation"><code>update</code>と同様に、クライアントコードでは<code>_id</code>でのみドキュメントを削除できます。一方で、サーバーコードや<a href="#meteor_methods">methods</a>であれば他のセレクタを使用してドキュメントを削除することができます。</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-allow" class="api-title">
    <div class="locus">
      Server
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-allow"><em>collection</em>.allow(options)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Allow users to write directly to this collection from client code, subject to limitations you define.</p>
<p class="translation">クライアントコードからこのコレクションに直接書き込みできるユーザの制限を定義します。</p>
  </div>

  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">insert, update, remove</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Functions that look at a proposed modification to the database and return true if it should be allowed.</p>
<p class="translation">データベースへの変更の提案を見て、許可すべきなら、trueを返す関数です。</p>
        </dd>
      
    </dl>
  

  
</div>


<p class="original">In newly created apps, Meteor allows almost any calls to <code>insert</code>, <code>update</code>, and
<code>remove</code> from any client or server code. This is because apps started with
<code>meteor create</code> include the <code>insecure</code> package by default to simplify
development. Obviously, if any user could change the database whenever they
wanted it would be bad for security, so it is important to remove the
<code>insecure</code> package and specify some permissions rules, in your terminal:</p>
<p class="translation">新しく作成されたアプリでは、Meteorはクライアントまたはサーバーコードからのほとんどの<code>insert</code>、<code>update</code>、<code>remove</code>の呼び出しを許可します。これは<code>meteor create</code>で始めたアプリには、デフォルトでシンプルに開発を行うための<code>insecure</code>パッケージが含まれているためです。当然ながら、誰もがどんな時にもデータベースを変更できるというのはセキュリティ的に良くありません。そこで、<code>insecure</code>パッケージを取り除き、いくつかのアクセス許可ルールを指定することが重要です。ターミナルで:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> remove insecure
</code></pre>

<p class="original">Once you have removed the <code>insecure</code> package, use the <code>allow</code> and <code>deny</code>
methods to control who can perform which operations on the database. By
default, all operations on the client are denied, so we need to add some
<code>allow</code> rules.  Keep in mind that server code and code inside
<a href="#meteor_methods">methods</a> are not affected by <code>allow</code> and <code>deny</code> —
these rules only apply when <code>insert</code>, <code>update</code>, and <code>remove</code> are called
from untrusted client code.</p>
<p class="translation">一度<code>insecure</code>を取り除いたら、データベース操作を行えるユーザーをコントロールするために<code>allow</code>と<code>deny</code>メソッドを使用します。デフォルトでは、クライアント上でのすべての操作は拒否されるため、いくつかの許可ルールの追加が必要です。注意すべきは、サーバーコードと<a href="#meteor_methods">methods</a>のコード内では、<code>allow</code>と<code>deny</code>は影響を与えない点です — これらのルールは、信頼されないクライアントコードからの<code>insert</code>、<code>update</code>、<code>remove</code>にのみ適用されます。</p>

<p class="original">For example, we might say that users can only create new posts if the
<code>createdBy</code> field matches the ID of the current user, so that users can&apos;t
impersonate each other.</p>
<p class="translation">たとえば、現在のユーザーのIDと<code>createdBy</code>フィールドがマッチする場合のみ新しい記事を作成できるようにすると、他のユーザーがなりすましできなくなるでしょう。</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// In a file loaded on the server (ignored on the client)</span>
Posts.allow({
  insert: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, post)</span> </span>{
    <span class="hljs-comment">// can only create posts where you are the author</span>
    <span class="hljs-keyword">return</span> post.createdBy === userId;
  },
  remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, post)</span> </span>{
    <span class="hljs-comment">// can only delete your own posts</span>
    <span class="hljs-keyword">return</span> post.createdBy === userId;
  }
  <span class="hljs-comment">// since there is no update field, all updates</span>
  <span class="hljs-comment">// are automatically denied</span>
});
</code></pre>

<p class="original">The <code>allow</code> method accepts three possible callbacks: <code>insert</code>, <code>remove</code>,
and <code>update</code>. The first argument to all three callbacks is the <code>_id</code> of
the logged in user, and the remaining arguments are as follows:</p>
<p class="translation"><code>allow</code>メソッドは次の3つのコールバックを受け付けます: <code>insert</code>と<code>remove</code>と<code>update</code>。すべてのコールバックの第１引数には現在ログインしているユーザの<code>_id</code>が渡されます。残りの引数は次の通りです:</p>

<ol>
<li><p><code>insert(userId, document)</code></p>

<p class="original"><code>document</code> is the document that is about to be inserted into the database.
Return <code>true</code> if the insert should be allowed, <code>false</code> otherwise.</p>
<p class="translation"><code>document</code>はデータベースに挿入されようとしているドキュメントです。もし挿入を許可すべきなら<code>true</code>を返し、そうでなければ<code>false</code>を返します。</p></li>
<li><p><code>update(userId, document, fieldNames, modifier)</code></p>

<p class="original"><code>document</code> is the document that is about to be modified. <code>fieldNames</code> is an
array of top-level fields that are affected by this change. <code>modifier</code> is
the <a href="#mongo_modifiers">Mongo Modifier</a> that was passed as the second
argument of <code>collection.update</code>. It can be difficult to achieve correct
validation using this callback, so it is recommended to use
<a href="#meteor_methods">methods</a> instead. Return <code>true</code> if the update should be
allowed, <code>false</code> otherwise.</p>
<p class="translation"><code>document</code>は変更されようとしているドキュメントです。<code>fieldNames</code>はこの変更によって影響を受ける最上位フィールドの配列です。<code>modifier</code>は<code>collection.update</code>の第２引数に渡された<a href="#mongo_modifiers">Mongo Modifier</a>です。このコールバックを使用して正しい検証を行うのは難しいため、その場合は<a href="#meteor_methods">methods</a>を代わりに使用することをおすすめします。更新を許可すべきなら<code>true</code>を返し、そうでなければ<code>false</code>を返します。</p></li>
<li><p><code>remove(userId, document)</code></p>

<p class="original"><code>document</code> is the document that is about to be removed from the database.
Return <code>true</code> if the document should be removed, <code>false</code> otherwise.</p>
<p class="translation"><code>document</code>はデータベースから削除されようとしているドキュメントです。削除を許可すべきなら<code>true</code>を返し、そうでなければ<code>false</code>を返します。</p></li>
</ol>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-deny" class="api-title">
    <div class="locus">
      Server
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-deny"><em>collection</em>.deny(options)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Override <code>allow</code> rules.</p>
<p class="translation"><code>allow</code>ルールを上書きします。</p>
  </div>

  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">insert, update, remove</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Functions that look at a proposed modification to the database and return true if it should be denied, even if an <a href="#allow">allow</a> rule says otherwise.</p>
<p class="translation">データベースへの変更の提案を見て、拒否すべきなら、trueを返す関数です。<a href="#allow">allow</a>ルールで許可していても、denyルールで上書きされます</p>
        </dd>
      
    </dl>
  

  
</div>


<p class="original">The <code>deny</code> method lets you selectively override your <code>allow</code> rules. While
only one of your <code>allow</code> callbacks has to return true to allow a
modification, <em>every one</em> of your <code>deny</code> callbacks has to return false for
the database change to happen.</p>
<p class="translation"><code>deny</code>メソッドを使用して、<code>allow</code>ルールを選択的に上書きできます。<code>allow</code>コールバックのいずれかがtrueを返し、<em>全ての</em><code>deny</code>コールバックがfalseを返すことでデータベースの変更が許可されます。</p>

<p class="original">For example, if we wanted to override part of our <code>allow</code> rule above to exclude
certain post titles:</p>
<p class="translation">たとえば、前にでてきた<code>allow</code>ルールを上書きして、特定のタイトルの記事を除外したい場合は、以下のように記述します:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// In a file loaded on the server (ignored on the client)</span>
Posts.deny({
  insert: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, post)</span> </span>{
    <span class="hljs-comment">// Don&apos;t allow posts with a certain title</span>
    <span class="hljs-keyword">return</span> post.title === <span class="hljs-string">&quot;First!&quot;</span>;
  }
});
</code></pre>
<h2 id="/basic/accounts"><span>Accounts</span></h2>

<p class="original">To get accounts functionality, add one or more of the following packages to
your app with <code>meteor add</code>:</p>
<p class="translation">アカウント機能を使うには、下記のパッケージをひとつ以上追加する必要があります。<code>meteor add</code>コマンドを使います:</p>

<ul>
<li class="original"><code>accounts-ui</code>: This package allows you to use
<code>{{&gt; loginButtons}}</code> in your templates to add an automatically
generated UI that will let users log into your app. There are several
community alternatives to this package that change the appearance, or you
can not use it and use the <a href="#accounts">advanced Accounts methods</a> instead.</li>
<li class="translation"><code>accounts-ui</code>: このパッケージはテンプレートで<code>{{&gt; loginButtons}}</code>を使えるようにするもので、アプリのログイン機能のUIが自動で生成されまます。これ以外にも複数のコミュニティパッケージがあり、表示スタイルを変更することができます。また、これらを使わなくても<a href="#accounts">advanced Accounts methods</a>のAPIを直接使うこともできます。</li>
<li class="original"><code>accounts-password</code>: This package will allow users to log in with passwords.
When you add it the <code>loginButtons</code> dropdown will automatically gain email
and password fields.</li>
<li class="translation"><code>accounts-password</code>: このパッケージはユーザがパスワードでログインできるようにするものです。このパッケージを追加すると、<code>loginButtons</code>のドロップダウンに自動でemailとパスワードのフィールドが追加されます。</li>
<li class="original"><code>accounts-facebook</code>, <code>accounts-google</code>, <code>accounts-github</code>, <code>accounts-twitter</code>,
and community packages for other services will allow your users to log
in with their accounts from other websites. These will automatically add
buttons to the <code>loginButtons</code> dropdown.</li>
<li class="translation"><code>accounts-facebook</code>や<code>accounts-google</code>や<code>accounts-github</code>や<code>accounts-twitter</code>や、その他サービス向けのコミュニティパッケージは、ユーザが他のサイトのアカウントでログインできるようにするものです。自動で<code>loginButtons</code>のドロップダウンにログイン用のボタンが追加されます。</li>
</ul>

<h3 id="/basic/loginButtons" class="api-title">
  <a class="name selflink" href="#b-loginButtons">{{&gt; loginButtons}}</a>
  <span class="locus">Client</span>
</h3>

<p class="original">Include the <code>loginButtons</code> template somewhere in your HTML to use Meteor&apos;s
default UI for logging in. To use this, you need to add the <code>accounts-ui</code> package,
in your terminal:</p>
<p class="translation"><code>loginButtons</code>のテンプレートをHTMLのどこかに設置すると、MeteorのデフォルトのログインUIが使えます。これを使うには、次のように<code>accounts-ui</code>パッケージを追加する必要があります:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> add accounts-ui
</code></pre>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-user" class="api-title">
    <div class="locus">
      Anywhere but publish functions
    </div>

    <a class="name selflink" href="#/basic/Meteor-user">Meteor.user()</a>

    
  </h3>

  <div class="desc">
    <p class="original">Get the current user record, or <code>null</code> if no user is logged in. A reactive data source.</p>
<p class="translation">現在ログイン中のユーザデータを返します。ログインしていない場合は、<code>null</code>が返ります。これはリアクティブデータです。</p>
  </div>

  

  

  
</div>


<p class="original">Get the logged in user from the <a href="#meteor_users"><code>Meteor.users</code></a> collection.
Equivalent to <code>Meteor.users.findOne(Meteor.userId())</code>.</p>
<p class="translation"><a href="#meteor_users"><code>Meteor.users</code></a>コレクションからログインユーザのデータを取得します。<code>Meteor.users.findOne(Meteor.userId())</code>と同等です。</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-userId" class="api-title">
    <div class="locus">
      Anywhere but publish functions
    </div>

    <a class="name selflink" href="#/basic/Meteor-userId">Meteor.userId()</a>

    
  </h3>

  <div class="desc">
    <p class="original">Get the current user id, or <code>null</code> if no user is logged in. A reactive data source.</p>
<p class="translation">現在ログイン中のユーザIDを返します。ログインしていない場合は、<code>null</code>が返ります。これはリアクティブデータです。</p>
  </div>

  

  

  
</div>



<div class="api new-api-box">
  <h3 id="/basic/Meteor-users" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-users">Meteor.users</a>

    
  </h3>

  <div class="desc">
    <p class="original">A <a href="#collections">Mongo.Collection</a> containing user documents.</p>
<p class="translation">すべてのユーザデータを含む<a href="#collections">Mongo.Collection</a>です。</p>
  </div>

  

  

  
</div>


<p class="original">This collection contains one document per registered user. Here&apos;s an example
user document:</p>
<p class="translation">このコレクションは一人のユーザにつき一つのドキュメント(データ)を持ちます。下記がユーザドキュメントの一例です:</p>

<pre><code class="hljs objectivec">{
  _<span class="hljs-keyword">id</span>: <span class="hljs-string">&quot;bbca5d6a-2156-41c4-89da-0329e8c99a4f&quot;</span>,  <span class="hljs-comment">// Meteor.userId()</span>
  username: <span class="hljs-string">&quot;cool_kid_13&quot;</span>, <span class="hljs-comment">// unique name</span>
  emails: [
    <span class="hljs-comment">// each email address can only belong to one user.</span>
    { address: <span class="hljs-string">&quot;cool@example.com&quot;</span>, verified: <span class="hljs-literal">true</span> },
    { address: <span class="hljs-string">&quot;another@different.com&quot;</span>, verified: <span class="hljs-literal">false</span> }
  ],
  createdAt: Wed Aug <span class="hljs-number">21</span> <span class="hljs-number">2013</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">52</span> GMT-<span class="hljs-number">0700</span> (PDT),
  profile: {
    <span class="hljs-comment">// The profile is writable by the user by default.</span>
    name: <span class="hljs-string">&quot;Joe Schmoe&quot;</span>
  },
  services: {
    facebook: {
      <span class="hljs-keyword">id</span>: <span class="hljs-string">&quot;709050&quot;</span>, <span class="hljs-comment">// facebook id</span>
      accessToken: <span class="hljs-string">&quot;AAACCgdX7G2...AbV9AZDZD&quot;</span>
    },
    resume: {
      loginTokens: [
        { token: <span class="hljs-string">&quot;97e8c205-c7e4-47c9-9bea-8e2ccc0694cd&quot;</span>,
          when: <span class="hljs-number">1349761684048</span> }
      ]
    }
  }
}
</code></pre>

<p class="original">A user document can contain any data you want to store about a user. Meteor
treats the following fields specially:</p>
<p class="translation">ユーザドキュメントには開発者が任意のデータを格納することができます。Meteorは下記のフィールドを特殊フィールドとして扱います。:</p>

<ul>
<li class="original"><code>username</code>: a unique String identifying the user.</li>
<li class="translation"><code>username</code>: ユーザを識別するユニークな文字列。</li>
<li class="original"><code>emails</code>: an Array of Objects with keys <code>address</code> and <code>verified</code>;
an email address may belong to at most one user. <code>verified</code> is
a Boolean which is true if the user has <a href="#accounts_verifyemail">verified the
address</a> with a token sent over email.</li>
<li class="translation"><code>emails</code>: オブジェクトの配列で、オブジェクトは<code>address</code>と<code>verified</code>というプロパティを持つ。emailアドレスは一人のユーザに固有である必要がある。<code>verified</code>はBooleanで、ユーザがメールで遅られたトークンで認証して<a href="#accounts_verifyemail">verified the address</a>となった場合にtrueとなる。</li>
<li class="original"><code>createdAt</code>: the Date at which the user document was created.</li>
<li class="translation"><code>createdAt</code>: ユーザドキュメントが作成された日時。</li>
<li class="original"><code>profile</code>: an Object which (by default) the user can create
and update with any data.</li>
<li class="translation"><code>profile</code>: (デフォルトでは)ユーザが任意のデータを作成したり更新したりできるオブジェクト。</li>
<li class="original"><code>services</code>: an Object containing data used by particular
login services. For example, its <code>reset</code> field contains
tokens used by <a href="#accounts_forgotpassword">forgot password</a> links,
and its <code>resume</code> field contains tokens used to keep you
logged in between sessions.</li>
<li class="translation"><code>services</code>: 個別のログインサービスがデータを格納するオブジェクト。例えば、その<code>reset</code>フィールドは<a href="#accounts_forgotpassword">forgot password</a>のリンクで使われるトークンを保持する、また、<code>resume</code>フィールドはセッションを横断してログイン状態を維持するためのトークンを保持する。</li>
</ul>

<p class="original">Like all <a href="#collections">Mongo.Collection</a>s, you can access all
documents on the server, but only those specifically published by the server are
available on the client.</p>
<p class="translation">他のすべての<a href="#collections">Mongo.Collection</a>と同じように、サーバにおいてはすべてのドキュメントにアクセスできる。しかし、クライアントにおいては明示的にpublishされたものしかアクセスできない。</p>

<p class="original">By default, the current user&apos;s <code>username</code>, <code>emails</code> and <code>profile</code> are
published to the client. You can publish additional fields for the
current user with:</p>
<p class="translation">デフォルトでは、現在のユーザの<code>username</code>と<code>emails</code>と<code>profile</code>はpublishされクライアントからアクセスできる。それ以外のフィールドを現在のユーザにpublishするには次のようにする:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// server</span>
Meteor.publish(<span class="hljs-string">&quot;userData&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.userId) {
    <span class="hljs-keyword">return</span> Meteor.users.find({_id: <span class="hljs-keyword">this</span>.userId},
                             {fields: {<span class="hljs-string">&apos;other&apos;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&apos;things&apos;</span>: <span class="hljs-number">1</span>}});
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.ready();
  }
});

<span class="hljs-comment">// client</span>
Meteor.subscribe(<span class="hljs-string">&quot;userData&quot;</span>);
</code></pre>

<p class="original">If the autopublish package is installed, information about all users
on the system is published to all clients. This includes <code>username</code>,
<code>profile</code>, and any fields in <code>services</code> that are meant to be public
(eg <code>services.facebook.id</code>,
<code>services.twitter.screenName</code>). Additionally, when using autopublish
more information is published for the currently logged in user,
including access tokens. This allows making API calls directly from
the client for services that allow this.</p>
<p class="translation">autopublishパッケージがインストールされている状態ではシステム上のすべてのユーザの情報がすべてのクライアントにpublishされる。これは、<code>username</code>と<code>profile</code>と<code>services</code>内の公開フィールド(例:<code>services.facebook.id</code>と<code>services.twitter.screenName</code>)が含まれる。これに加えて、autopublishパッケージを使った場合は、現在ログインしているユーザにはアクセストークンなどさらに情報がpublishされる。これにより、許可されていれば、クライアントからサービスに直接API呼び出しができるようになる。</p>

<p class="original">Users are by default allowed to specify their own <code>profile</code> field with
<a href="#accounts_createuser"><code>Accounts.createUser</code></a> and modify it with
<code>Meteor.users.update</code>. To allow users to edit additional fields, use
<a href="#allow"><code>Meteor.users.allow</code></a>. To forbid users from making any modifications to
their user document:</p>
<p class="translation">デフォルトではユーザは自分で<code>profile</code>フィールドを設定したり修正したりするこができる。設定は<a href="#accounts_createuser"><code>Accounts.createUser</code></a>を使い、修正は<code>Meteor.users.update</code>を使う。ユーザに他のフィールドも追加で編集させるには、<a href="#allow"><code>Meteor.users.allow</code></a>を使う。逆にユーザにドキュメントをまったく修正させないようにするには、次のようにする:</p>

<pre><code class="hljs javascript">Meteor.users.deny({update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }});
</code></pre>


<div class="api new-api-box">
  <h3 id="/basic/currentUser" class="api-title">
    <div class="locus">
      
    </div>

    <a class="name selflink" href="#/basic/currentUser">{{ currentUser  }}</a>

    
  </h3>

  <div class="desc">
    <p class="original">Calls <a href="#meteor_user">Meteor.user()</a>. Use <code>{{#if currentUser}}</code> to check whether the user is logged in.</p>
<p class="translation"><a href="#meteor_user">Meteor.user()</a>を呼び出す。ユーザがログインしていがかだけをチェックする場合は、<code>{{#if currentUser}}</code>を使う。</p>
  </div>

  

  

  
</div>

<h2 id="/basic/methods"><span>Methods</span></h2>

<p class="original">Methods are server functions that can be called from the client. They are
useful in situations where you want to do something more complicated than
<code>insert</code>, <code>update</code> or <code>remove</code>, or when you need to do data validation that
is difficult to achieve with just <code>allow</code> and <code>deny</code>.</p>
<p class="translation">Methods(メソッド)はクライアントから呼ばれるサーバー関数です. これらは、<code>insert</code>、<code>update</code>や<code>remove</code>よりもっと複雑に何かをしたい状況や、<code>allow</code>と<code>deny</code>だけでは難しいデータバリデーションが必要な状況で便利なものです。</p>

<p class="original">Methods can return values and throw errors.</p>
<p class="translation">Methods(メソッド)は戻り値とエラーを返します。</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-methods" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-methods">Meteor.methods(methods)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Defines functions that can be invoked over the network by clients.</p>
<p class="translation">クライアントによってネットワーク越しに呼び出される関数を定義します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">methods</span>
          <span class="type">Object</span>
        </dt>
        <dd>
          <p class="original">Dictionary whose keys are method names and values are functions.</p>
<p class="translation">辞書のキーはメソッド名で、バリューは関数です。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">Calling <code>Meteor.methods</code> on the server defines functions that can be
called remotely by clients. Here&apos;s an example of a method that checks its
arguments and throws an error:</p>
<p class="translation">サーバー上での<code>Meteor.methods</code>の呼び出しは、クライアント側からリモートで呼び出すことのできる関数を定義します。ここでは、引数のチェックとエラーを返すメソッドの一例を示しています。</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// On the server</span>
Meteor.methods({
  commentOnPost: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(comment, postId)</span> </span>{
    <span class="hljs-comment">// Check argument types</span>
    check(comment, <span class="hljs-built_in">String</span>);
    check(postId, <span class="hljs-built_in">String</span>);

    <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">this</span>.userId) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">&quot;not-logged-in&quot;</span>,
        <span class="hljs-string">&quot;Must be logged in to post a comment.&quot;</span>);
    }

    <span class="hljs-comment">// ... do stuff ...</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;
  },

  otherMethod: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ... do other stuff ...</span>
  }
});
</code></pre>

<p class="original">The <a href="#check"><code>check</code></a> function is a convenient way to enforce the expected
<a href="#matchpatterns">types and structure</a> of method arguments.</p>
<p class="translation">ここでの<a href="#check"><code>check</code></a>関数は、期待されるメソッド引数の<a href="#matchpatterns">typesとstructure</a>を強制実行するための一つの便利な方法です。</p>

<p class="original">Inside your method definition, <code>this</code> is bound to a method invocation object,
which has several useful properties, including <code>this.userId</code>, which
identifies the currently logged-in user.</p>
<p class="translation">メソッド定義上で、<code>this</code>はメソッド呼び出しにバインドされたオブジェクトです。<code>this</code>はいくつかの便利なプロパティを持ち、その内の<code>this.userId</code>は現状ログインしているユーザーを確認します。</p>

<p class="original">You don&apos;t have to put all your method definitions into a single <code>Meteor.methods</code>
call; you may call it multiple times, as long as each method has a unique name.</p>
<p class="translation">ひとつの<code>Meteor.methods</code>呼び出しにメソッド定義全てを置く必要はありません。ユニークな名前を各メソッドが持つ限り、あなたはこれを複数回呼び出すでしょう。</p>

<h3 id="/basic/latencycompensation">Latency Compensation</h3>

<p class="original">Calling a method on the server requires a round-trip over the network. It would
be really frustrating if users had to wait a whole second to see their comment
show up due to this delay. That&apos;s why Meteor has a feature called <em>method
stubs</em>. If you define a method on the client with the same name as a server
method, Meteor will run it to attempt to predict the outcome of the server
method. When the code on the server actually finishes, the prediction generated
on the client will be replaced with the actual outcome of the server method.</p>
<p class="translation">サーバー上でのメソッド呼び出しは、ネットワーク越しに往復が必要になります。例えば、このネットワークの往復によるディレイによって、ユーザーがコメントを表示させるのに数秒間待たなくてはならないのは非常にストレスになります。なぜならMeteorは<em>method stubs</em>という特徴を持っているからです。もし、あなたがクライアント上で一つのメソッドを一つのサーバーメソッドとして同じ名前で定義した場合、Meteorはサーバーメソッドからの結果を予測して試みる為に実行します。実際にサーバー上でコードが終了すると、クライアント上で生成されたその予測はサーバーメソッドの実際の結果に置き換えられます。</p>

<p class="original">The client versions of <a href="#insert"><code>insert</code></a>, <a href="#update"><code>update</code></a>, and
<a href="#remove"><code>remove</code></a>, which are implemented as methods, use this feature to make
client-side interactions with the database appear instant.</p>
<p class="translation">メソッドとして実装されたクライアント版の<a href="#insert"><code>insert</code></a>や<a href="#update"><code>update</code></a>や<a href="#remove"><code>remove</code></a>は、クライアント側のインタラクションとデータベースに即時反映させるためにこの特徴を使います。</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-call" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-call">Meteor.call(name, [arg1, arg2...], [asyncCallback])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Invokes a method passing any number of arguments.</p>
<p class="translation">複数の引数を通して呼び出されます。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">Name of method to invoke</p>
<p class="translation">呼び出すためのメソッド名</p>
        </dd>
      
        <dt>
          <span class="name">arg1, arg2...</span>
          <span class="type"><a href="#ejson">EJSON-able Object</a></span>
        </dt>
        <dd>
          <p class="original">Optional method arguments</p>
<p class="translation">任意のメソッド引数</p>
        </dd>
      
        <dt>
          <span class="name">asyncCallback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).</p>
<p class="translation">任意のコールバック（このメソッド完了後に結果やエラーと非同期的に呼ばれる）。もし引数が設定されてない場合、このメソッドは可能であれば同期的に実行される。（以下参照）</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">This is how you call a method.</p>
<p class="translation">以下は、メソッドの呼び出し方です。</p>

<h3 id="/basic/ontheclient">On the client</h3>

<p class="original">Methods called on the client run asynchronously, so you need to pass a
callback in order to observe the result of the call. The callback will be
called with two arguments, <code>error</code> and <code>result</code>. The <code>error</code> argument will
be <code>null</code> unless an exception was thrown. When an exception is thrown, the
<code>error</code> argument is a <code>Meteor.Error</code> instance and the <code>result</code> argument is
undefined.</p>
<p class="translation">メソッドはクライアント上で非同期的に実行されるので、呼び出し結果を監視するためにコールバックを渡す必要があります。そのコールバックは<code>error</code>と<code>result</code>の２つを引数として持ち、呼びだされます。<code>error</code>引数は、例外が投げられない限り<code>null</code>を返します。例外が投げられた場合、<code>error</code>引数は<code>Meteor.Error</code>インスタンスとなり、<code>result</code>はundefinedとなります。</p>

<p class="original">Here&apos;s an example of calling the <code>commentOnPost</code> method with arguments
<code>comment</code> and <code>postId</code>:</p>
<p class="translation">ここでの例では、<code>commentOnPost</code>メソッドを<code>comment</code>と<code>postId</code>の引数と共に呼び出しています。</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// Asynchronous call with a callback on the client</span>
Meteor.call(<span class="hljs-string">&apos;commentOnPost&apos;</span>, comment, postId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, result)</span> </span>{
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-comment">// handle error</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// examine result</span>
  }
});
</code></pre>

<p class="original">Meteor tracks the database updates performed as part of a method call, and
waits to invoke the client-side callback until all of those updates have
been sent to the client.</p>
<p class="translation">Meteorはメソッド呼び出しの一部として機能したデータベースアップデートを追跡し、クライアントサイドのコールバックを呼び出すためにクライアントへそれら全てのアップデートが送られるまで待ちます。</p>

<h3 id="/basic/ontheserver">On the server</h3>

<p class="original">On the server, you don&apos;t have to pass a callback — the method call
will simply block until the method is complete, returning a result or
throwing an exception, just as if you called the function directly:</p>
<p class="translation">サーバー上では、コールバックを渡す必要はありません（ただ単に直接的に関数を呼び出すと、メソッドが結果や例外を返し完了するまでメソッド呼び出しは単純にブロックします）</p>

<pre><code class="hljs js"><span class="hljs-comment">// Synchronous call on the server with no callback</span>
<span class="hljs-keyword">var</span> result = Meteor.call(<span class="hljs-string">&apos;commentOnPost&apos;</span>, comment, postId);
</code></pre>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-Error" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-Error">new Meteor.Error(error, [reason], [details])</a>

    
  </h3>

  <div class="desc">
    <p class="original">This class represents a symbolic error thrown by a method.</p>
<p class="translation">このクラスは、何かのメソッドによって投げられたシンボリックエラーを表します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">error</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">A string code uniquely identifying this kind of error.
This string should be used by callers of the method to determine the
appropriate action to take, instead of attempting to parse the reason
or details fields. For example:</p>
<p class="translation">文字列はエラーを特定するユニークなものとして表現します。この文字列は、reasonやdetailsをパースしようとする代わりに適切なアクションを決定するためのメソッドの呼び出し元によって使われるべきです。例えば:</p>
<pre class="prettyprint source"><code class="hljs javascript"><span class="hljs-comment">// on the server, pick a code unique to this error</span>
<span class="hljs-comment">// the reason field should be a useful debug message</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">&quot;logged-out&quot;</span>, 
  <span class="hljs-string">&quot;The user must be logged in to post a comment.&quot;</span>);

<span class="hljs-comment">// on the client</span>
Meteor.call(<span class="hljs-string">&quot;methodName&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> </span>{
  <span class="hljs-comment">// identify the error</span>
  <span class="hljs-keyword">if</span> (error &amp;&amp; error.error === <span class="hljs-string">&quot;logged-out&quot;</span>) {
    <span class="hljs-comment">// show a nice error message</span>
    Session.set(<span class="hljs-string">&quot;errorMessage&quot;</span>, <span class="hljs-string">&quot;Please log in to post a comment.&quot;</span>);
  }
});</code></pre><p class="original">For legacy reasons, some built-in Meteor functions such as <code>check</code> throw
errors with a number in this field.</p>
<p class="translation">レガシーな理由のため、いくつかのビルトインなMeteorはエラー処理の順番確認のように機能します。</p>
        </dd>
      
        <dt>
          <span class="name">reason</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">Optional.  A short human-readable summary of the
error, like &apos;Not Found&apos;.</p>
<p class="translation">任意。人間が読んで理解できるエラーの要約。</p>
        </dd>
      
        <dt>
          <span class="name">details</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">Optional.  Additional information about the error,
like a textual stack trace.</p>
<p class="translation">任意。エラーの追加情報。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">If you want to return an error from a method, throw an exception.  Methods can
throw any kind of exception, but <code>Meteor.Error</code> is the only kind of error that
will be sent to the client. If a method function throws a different exception,
the client gets <code>Meteor.Error(500, &apos;Internal server error&apos;)</code>.</p>
<p class="translation">もし、メソッドから何かエラーを返してほしいならば、例外を投げてください。メソッドはいくつかの例外の種類を投げることができますが、<code>Meteor.Error</code>は唯一のクライアントへ送信されるエラーの種類です。もし何かのメソッド関数が異なる例外を投げる場合、クライアントは<code>Meteor.Error(500, &apos;Internal server error&apos;)</code>を受け取ります。</p>
<h2 id="/basic/pubsub"><span>Publish and subscribe</span></h2>

<p class="original">Meteor servers can publish sets of documents with <code>Meteor.publish</code>, and
clients can subscribe to those publications with <code>Meteor.subscribe</code>. Any
documents the client subscribes to will be available through the <code>find</code>
method of client collections.</p>
<p class="translation">Meteorのサーバは、<code>Meteor.publish</code>メソッドによりドキュメントのセットを配信し、クライアントでは<code>Meteor.subscribe</code>メソッドで配信されたドキュメントを購読することができます。購読されたドキュメントは、クライアント側の<code>find</code>メソッドにより利用できるようになります。</p>

<p class="original">By default, every newly created Meteor app contains the <code>autopublish</code>
package, which automatically publishes all available documents to every
client. To exercise finer-grained control over what documents different
clients receive, first remove <code>autopublish</code>, in your terminal:</p>
<p class="translation">デフォルトでは、新規作成されたMeteorアプリケーションには<code>autopublish</code>パッケージが予め同梱されており、全ての利用可能なドキュメントは、全てのクライアントに自動で配信されます。クライアントそれぞれに配信するドキュメントをより細やかに制御したい場合、まずターミナル上で以下のコマンドを入力し、<code>autopublish</code>パッケージを削除しましょう。</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> remove autopublish
</code></pre>

<p class="original">Now you can use <code>Meteor.publish</code> and <code>Meteor.subscribe</code> to control what
documents flow from the server to its clients.</p>
<p class="translation">これで、<code>Meteor.publish</code>と<code>Meteor.subscribe</code>を使って、どのドキュメントをサーバからクライアントへ流すかを制御できるようになります。</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-publish" class="api-title">
    <div class="locus">
      Server
    </div>

    <a class="name selflink" href="#/basic/Meteor-publish">Meteor.publish(name, func)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Publish a record set.</p>
<p class="translation">レコードのセットを配信します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">Name of the record set.  If <code>null</code>, the set has no name, and the record set is automatically sent to all connected clients.</p>
<p class="translation">配信するデータの名称。<code>null</code>がセットされた場合、配信されるデータには名称が設定されず、自動的に接続している全てのクライアントに配信されます。</p>
        </dd>
      
        <dt>
          <span class="name">func</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">Function called on the server each time a client subscribes.  Inside the function, <code>this</code> is the publish handler object, described below.  If the client passed arguments to <code>subscribe</code>, the function is called with the same arguments.</p>
<p class="translation">クライアントから購読されるたびにサーバで実行される関数。関数の処理中で<code>this</code>は、後述する配信を制御するオブジェクトを指し示します。クライアント側で<code>subscribe</code>メソッドの同引数を省略すると、サーバ側と同じ関数が実行されます。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">To publish data to clients, call <code>Meteor.publish</code> on the server with two
arguments: the name of the record set, and a <em>publish function</em> that will
be called each time a client subscribes to this record set.</p>
<p class="translation">クライアントにデータを配信するには、サーバ側で以下の2つの引数をセットして<code>Meteor.publish</code>メソッドを実行します。1つは配信データの名称。もう1つは、クライアント側で配信データへの購読要求が行われるたびに呼び出される<em>配信関数</em>です。</p>

<p class="original">Publish functions typically return the result of calling
<code>collection.find(query)</code> on some <code>collection</code> with a <code>query</code> that narrows
down the set of documents to publish from that collection:</p>
<p class="translation">配信関数では一般的に、配信するドキュメントのセットを<code>collection.find(query)</code>によって絞りこんで取得し返却します。</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// Publish the logged in user&apos;s posts</span>
Meteor.publish(<span class="hljs-string">&quot;posts&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> Posts.find({ createdBy: <span class="hljs-keyword">this</span>.userId });
});
</code></pre>

<p class="original">You can publish documents from multiple collections by returning an array
of <code>collection.find</code> results:</p>
<p class="translation"><code>collection.find</code>の結果を配列として返すことで、複数のコレクションから取得したドキュメントを配信することも可能です。</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// Publish a single post and its comments</span>
Meteor.publish(<span class="hljs-string">&quot;postAndComments&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(postId)</span> </span>{
  <span class="hljs-comment">// Check argument</span>
  check(postId, <span class="hljs-built_in">String</span>);

  <span class="hljs-keyword">return</span> [
    Posts.find({ _id: postId }),
    Comments.find({ postId: roomId })
  ];
});
</code></pre>

<p class="original">Inside the publish function, <code>this.userId</code> is the current logged-in user&apos;s
<code>_id</code>, which can be useful for filtering collections so that certain
documents are visible only to certain users. If the logged-in user changes
for a particular client, the publish function will be automatically rerun
with the new <code>userId</code>, so the new user will not have access to any
documents that were meant only for the previous user.</p>
<p class="translation">配信関数の処理内では、<code>this.userId</code>は現在ログインしているユーザの<code>_id</code>を指し示しており、これは、特定のドキュメントを特定のユーザにのみ表示するよう制限をかけるのに役立ちます。 もし、クライアントのログインユーザが変わると、配信関数は自動的に新しいユーザの<code>userId</code>を元に再実行されるため、新しいユーザは以前のユーザに対してのみ提供されていたドキュメントにはアクセスできなくなります。</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-subscribe" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Meteor-subscribe">Meteor.subscribe(name, [arg1, arg2...], [callbacks])</a>

    
  </h3>

  <div class="desc">
    <p class="original">Subscribe to a record set.  Returns a handle that provides
<code>stop()</code> and <code>ready()</code> methods.</p>
<p class="translation">データの購読登録を行います。返却されるオブジェクトは、<code>stop()</code>メソッドと<code>ready()</code>メソッドを提供します。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p class="original">Name of the subscription.  Matches the name of the
server&apos;s <code>publish()</code> call.</p>
<p class="translation">購読するデータの名称。サーバ側で同じ名称が設定された<code>publish()</code>メソッドが呼び出されます。</p>
        </dd>
      
        <dt>
          <span class="name">arg1, arg2...</span>
          <span class="type">Any</span>
        </dt>
        <dd>
          <p class="original">Optional arguments passed to publisher
function on server.</p>
<p class="translation">サーバ側の配信関数へ受け渡される引数を任意で設定する。</p>
        </dd>
      
        <dt>
          <span class="name">callbacks</span>
          <span class="type">Function or Object</span>
        </dt>
        <dd>
          <p class="original">Optional. May include <code>onStop</code>
and <code>onReady</code> callbacks. If there is an error, it is passed as an
argument to <code>onStop</code>. If a function is passed instead of an object, it
is interpreted as an <code>onReady</code> callback.</p>
<p class="translation">任意で設定可能。<code>onStop</code>メソッドと<code>onReady</code>メソッドを含めることができます。エラーが発生した場合は<code>onStop</code>メソッドの引数となります。オブジェクトの代わりに関数が渡された場合、<code>onReady</code>メソッドのコールバック関数として解釈されます。</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">Clients call <code>Meteor.subscribe</code> to express interest in document
collections published by the server. Clients can further filter these
collections of documents by calling <a href="#find"><code>collection.find(query)</code></a>.
Whenever any data that was accessed by a publish function changes on the
server, the publish function is automatically rerun and the updated
document collections are pushed to the subscribed client.</p>
<p class="translation">クライアント側で<code>Meteor.subscribe</code>メソッドを呼び出すことで、サーバから配信されたドキュメントのコレクションに対する関係性を明示します。クライアント側で<a href="#find"><code>collection.find(query)</code></a>を使うと、ドキュメントのコレクションを更に絞り込んで取得することもできます。サーバ側で配信関数が手に入れたデータに変更があった場合、配信関数は自動的に再実行され、更新されたドキュメントのコレクションは購読中のクライアントへと送り出されます。</p>

<p class="original">The <code>onReady</code> callback is called with no arguments when the server has sent all
of the initial data for the subscription. The <code>onStop</code> callback is when the
subscription is terminated for any reason; it receives a
<a href="#meteor_error"><code>Meteor.Error</code></a> if the subscription failed due to a server-side
error.</p>
<p class="translation"><code>onReady</code>メソッドは、購読の初期化に必要なデータをサーバが送り終えた時に、引数無しで実行されます。<code>onStop</code>メソッドは、何らかの理由で購読が終了した時に実行されます。サーバ側でのエラーなどにより購読に失敗すると、<a href="#meteor_error"><code>Meteor.Error</code></a>を受け取ります。</p>

<p class="original"><code>Meteor.subscribe</code> returns a subscription handle, which is an object with the
following methods:</p>
<p class="translation"><code>Meteor.subscribe</code>メソッドは戻り値として、購読を制御する以下のメソッドを持ったオブジェクトを返します。</p>

<dl class="callbacks">


  
    <dt><span class="name">stop()</span></dt>
  
  <dd><p class="original">Cancel the subscription. This will typically result in the server directing the
client to remove the subscription&apos;s data from the client&apos;s cache.</p>
<p class="translation">購読を中止します。通常 購読を中止すると、キャッシュから購読のためのデータを削除するよう、サーバからクライアントへ命令が出されます。</p></dd>



  
    <dt><span class="name">ready()</span></dt>
  
  <dd><p class="original">Returns true if the server has <a href="#publish_ready">marked the subscription as
ready</a>. A reactive data source.</p>
<p class="translation"><a href="#publish_ready">購読の準備が整った</a>とサーバが判断した場合にTrueが返されます。</p></dd>
</dl>

<p class="original">If you call <code>Meteor.subscribe</code> inside
<a href="#tracker_autorun"><code>Tracker.autorun</code></a>, the subscription will be cancelled
automatically whenever the computation reruns (so that a new subscription
can be created, if appropriate), meaning you don&apos;t have to to call <code>stop</code>
on subscriptions made from inside <code>Tracker.autorun</code>.</p>
<p class="translation"><a href="#tracker_autorun"><code>Tracker.autorun</code></a>メソッドの内部で<code>Tracker.autorun</code>メソッドが呼ばれた場合、処理が再実行されるたび自動的に購読は中止されます。（結果的に、新規の購読は適切な手順で作成することができます。）つまり、<code>Tracker.autorun</code>メソッドの内部で生成された購読を停止させるために<code>stop</code>メソッドを呼び出す必要はないのです。</p>
<h2 id="/basic/environment"><span>Environment</span></h2>

<p>
<div class="api new-api-box">
  <h3 id="/basic/Meteor-isClient" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-isClient">Meteor.isClient</a>

    
  </h3>

  <div class="desc">
    <p class="original">Boolean variable.  True if running in client environment.</p>
<p class="translation">真偽値。クライアント環境の場合Trueになる。</p>
  </div>

  

  

  
</div>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-isServer" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-isServer">Meteor.isServer</a>

    
  </h3>

  <div class="desc">
    <p class="original">Boolean variable.  True if running in server environment.</p>
<p class="translation">真偽値。サーバ環境の場合Trueになる。</p>
  </div>

  

  

  
</div>
</p>

<div class="note">
  <p class="original">
<code>Meteor.isServer</code> can be used to limit where code runs, but it does
not prevent code from being sent to the client. Any sensitive code that you
don&apos;t want served to the client, such as code containing passwords or
authentication mechanisms, should be kept in the <code>server</code> directory.
</p>
<p class="translation"><code>Meteor.isServer</code>はそのコードがどこで動くかを制限することには使えますが、そのコードがクライアント側に送られることは阻止しません。クライアントに送りたくない秘密のコード<code>server</code>に格納すべきです。例えば、パスワードや認証のメカニズムが含まれているコードなどが該当します。</p>
</div>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-startup" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-startup">Meteor.startup(func)</a>

    
  </h3>

  <div class="desc">
    <p class="original">Run code when a client or a server starts.</p>
<p class="translation">クライアントやサーバが起動したときにコードを実行する。</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">func</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p class="original">A function to run on startup.</p>
<p class="translation">起動時に実行する関数</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p class="original">On the server, the callback function will run as soon as the server
process is finished starting up. On the client, the callback function will
run as soon as the page is ready.</p>
<p class="translation">サーバ側ではコールバック関数はサーバ起動完了後すぐに実行されます。クライアント側ではコールバック関数はページが準備完了になった後すぐに実行されます。</p>

<p class="original">It&apos;s good practice to wrap all code that isn&apos;t inside template events,
template helpers, <code>Meteor.methods</code>, <code>Meteor.publish</code>, or
<code>Meteor.subscribe</code> in <code>Meteor.startup</code> so that your application code isn&apos;t
executed before the environment is ready.</p>
<p class="translation">ひとつのよい方法として、テンプレートイベント、テンプレートヘルパー、<code>Meteor.methods</code>、<code>Meteor.publish</code>、<code>Meteor.subscribe</code>以外のすべてのコードを<code>Meteor.startup</code>に入れてしまう方法があります。そうすると、環境が準備される前にコードが実行されてしまうことがなくなります。</p>

<p class="original">For example, to create some initial data if the database is empty when the
server starts up, you might use the following pattern:</p>
<p class="translation">例えば、サーバ起動時にデータベースが空であれば初期データを作成するためには次のようにします:</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (Meteor.isServer) {
  Meteor.startup(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (Rooms.find().count() === <span class="hljs-number">0</span>) {
      Rooms.insert({name: <span class="hljs-string">&quot;Initial room&quot;</span>});
    }
  });
}
</code></pre>

<p class="original">If you call <code>Meteor.startup</code> on the server after the server process has
started up, or on the client after the page is ready, the callback will
fire immediately. <!-- XXX It should still fire asynchronously, though --></p>
<p class="translation">サーバ起動後やクライアント起動後に<code>Meteor.startup</code>を呼び出した場合はコールバック関数はすぐに実行されます。<!-- XXX ただし非同期に実行されます。 --></p><p></p>
  <h2 id="/basic/packages"><span>Packages</span></h2>

<p class="original">All of Meteor&apos;s functionality is implemented in modular packages. In addition
to the core packages documented above, there are many others that you can add to
your app to enable useful functionality.</p>
<p class="translation">Meteorの機能のすべては、モジュラーパッケージとして実装されています。上記で説明したコアパッケージに加え、他の多くのパッケージを便利な機能を有効にするために追加することができます。</p>

<p class="original">From the command line, you can add and remove packages with <code>meteor add</code>
and <code>meteor remove</code>:</p>
<p class="translation">コマンドラインで、<code>meteor add</code>や<code>meteor remove</code>を実行するとパッケージの追加や削除ができます:</p>

<pre><code class="hljs bash"><span class="hljs-comment"># add the less package</span>
meteor add less

<span class="hljs-comment"># remove the less package</span>
meteor remove less
</code></pre>

<p class="original">Your app will restart itself automatically when you add or remove a
package.  An app&apos;s package dependencies are tracked in <code>.meteor/packages</code>,
so your collaborators will be automatically updated to the same set of
installed packages as you after they pull your source code, because they
have the same <code>.meteor/packages</code> file as you.</p>
<p class="translation">パッケージを追加または削除すると、自動的にアプリがリロードされます。アプリのパッケージは<code>.meteor/packages</code>の中で追跡されており、あなたと同じ<code>.meteor/packages</code>ファイルを使用しているコラボレーターは、ソースコードをプルした後に自動的にあなたがインストールしたパッケージと同じセットに更新されます。</p>

<p class="original">You can see which packages are used by your app by running <code>meteor list</code>
in the app&apos;s directory.</p>
<p class="translation">アプリディレクトリ内で<code>meteor list</code>コマンドを実行すると、あなたのアプリがどのパッケージを使用しているか確認できます。</p>

<h2 id="/basic/searchingforpackages">Searching for packages</h2>

<p>Currently the best way to search for packages available from the official
Meteor package server is <a href="https://atmospherejs.com/?__hstc=256467284.06c0d3fa064611691d66d2c578e27182.1445920650574.1445920650574.1445920650574.1&amp;__hssc=256467284.1.1445920650574&amp;__hsfp=1614345591">Atmosphere</a>, the
community package search website maintained by Percolate Studio. You can
also search for packages directly using the <code>meteor search</code> command.</p>

<p class="original">Packages that have a <code>:</code> in the name, such as <code>mquandalle:jade</code>, are written and
maintained by community members. The prefix before the colon is the name of the
user or organization who created that package. Unprefixed packages are
maintained by Meteor Development Group as part of the Meteor framework.</p>
<p class="translation">パッケージ名はコロン区切りで記載され、コロンの前はパッケージを作成したユーザーです。記載のないものはMeteor Development Groupによりメンテナンスされています。</p>

<p class="original">There are currently over 2000 packages available on Atmosphere. Below is a small
selection of some of the most useful packages.</p>
<p class="translation">現在Atmosphereには2000以上のパッケージが存在します。あなたにあったものが見つかるでしょう。</p>

<h2 id="/basic/accountsui">accounts-ui</h2>

<p class="original">This is a drop-in user interface to Meteor&apos;s accounts system. After adding the
package, include it in your templates with <code>{{&gt; loginButtons}}</code>. The UI
automatically adapts to include controls for any added login services, such as
<code>accounts-password</code>, <code>accounts-facebook</code>, etc.</p>
<p class="translation">accounts-uiはMeteor上のアカウントシステムです。パッケージを追加したあと、テンプレートに<code>{{&gt; loginButtons}}</code>を追加します。accounts-uiはソーシャルログインやログインのための機能を自動的に追加することができます。</p>

<p class="original"><a href="#/basic/accounts">See the docs about accounts-ui above.</a>.</p>
<p class="translation"><a href="#/basic/accounts">accounts-uiについてのドキュメントを御覧ください。</a></p>

<h2 id="/basic/coffeescript">coffeescript</h2>

<p class="original">Use <a href="http://coffeescript.org/">CoffeeScript</a> in your app. With this package, any
files with a <code>.coffee</code> extension will be compiled to JavaScript by Meteor&apos;s
build system.</p>
<p class="translation">coffeescriptをMeteorで利用するには<a href="http://coffeescript.org/">Coffeescriptパッケージ</a>を追加してください。.coffeeの拡張子を持つファイルがJavaScriptにコンパイルされるようになります。</p>

<h2 id="/basic/email">email</h2>

<p class="original">Send emails from your app. See the <a href="#/full/email">email section of the full API
docs</a>.</p>
<p class="translation">emailを送信するには、<a href="#/full/email">Full APIのメール送信の章を御覧ください。</a></p>

<h2 id="/basic/jade">mquandalle:jade</h2>

<p>Use the <a href="http://jade-lang.com/">Jade</a> templating language in your app. After
adding this package, any files with a <code>.jade</code> extension will be compiled into
Meteor templates. See the <a href="https://atmospherejs.com/mquandalle/jade?__hstc=256467284.06c0d3fa064611691d66d2c578e27182.1445920650574.1445920650574.1445920650574.1&amp;__hssc=256467284.1.1445920650574&amp;__hsfp=1614345591">page on
Atmosphere</a> for details.</p>

<h2 id="/basic/jquery">jquery</h2>

<p class="original">JQuery makes HTML traversal and manipulation, event handling, and animation
easy with a simple API that works across most browsers.</p>
<p class="translation">JQueryはシンプルなAPIで簡単にDOM操作が可能にします。</p>

<p class="original">JQuery is automatically included in every Meteor app since the framework uses it
extensively. See the <a href="http://jquery.com/">JQuery docs</a> for more details.</p>
<p class="translation">JQueryは自動的にMeteorアプリに含まれています。詳細は<a href="http://jquery.com/">JQueryのドキュメント</a>を御覧ください。</p>

<h2 id="/basic/http">http</h2>

<p class="original">This package allows you to make HTTP requests from the client or server using
the same API. See the <a href="#/full/http">http docs</a> to see how to use it.</p>
<p class="translation">このパッケージを利用すると、クライアントまたはサーバーからのHTTPリクエストが可能になります。詳細は<a href="#/full/http">httpのドキュメント</a>を御覧ください。</p>

<h2 id="/basic/less">less</h2>

<p class="original">Add the <a href="http://lesscss.org/">LESS</a> CSS preprocessor to your app to
compile any files with a <code>.less</code> extension into standard CSS. If you want
to use <code>@import</code> to include other files and not have Meteor automatically
compile them, use the <code>.import.less</code> extension.</p>
<p class="translation">.less拡張子を持つファイルをコンパイルするために、CSSプリプロセッサの<a href="http://lesscss.org/">LESS</a>を追加します。Meteorがコンパイルしてもいいファイルには<code>@import</code>を、コンパイルしないファイルには<code>.import.less</code>を使用してください。</p>

<h2 id="/basic/markdown">markdown</h2>

<p class="original">Include <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>
code in your templates. It&apos;s as easy as using the <code>{{#
markdown}}</code> helper:</p>
<p class="translation"><a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>を使用する場合は、<code>{{# markdown}}</code>をご使用ください。</p>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;my-div&quot;</span>&gt;</span>
{{#markdown}}
# My heading

Some paragraph text
{{/markdown}}
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>

<p class="original">Just make sure to keep your markdown unindented, since whitespace matters.</p>
<p class="translation">Markdownはインデントしないように注意してください。</p>

<h2 id="/basic/underscore">underscore</h2>

<p class="original"><a href="http://underscorejs.org/">Underscore</a> provides a collection of useful functions
to manipulate arrays, objects, and functions. <code>underscore</code> is included in every
Meteor app because the framework itself uses it extensively.</p>
<p class="translation"><a href="http://underscorejs.org/">Underscore</a>は、配列、オブジェクト、functionを操作するためのコレクションを提供します。MeteorはUnderscoreを利用しているため、Meteorには既にincludeされています。</p>

<h2 id="/basic/spiderable">spiderable</h2>

<p class="original">This package gives your app server-side rendering to allow search engine
crawlers and other bots see your app&apos;s contents. If you care about SEO, you
should add this package.</p>
<p class="translation">このパッケージは、検索エンジンのクローラや他のボットがアプリの内容を参照できるように、アプリケーションのサーバー側のレンダリングを提供します。SEO施策を行う際は、このパッケージをご利用ください。</p>

  <h1 id="checkoutthefullapidocs">Check out the Full API Docs</h1>

<p class="original">Congratulations, you&apos;re at the end of the Meteor basic documentation. For more
advanced features and more specific explanations, check out the <a href="#/full/">Full API
Docs</a>.</p>
<p class="translation">MeteorのBasicドキュメントは終了です。より詳しい説明は、<a href="#/full/">Full API Docs</a>を御覧ください。</p>

  <a href="http://meteor.com">
    <img src="http://docs.meteor.com/logo.png" style="width: 100%; max-width: 300px">
  </a>
        </div>
      </div>
    </div>
  </div>
  
<script>if(window.location.hash==="#showoriginal"){var nodes=document.getElementsByClassName("original");for(var i=0;i<nodes.length;i++){nodes[i].style.display="initial";}}</script></body></html>

<html manifest="/app.manifest"><head>
  <link rel="stylesheet" type="text/css" class="__meteor-css__" href="http://docs.meteor.com/4378b230b3427032028d881c2bb2e508762a7eab.css?meteor_css_resource=true">




  


  
    
  


<meta name="fragment" content="!">
<title>Documentation - Meteor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="Description" content="Meteor is an open-source JavaScript platform for building top-quality web apps in a fraction of the time, whether you&apos;re an expert developer or just getting started.">
  <link rel="icon" href="http://docs.meteor.com/favicon.png" type="image/png">

  <!-- Google Tag Manager -->
  <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-M2CMWR"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  
  <!-- End Google Tag Manager -->

  <!-- Start of Async HubSpot Analytics Code -->
    
  <!-- End of Async HubSpot Analytics Code -->
</head>
<body>



<div class="body sidebar-closed">
    
    <div id="nav">
      <div id="nav-inner">
    <h1>
      <a href="#/basic/">
        <img src="http://docs.meteor.com/logo.png" class="logo" alt="Meteor">
        <div>1.2.0.2 Documentation</div>
      </a>
    </h1>

    <select class="basic-or-full">
    <option value="basic">Basic Docs</option>
    
  </select>

    
    <div class="basic-toc">
    
      <section>
        
          <h2><a href="#/basic/quickstart" class="">Quick Start
          </a></h2>
        
          <h2><a href="#/basic/sevenprinciples" class="">Principles
          </a></h2>
        
          <h2><a href="#/basic/learning-resources" class="">Learning Resources
          </a></h2>
        
          <h2><a href="#/basic/command-line" class="">Command Line Tool
          </a></h2>
        
          <h2><a href="#/basic/filestructure" class="">File Structure
          </a></h2>
        
          <h2><a href="#/basic/buildingmobileapps" class="">Building Mobile Apps
          </a></h2>
        
        
        

        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/templates" class="">Templates
          </a></h2>
        
        
          <p class="subtitle">Create views that update automatically when data changes</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/defining-templates" class="">Defining templates in HTML</a>
              </li>
            
              <li>
                <a href="#/basic/Template-helpers" class="">Template.<em>name</em>.helpers</a>
              </li>
            
              <li>
                <a href="#/basic/Template-events" class="">Template.<em>name</em>.events</a>
              </li>
            
              <li>
                <a href="#/basic/Template-onRendered" class="">Template.<em>name</em>.onRendered</a>
              </li>
            
              <li>
                <a href="#/basic/Blaze-TemplateInstance-findAll" class=""><em>template</em>.findAll</a>
              </li>
            
              <li>
                <a href="#/basic/Blaze-TemplateInstance-find" class=""><em>template</em>.find</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/session" class="">Session
          </a></h2>
        
        
          <p class="subtitle">Store temporary data for the user interface</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Session-set" class="">Session.set</a>
              </li>
            
              <li>
                <a href="#/basic/Session-get" class="">Session.get</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/tracker" class="">Tracker
          </a></h2>
        
        
          <p class="subtitle">Re-run functions when data changes</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Tracker-autorun" class="">Tracker.autorun</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/collections" class="">Collections
          </a></h2>
        
        
          <p class="subtitle">Store persistent data</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Mongo-Collection" class="">Mongo.Collection</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-findOne" class=""><em>collection</em>.findOne</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-find" class=""><em>collection</em>.find</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-insert" class=""><em>collection</em>.insert</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-update" class=""><em>collection</em>.update</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-remove" class=""><em>collection</em>.remove</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-allow" class=""><em>collection</em>.allow</a>
              </li>
            
              <li>
                <a href="#/basic/Mongo-Collection-deny" class=""><em>collection</em>.deny</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/accounts" class="">Accounts
          </a></h2>
        
        
          <p class="subtitle">Let users log in with passwords, Facebook, Google, GitHub, etc.</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/loginButtons" class="">{{&gt; loginButtons}}</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-user" class="">Meteor.user</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-userId" class="">Meteor.userId</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-users" class="">Meteor.users</a>
              </li>
            
              <li>
                <a href="#/basic/currentUser" class="">{{currentUser}}</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/methods" class="">Methods
          </a></h2>
        
        
          <p class="subtitle">Call server functions from the client</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Meteor-methods" class="">Meteor.methods</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-call" class="">Meteor.call</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-Error" class="">Meteor.Error</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/pubsub" class="">Publish / Subscribe
          </a></h2>
        
        
          <p class="subtitle">Sync part of your data to the client</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Meteor-publish" class="">Meteor.publish</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-subscribe" class="">Meteor.subscribe</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/environment" class="">Environment
          </a></h2>
        
        
          <p class="subtitle">Control when and where your code runs</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/Meteor-isClient" class="">Meteor.isClient</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-isServer" class="">Meteor.isServer</a>
              </li>
            
              <li>
                <a href="#/basic/Meteor-startup" class="">Meteor.startup</a>
              </li>
            
          </ul>
        
      </section>
    
      <section>
        
        
          <h2><a href="#/basic/packages" class="">Packages
          </a></h2>
        
        
          <p class="subtitle">Choose from thousands of community packages</p>
        

        
          <ul>
            
              <li>
                <a href="#/basic/searchingforpackages" class="">Searching for packages</a>
              </li>
            
              <li>
                <a href="#/basic/accountsui" class="">accounts-ui</a>
              </li>
            
              <li>
                <a href="#/basic/coffeescript" class="">coffeescript</a>
              </li>
            
              <li>
                <a href="#/basic/email" class="">email</a>
              </li>
            
              <li>
                <a href="#/basic/jade" class="">jade</a>
              </li>
            
              <li>
                <a href="#/basic/jquery" class="">jquery</a>
              </li>
            
              <li>
                <a href="#/basic/http" class="">http</a>
              </li>
            
              <li>
                <a href="#/basic/less" class="">less</a>
              </li>
            
              <li>
                <a href="#/basic/markdown" class="">markdown</a>
              </li>
            
              <li>
                <a href="#/basic/underscore" class="">underscore</a>
              </li>
            
              <li>
                <a href="#/basic/spiderable" class="">spiderable</a>
              </li>
            
          </ul>
        
      </section>
    
  </div>
  </div>
    </div>
    <div class="overlay close-sidebar"></div>
    <div class="top-bar">
    <div class="hamburger-menu-target open-sidebar">
      <div class="hamburger-menu"></div>
    </div>
    <h1>
      <img src="http://docs.meteor.com/logo.png" class="logo" alt="Meteor"> 1.2.0.2 Docs
    </h1>
  </div>
    <div class="main-content">
      <div id="main">
        <div><div id="top"></div></div>
        
        <div class="">
          <div id="introduction">
<!-- clicking this anchor in the left bar should scroll to top of doc,
not here -->

<p><em><strong>Meteor is an ultra-simple environment for building modern websites.
What once took weeks, even with the best tools, now takes hours with
Meteor.</strong></em></p>

<p>The web was originally designed to work in the same way that mainframes
worked in the 70s.  The application server rendered a screen and sent it
over the network to a dumb terminal. Whenever the user did anything,
that server rerendered a whole new screen. This model served the Web
well for over a decade. It gave rise to LAMP, Rails, Django, PHP.</p>

<p>But the best teams, with the biggest budgets and the longest schedules,
now build applications in JavaScript that run on the client.  These apps
have stellar interfaces.  They don&apos;t reload pages.  They are reactive:
changes from any client immediately appear on everyone&apos;s screen.</p>

<p>They&apos;ve built them the hard way.  Meteor makes it an order of
magnitude simpler, and a lot more fun.  You can build a complete
application in a weekend, or a sufficiently caffeinated hackathon.  No
longer do you need to provision server resources, or deploy API
endpoints in the cloud, or manage a database, or wrangle an ORM layer,
or swap back and forth between JavaScript and Ruby, or broadcast data
invalidations to clients.</p>

<h2 id="/basic/quickstart">Quick start!</h2>

<p>Meteor supports <a href="https://github.com/meteor/meteor/wiki/Supported-Platforms">OS X, Windows, and Linux</a>.</p>

<p>On Windows?  <a href="https://install.meteor.com/windows">Download the official Meteor installer here</a>.</p>

<p>On OS X or Linux?  Install the latest official Meteor release from your terminal:</p>

<pre><code class="hljs bash">$ curl https://install.meteor.com/ | sh
</code></pre>

<p>The Windows installer supports Windows 7, Windows 8.1, Windows Server
2008, and Windows Server 2012.  The command line installer supports Mac OS X
10.7 (Lion) and above, and Linux on x86 and x86_64 architectures.</p>

<p>Once you&apos;ve installed Meteor, create a project:</p>

<pre><code class="hljs bash">meteor create myapp
</code></pre>

<p>Run it locally:</p>

<pre><code class="hljs bash"><span class="hljs-built_in">cd</span> myapp
meteor
<span class="hljs-comment"># Meteor server running on: http://localhost:3000/</span>
</code></pre>

<p>Then, open a new terminal tab and unleash it on the world (on a free server we provide):</p>

<pre><code class="hljs bash">meteor deploy myapp.meteor.com
</code></pre>

<h2 id="/basic/sevenprinciples">Principles of Meteor</h2>

<ul>
<li><p><em>Data on the Wire</em>. Meteor doesn&apos;t send HTML over the network. The server sends data and
lets the client render it.</p></li>
<li><p><em>One Language.</em> Meteor lets you write both the client and the server parts of your
application in JavaScript.</p></li>
<li><p><em>Database Everywhere</em>. You can use the same methods to access your
database from the client or the server.</p></li>
<li><p><em>Latency Compensation</em>. On the client, Meteor prefetches data and simulates models to make it look like server method calls return instantly.</p></li>
<li><p><em>Full Stack Reactivity</em>. In Meteor, realtime is the default. All layers, from
database to template, update themselves automatically when necessary.</p></li>
<li><p><em>Embrace the Ecosystem</em>. Meteor is open source and integrates with existing open source tools and frameworks.</p></li>
<li><p><em>Simplicity Equals Productivity</em>. The best way to make something
seem simple is to have it actually <em>be</em> simple. Meteor&apos;s main functionality has
clean, classically beautiful APIs.</p></li>
</ul>

<h2 id="/basic/learning-resources">Learning Resources</h2>

<!-- https://github.com/blog/273-github-ribbons -->

<p><a href="http://github.com/meteor/meteor"><img class="github-ribbon visible-desktop" style="position: absolute; top: 0; right: 0; border: 0;" src="/forkme_right_red_aa0000.png" alt="Fork me on GitHub"></a></p>

<p>There are many community resources for getting help with your app. If Meteor
catches your interest, we hope you&apos;ll get involved with the project!</p>

<dl class="involved">
<dt><span>Tutorial</span></dt>
<dd>Get started fast with the <a href="https://www.meteor.com/install">official Meteor tutorial</a>!
</dd>

<dt><span>Stack Overflow</span></dt>
<dd>The best place to ask (and answer!) technical questions is on <a href="http://stackoverflow.com/questions/tagged/meteor">Stack
  Overflow</a>.  Be sure to add
  the <code>meteor</code> tag to your question.
</dd>

<dt><span>Forums</span></dt>
<dd>Visit the <a href="https://forums.meteor.com">Meteor discussion
    forums</a> to announce projects, get help, talk about the community,
  or discuss changes to core.
</dd>

<dt><span>GitHub</span></dt>
<dd>The core code is on <a href="http://github.com/meteor/meteor">GitHub</a>.  If you&apos;re able to write code or file issues, we&apos;d love to have your help.  Please read <a href="https://github.com/meteor/meteor/wiki/Contributing-to-Meteor">Contributing to Meteor</a> for how to get started.
</dd>
</dl>
</div>

<h2 id="/basic/command-line">Command Line Tool</h2>

<h4 id="/basic/meteorhelp"><code>meteor help</code></h4>

<p>Get help on <code>meteor</code> command line usage. Running <code>meteor help</code> by itself
will list the common <code>meteor</code> commands. Running <code>meteor help &lt;command&gt;</code>
will print detailed help about <code>meteor &lt;command&gt;</code>.</p>

<h4 id="/basic/meteorcreatename"><code>meteor create &lt;name&gt;</code></h4>

<p>Make a subdirectory called <code>&lt;name&gt;</code> and create a new Meteor app there.</p>

<h4 id="/basic/meteorrun"><code>meteor run</code></h4>

<p>Serve the current app at <a href="http://localhost:3000">http://localhost:3000</a>
using Meteor&apos;s local development server.</p>

<h4 id="/basic/meteordebug"><code>meteor debug</code></h4>

<p>Run the project with Node Inspector attached, so that you can step through your server code line by line. See <a href="#/full/meteordebug"><code>meteor debug</code></a> in the full docs for more information.</p>

<h4 id="/basic/meteordeploysite"><code>meteor deploy &lt;site&gt;</code></h4>

<p>Bundle your app and deploy it to <code>&lt;site&gt;</code>. Meteor provides free hosting if
you deploy to <code>&lt;your app&gt;.meteor.com</code> as long as <code>&lt;your app&gt;</code> is a name
that has not been claimed by someone else.</p>

<h4 id="/basic/meteorupdate"><code>meteor update</code></h4>

<p>Update your Meteor installation to the latest released version and then
(if <code>meteor update</code> was run from an app directory) update the packages
used by the current app to the latest versions that are compatible with
all other packages used by the app.</p>

<h4 id="/basic/meteoradd"><code>meteor add</code></h4>

<p>Add a package (or multiple packages) to your Meteor project. To query for
available packages, use the <code>meteor search</code> command.</p>

<h4 id="/basic/meteorremove"><code>meteor remove</code></h4>

<p>Remove a package previously added to your Meteor project. For a list of
the packages that your application is currently using, use the
<code>meteor list</code> command.</p>

<h4 id="/basic/meteormongo"><code>meteor mongo</code></h4>

<p>Opens a MongoDB shell for viewing and/or manipulating collections stored
in the database. Note that you must already be running a server for the
current app (in another terminal window) in order for <code>meteor mongo</code> to
connect to the app&apos;s database.</p>

<h4 id="/basic/meteorreset"><code>meteor reset</code></h4>

<p>Reset the current project to a fresh state. Removes all local data.</p>

<p>If you use <code>meteor reset</code> often, but you have some initial data that you don&apos;t
want to discard, consider using <a href="#/basic/Meteor-startup"><code>Meteor.startup</code></a> to
recreate that data the first time the server starts up:</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (Meteor.isServer) {
  Meteor.startup(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (Rooms.find().count() === <span class="hljs-number">0</span>) {
      Rooms.insert({name: <span class="hljs-string">&quot;Initial room&quot;</span>});
    }
  });
}
</code></pre>
<h2 id="/basic/filestructure">File Structure</h2>

<p>Meteor is very flexible about how you structure the files in your app. It
automatically loads all of your files, so there is no need to use <code>&lt;script&gt;</code> or
<code>&lt;link&gt;</code> tags to include JavaScript or CSS.</p>

<h3 id="/basic/defaultfileloading">Default file loading</h3>

<p>If files are outside of the special directories listed below, Meteor does the following:</p>

<ol>
<li>HTML templates are compiled and sent to the client. See <a href="#/basic/templates">the templates section</a> for more details.</li>
<li>CSS files are sent to the client. In production mode they are automatically concatenated and minified.</li>
<li>JavaScript is loaded on the client and the server. You can use <code>Meteor.isClient</code> and <code>Meteor.isServer</code> to control where certain blocks of code run.</li>
</ol>

<p>If you want more control over which JavaScript code is loaded on the client and
the server, you can use the special directories listed below.</p>

<h3 id="/basic/specialdirectories">Special directories</h3>

<h4 id="/basic/client"><code>/client</code></h4>

<p>Any files here are only served to the client. This is a good place to keep your
HTML, CSS, and UI-related JavaScript code.</p>

<h4 id="/basic/server"><code>/server</code></h4>

<p>Any files in this directory are only used on the server, and are never sent to
the client. Use <code>/server</code> to store source files with sensitive logic or data
that should not be visible to the client.</p>

<h4 id="/basic/public"><code>/public</code></h4>

<p>Files in <code>/public</code> are served to the client as-is. Use this to store assets such
as images. For example, if you have an image located at
<code>/public/background.png</code>, you can include it in your HTML with <code>&lt;img src=&apos;/background.png&apos;/&gt;</code> or in your CSS with <code>background-image:
url(/background.png)</code>. Note that <code>/public</code> is not part of the image URL.</p>

<h4 id="/basic/private"><code>/private</code></h4>

<p>These files can only be accessed by server code through <a href="#assets"><code>Assets</code></a> API and are not accessible to the client.</p>

<p>Read more about file load order and special directories in the <a href="#/full/structuringyourapp">Structuring Your
App section</a> of the full API documentation.</p>
<h2 id="/basic/buildingmobileapps">Building Mobile Apps</h2>

<p>Once you&apos;ve built your web app with Meteor, you can easily build a native
wrapper for your app and publish it to the Google Play Store or iOS App Store
with just a few commands. We&apos;ve put a lot of work into making the same packages
and APIs work on desktop and mobile, so that you don&apos;t have to worry about a lot
of the edge cases associated with mobile app development.</p>

<h3 id="/basic/installingmobilesdks">Installing mobile SDKs</h3>

<p>Install the development tools for Android or iOS with one command:</p>

<pre><code class="hljs bash">meteor install-sdk android     <span class="hljs-comment"># for Android</span>
meteor install-sdk ios         <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/addingplatforms">Adding platforms</h3>

<p>Add the relevant platform to your app:</p>

<pre><code class="hljs bash">meteor add-platform android    <span class="hljs-comment"># for Android</span>
meteor add-platform ios        <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/runningonasimulator">Running on a simulator</h3>

<pre><code class="hljs bash">meteor run android             <span class="hljs-comment"># for Android</span>
meteor run ios                 <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/runningonadevice">Running on a device</h3>

<pre><code class="hljs bash">meteor run android-device      <span class="hljs-comment"># for Android</span>
meteor run ios-device          <span class="hljs-comment"># for iOS</span>
</code></pre>

<h3 id="/basic/configuringappiconsandmetadata">Configuring app icons and metadata</h3>

<p>You can configure your app&apos;s icons, title, version number, splash screen, and other metadata with the special <a href="#/full/mobileconfigjs"><code>mobile-config.js</code> file</a>.</p>

<p>Learn more about Meteor&apos;s mobile support on the <a href="https://github.com/meteor/meteor/wiki/Meteor-Cordova-Phonegap-integration">GitHub wiki page</a>.</p>
  <h1 id="api">The Meteor API</h1>

<p>Your JavaScript code can run in two environments: the <em>client</em> (browser), and
the <em>server</em> (a <a href="http://nodejs.org/">Node.js</a> container on a server).  For each
function in this API reference, we&apos;ll indicate if the function is available just
on the client, just on the server, or <em>Anywhere</em>.</p>

<p></p><h2 id="/basic/templates"><span>Templates</span></h2>

<p>In Meteor, views are defined in <em>templates</em>. A template is a snippet of HTML
that can include dynamic data. You can also interact with your templates from
JavaScript code to insert data and listen to events.</p>

<h3 class="api-title" id="/basic/defining-templates">Defining Templates in HTML</h3>

<p>Templates are defined in <code>.html</code> files that can be located anywhere in your
Meteor project folder except the <code>server</code>, <code>public</code>, and <code>private</code> directories.</p>

<p>Each <code>.html</code> file can contain any number of the following top-level elements:
<code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, or <code>&lt;template&gt;</code>. Code in the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags is
appended to that section of the HTML page, and code inside <code>&lt;template&gt;</code> tags can
be included using <code>{{&gt; templateName}}</code>, as shown in the example below.
Templates can be included more than once &#x2014; one of the main purposes of
templates is to avoid writing the same HTML multiple times by hand.</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- add code to the &lt;head&gt; of the page --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">title</span>&gt;</span>My website!<span class="hljs-tag">&lt;/<span class="hljs-title">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>

<span class="hljs-comment">&lt;!-- add code to the &lt;body&gt; of the page --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
  {{&gt; welcomePage}}
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>

<span class="hljs-comment">&lt;!-- define a template called welcomePage --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;welcomePage&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Welcome to my website!<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p>The <code>{{ ... }}</code> syntax is part of a language called Spacebars that
Meteor uses to add functionality to HTML. As shown above, it lets you include
templates in other parts of your page. Using Spacebars, you can also display
data obtained from <em>helpers</em>. Helpers are written in JavaScript, and can be
either simple values or functions.</p>


<div class="api new-api-box">
  <h3 id="/basic/Template-helpers" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Template-helpers"><em>Template.myTemplate</em>.helpers(helpers)</a>

    
  </h3>

  <div class="desc">
    <p>Specify template helpers available to this template.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">helpers</span>
          <span class="type">Object</span>
        </dt>
        <dd>
          <p>Dictionary of helper functions by name.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Here&apos;s how you might define a helper called <code>name</code> for a template called
<code>nametag</code> (in JavaScript):</p>

<pre><code class="hljs css"><span class="hljs-tag">Template</span><span class="hljs-class">.nametag</span><span class="hljs-class">.helpers</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">name</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Ben Bitdiddle&quot;</span>
</span></span></span>});
</code></pre>

<p>And here is the <code>nametag</code> template itself (in HTML):</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- In an HTML file, display the value of the helper --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;nametag&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>My name is {{name}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p>Spacebars also has a few other handy control structures that can be used
to make your views more dynamic:</p>

<ul>
<li><code>{{#each data}} ... {{/each}}</code> - Iterate over the items in
<code>data</code> and display the HTML inside the block for each one.</li>
<li><code>{{#if data}} ... {{else}} ... {{/if}}</code> - If <code>data</code>
is <code>true</code>, display the first block; if it is false, display the second one.</li>
<li><code>{{#with data}} ... {{/with}}</code> - Set the data context of
the HTML inside, and display it.</li>
</ul>

<p>Each nested <code>#each</code> or <code>#with</code> block has its own <em>data context</em>, which is
an object whose properties can be used as helpers inside the block. For
<code>#with</code> blocks, the data context is simply the value that appears after
the <code>#with</code> and before the <code>}}</code> characters. For <code>#each</code> blocks, each
element of the given array becomes the data context while the block is
evaluated for that element.</p>

<p>For instance, if the <code>people</code> helper has the following value</p>

<pre><code class="hljs css"><span class="hljs-tag">Template</span><span class="hljs-class">.welcomePage</span><span class="hljs-class">.helpers</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">people</span>:<span class="hljs-value"> [{name: <span class="hljs-string">&quot;Bob&quot;</span></span></span></span>}, <span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">name</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Frank&quot;</span></span></span></span>}, <span class="hljs-rules">{<span class="hljs-rule"><span class="hljs-attribute">name</span>:<span class="hljs-value"> <span class="hljs-string">&quot;Alice&quot;</span></span></span></span>}]
});
</code></pre>

<p>then you can display every person&apos;s name as a list of <code>&lt;p&gt;</code> tags:</p>

<pre><code class="hljs html">{{#each people}}
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{{name}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
{{/each}}
</code></pre>

<p>or use the &quot;nametag&quot; template from above instead of <code>&lt;p&gt;</code> tags:</p>

<pre><code class="hljs html">{{#each people}}
  {{&gt; nametag}}
{{/each}}
</code></pre>

<p>Remember that helpers can be functions as well as simple values. For
example, to show the logged in user&apos;s username, you might define a
function-valued helper called <code>username</code>:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// in your JS file</span>
Template.profilePage.helpers({
  username: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Meteor.user() &amp;&amp; Meteor.user().username;
  }
});
</code></pre>

<p>Now, each time you use the <code>username</code> helper, the helper function above
will be called to determine the user&apos;s name:</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- in your HTML --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;profilePage&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>Profile page for {{username}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p>Helpers can also take arguments. For example, here&apos;s a helper that pluralizes
a word:</p>

<pre><code class="hljs js">Template.post.helpers({
  commentCount: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(numComments)</span> </span>{
    <span class="hljs-keyword">if</span> (numComments === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1 comment&quot;</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> numComments + <span class="hljs-string">&quot; comments&quot;</span>;
    }
  }
});
</code></pre>

<p>Pass in arguments by putting them inside the curly braces after the name of the
helper:</p>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>There are {{commentCount 3}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
</code></pre>

<p>The helpers above have all been associated with specific templates, but
you can also make a helper available in all templates by using
<a href="#template_registerhelper"><code>Template.registerHelper</code></a>.</p>

<p>You can find detailed documentation for Spacebars in the
<a href="https://github.com/meteor/meteor/blob/master/packages/spacebars/README.md">README on GitHub</a>.
Later in this documentation, the sections about <code>Session</code>, <code>Tracker</code>,
<code>Collections</code>, and <code>Accounts</code> will talk more about how to add dynamic data
to your templates.</p>


<div class="api new-api-box">
  <h3 id="/basic/Template-events" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Template-events"><em>Template.myTemplate</em>.events(eventMap)</a>

    
  </h3>

  <div class="desc">
    <p>Specify event handlers for this template.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">eventMap</span>
          <span class="type"><a href="#eventmaps">Event Map</a></span>
        </dt>
        <dd>
          <p>Event handlers to associate with this template.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>The event map passed into <code>Template.myTemplate.events</code> has event descriptors as
its keys and event handler functions as the values. Event handlers get two
arguments: the event object and the template instance. Event handlers can also
access the data context of the target element in <code>this</code>.</p>

<p>To attach event handlers to the following template</p>

<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;example&quot;</span>&gt;</span>
  {{#with myHelper}}
    <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;my-button&quot;</span>&gt;</span>My button<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">form</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&quot;text&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;myInput&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">&quot;submit&quot;</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">&quot;Submit Form&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
  {{/with}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p>you might call <code>Template.example.events</code> as follows:</p>

<pre><code class="hljs javascript">Template.example.events({
  <span class="hljs-string">&quot;click .my-button&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event, template)</span> </span>{
    alert(<span class="hljs-string">&quot;My button was clicked!&quot;</span>);
  },
  <span class="hljs-string">&quot;submit form&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event, template)</span> </span>{
    <span class="hljs-keyword">var</span> inputValue = event.target.myInput.value;
    <span class="hljs-keyword">var</span> helperValue = <span class="hljs-keyword">this</span>;
    alert(inputValue, helperValue);
  }
});
</code></pre>

<p>The first part of the key (before the first space) is the name of the
event being captured. Pretty much any DOM event is supported. Some common
ones are: <code>click</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseenter</code>, <code>mouseleave</code>,
<code>keydown</code>, <code>keyup</code>, <code>keypress</code>, <code>focus</code>, <code>blur</code>, and <code>change</code>.</p>

<p>The second part of the key (after the first space) is a CSS selector that
indicates which elements to listen to. This can be almost any selector
<a href="http://api.jquery.com/category/selectors/">supported by JQuery</a>.</p>

Whenever the indicated event happens on the selected element, the
corresponding event handler function will be called with the relevant DOM
event object and template instance. See the [Event Maps section](#eventmaps)
for details.
<!-- TODO Update the link to full docs for Event Maps -->


<div class="api new-api-box">
  <h3 id="/basic/Template-onRendered" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Template-onRendered"><em>Template.myTemplate</em>.onRendered</a>

    
  </h3>

  <div class="desc">
    <p>Register a function to be called when an instance of this template is inserted into the DOM.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>A function to be added as a callback.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>The functions added with this method are called once for every instance of
<em>Template.myTemplate</em> when it is inserted into the page for the first time.</p>

<p>These callbacks can be used to integrate external libraries that
aren&apos;t familiar with Meteor&apos;s automatic view rendering, and need to be
initialized every time HTML is inserted into the page.
You can perform initialization or clean-up on any objects in
<a href="#template_oncreated"><code>onCreated</code></a> and <a href="#template_ondestroyed"><code>onDestroyed</code></a>
callbacks.</p>

<p>For example, to use the HighlightJS library to apply code highlighting to
all <code>&lt;pre&gt;</code> elements inside the <code>codeSample</code> template, you might pass
the following function to <code>Template.codeSample.onRendered</code>:</p>

<pre><code class="hljs javascript">Template.codeSample.onRendered(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  hljs.highlightBlock(<span class="hljs-keyword">this</span>.findAll(<span class="hljs-string">&apos;pre&apos;</span>));
});
</code></pre>

<p>In the callback function, <code>this</code> is bound to a <a href="#template_inst">template
instance</a> object that is unique to this inclusion of the
template and remains across re-renderings. You can use methods like
<a href="#template_find"><code>this.find</code></a> and
<a href="#template_findAll"><code>this.findAll</code></a> to access DOM nodes in the template&apos;s
rendered HTML.</p>

<h2 id="/basic/template_inst"><span>Template instances</span></h2>

<p>A template instance object represents a single inclusion of a template in the
document.  It can be used to access the HTML elements inside the template and it
can be assigned properties that persist as the template is reactively updated.</p>

<p>Template instance objects can be found in several places:</p>

<ol>
<li>The value of <code>this</code> in the <code>created</code>, <code>rendered</code>,
and <code>destroyed</code> template callbacks</li>
<li>The second argument to event handlers</li>
<li>As <a href="#template_instance"><code>Template.instance()</code></a> inside helpers</li>
</ol>

<p>You can assign additional properties of your choice to the template instance to
keep track of any state relevant to the template. For example, when using the
Google Maps API you could attach the <code>map</code> object to the current template
instance to be able to refer to it in helpers and event handlers. Use the
<a href="#template_onCreated"><code>onCreated</code></a> and <a href="#template_onDestroyed"><code>onDestroyed</code></a>
callbacks to perform initialization or clean-up.</p>


<div class="api new-api-box">
  <h3 id="/basic/Blaze-TemplateInstance-findAll" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Blaze-TemplateInstance-findAll"><em>template</em>.findAll(selector)</a>

    
  </h3>

  <div class="desc">
    <p>Find all elements matching <code>selector</code> in this template instance.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>The CSS selector to match, scoped to the template contents.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p><code>template.findAll</code> returns an array of DOM elements matching <code>selector</code>. You can
also use <code>template.$</code>, which works exactly like the JQuery <code>$</code> function but only
returns elements within <code>template</code>.</p>


<div class="api new-api-box">
  <h3 id="/basic/Blaze-TemplateInstance-find" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Blaze-TemplateInstance-find"><em>template</em>.find(selector)</a>

    
  </h3>

  <div class="desc">
    <p>Find one element matching <code>selector</code> in this template instance.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>The CSS selector to match, scoped to the template contents.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<!-- XXX Why is this not findOne? -->

<p><code>find</code> is just like <code>findAll</code> but only returns the first element found. Like
<code>findAll</code>, <code>find</code> only returns elements from inside the template.</p>
<h2 id="/basic/session"><span>Session</span></h2>

<p><code>Session</code> provides a global object on the client that you can use to
store an arbitrary set of key-value pairs. Use it to store things like
the currently selected item in a list.</p>

<p>What&apos;s special about <code>Session</code> is that it&apos;s <em>reactive</em>. If you call
<code>Session.get(&quot;myKey&quot;)</code> in a <a href="#template_helpers">template helper</a> or inside
<a href="#tracker_autorun"><code>Tracker.autorun</code></a>, the relevant part of the template will
be re-rendered automatically whenever <code>Session.set(&quot;myKey&quot;, newValue)</code> is
called.</p>


<div class="api new-api-box">
  <h3 id="/basic/Session-set" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Session-set">Session.set(key, value)</a>

    
  </h3>

  <div class="desc">
    <p>Set a variable in the session. Notify any listeners that the value
has changed (eg: redraw templates, and rerun any
<a href="#tracker_autorun"><code>Tracker.autorun</code></a> computations, that called
<a href="#session_get"><code>Session.get</code></a> on this <code>key</code>.)</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">key</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>The key to set, eg, <code>selectedItem</code></p>
        </dd>
      
        <dt>
          <span class="name">value</span>
          <span class="type"><a href="#ejson">EJSON-able Object</a> or undefined</span>
        </dt>
        <dd>
          <p>The new value for <code>key</code></p>
        </dd>
      
    </dl>
  

  

  
</div>

<!-- XXX The Session.set API box is a little wonky -->


<div class="api new-api-box">
  <h3 id="/basic/Session-get" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Session-get">Session.get(key)</a>

    
  </h3>

  <div class="desc">
    <p>Get the value of a session variable. If inside a <a href="#reactivity">reactive
computation</a>, invalidate the computation the next time the
value of the variable is changed by <a href="#session_set"><code>Session.set</code></a>. This
returns a clone of the session value, so if it&apos;s an object or an array,
mutating the returned value has no effect on the value stored in the
session.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">key</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>The name of the session variable to return</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Example:</p>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- In your template --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;main&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>We&apos;ve always been at war with {{theEnemy}}.<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<pre><code class="hljs javascript"><span class="hljs-comment">// In your JavaScript</span>
Template.main.helpers({
  theEnemy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> Session.get(<span class="hljs-string">&quot;enemy&quot;</span>);
  }
});

Session.set(<span class="hljs-string">&quot;enemy&quot;</span>, <span class="hljs-string">&quot;Eastasia&quot;</span>);
<span class="hljs-comment">// Page will say &quot;We&apos;ve always been at war with Eastasia&quot;</span>

Session.set(<span class="hljs-string">&quot;enemy&quot;</span>, <span class="hljs-string">&quot;Eurasia&quot;</span>);
<span class="hljs-comment">// Page will change to say &quot;We&apos;ve always been at war with Eurasia&quot;</span>
</code></pre>

<p>Using <code>Session</code> gives us our first taste of <em>reactivity</em>, the idea that the view
should update automatically when necessary, without us having to call a <code>render</code>
function manually. In the next section, we will learn how to use Tracker, the
lightweight library that makes this possible in Meteor.</p>
<h2 id="/basic/tracker"><span>Tracker</span></h2>

<p>Meteor has a simple dependency tracking system which allows it to
automatically rerun templates and other functions whenever
<a href="#session"><code>Session</code></a> variables, database queries, and other data
sources change.</p>

<p>Unlike most other systems, you don&apos;t have to manually declare these dependencies
&#x2014; it &quot;just works.&quot; The mechanism is simple and efficient. Once you&apos;ve
initialized a computation with <code>Tracker.autorun</code>, whenever you call a Meteor function that returns data, <code>Tracker</code> automatically records which data were
accessed. Later, when this data changes, the computation is rerun automatically.
This is how a template knows how to re-render whenever its <a href="#template_helpers">helper
functions</a> have new data to return.</p>


<div class="api new-api-box">
  <h3 id="/basic/Tracker-autorun" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Tracker-autorun">Tracker.autorun(runFunc, [options])</a>

    
  </h3>

  <div class="desc">
    <p>Run a function now and rerun it later whenever its dependencies
change. Returns a Computation object that can be used to stop or observe the
rerunning.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">runFunc</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>The function to run. It receives
one argument: the Computation object that will be returned.</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">onError</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Optional. The function to run when an error
happens in the Computation. The only argument it recieves is the Error
thrown. Defaults to the error being logged to the console.</p>
        </dd>
      
    </dl>
  

  
</div>


<p><code>Tracker.autorun</code> allows you to run a function that depends on reactive
data sources. Whenever those data sources are updated with new data, the
function will be rerun.</p>

<p>For example, you can monitor one <code>Session</code> variable and set another:</p>

<pre><code class="hljs javascript">Tracker.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> celsius = Session.get(<span class="hljs-string">&quot;celsius&quot;</span>);
  Session.set(<span class="hljs-string">&quot;fahrenheit&quot;</span>, celsius * <span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>);
});
</code></pre>

<p>Or you can wait for a session variable to have a certain value, and do
something the first time it does. If you want to prevent further rerunning
of the function, you can call <code>stop</code> on the computation object that is
passed as the first parameter to the callback function:</p>

<pre><code class="hljs cs"><span class="hljs-comment">// Initialize a session variable called &quot;counter&quot; to 0</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// The autorun function runs but does not alert (counter: 0)</span>
Tracker.autorun(function (computation) {
  <span class="hljs-keyword">if</span> (Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) === <span class="hljs-number">2</span>) {
    computation.stop();
    alert(<span class="hljs-string">&quot;counter reached two&quot;</span>);
  }
});

<span class="hljs-comment">// The autorun function runs but does not alert (counter: 1)</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) + <span class="hljs-number">1</span>);

<span class="hljs-comment">// The autorun function runs and alerts &quot;counter reached two&quot;</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) + <span class="hljs-number">1</span>);

<span class="hljs-comment">// The autorun function no longer runs (counter: 3)</span>
Session.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;counter&quot;</span>, Session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;counter&quot;</span>) + <span class="hljs-number">1</span>);
</code></pre>

<p>The first time <code>Tracker.autorun</code> is called, the callback function is
invoked immediately, at which point it alerts and stops right away if
<code>counter === 2</code> already. In this example, <code>Session.get(&quot;counter&quot;) === 0</code>
when <code>Tracker.autorun</code> is called, so nothing happens the first time, and
the function is run again each time <code>counter</code> changes, until
<code>computation.stop()</code> is called after <code>counter</code> reaches <code>2</code>.</p>

<p>If the initial run of an autorun throws an exception, the computation
is automatically stopped and won&apos;t be rerun.</p>

<p>To learn more about how <code>Tracker</code> works and to explore advanced ways to
use it, visit the <a href="http://manual.meteor.com/#tracker">Tracker</a>
chapter in the <a href="http://manual.meteor.com/">Meteor Manual</a>,
which describes it in much more detail.</p>
<h2 id="/basic/collections"><span>Collections</span></h2>

<p>Meteor stores data in <em>collections</em>. JavaScript objects stored in collections
are called <code>documents</code>.  To get started, declare a collection with
<code>new Mongo.Collection</code>.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection">new Mongo.Collection(name, [options])</a>

    
  </h3>

  <div class="desc">
    <p>Constructor for a Collection</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Calling the <code>Mongo.Collection</code> constructor creates a collection object
which acts just like a MongoDB collection. If you pass a name when you
create the collection, then you are declaring a persistent collection
&#x2014; one that is stored on the server and can be published to clients.</p>

<p>To allow both client code and server code to access the same collection
using the same API, it&apos;s usually best to declare collections as global
variables in a JavaScript file that&apos;s present on both client and server.</p>

<p>Here&apos;s an example of declaring two named, persistent collections as global
variables:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// In a JS file that&apos;s loaded on the client and the server</span>
Posts = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">&quot;posts&quot;</span>);
Comments = <span class="hljs-keyword">new</span> Mongo.Collection(<span class="hljs-string">&quot;comments&quot;</span>);
</code></pre>

<p>If you pass <code>null</code> as the name, then you&apos;re creating a local
collection. Local collections are not synchronized between the client and
the server; they are just temporary collections of JavaScript objects that
support Mongo-style <code>find</code>, <code>insert</code>, <code>update</code>, and <code>remove</code> operations.</p>

<p>By default, Meteor automatically publishes every document in your
collection to each connected client. To disable this behavior, you must
remove the <code>autopublish</code> package, in your terminal:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> remove autopublish
</code></pre>

<p>Then, use <a href="#meteor_publish"><code>Meteor.publish</code></a> and
<a href="#meteor_subscribe"><code>Meteor.subscribe</code></a> to specify which parts of your
collection should be published to which clients.</p>

<p>Use <code>findOne</code> or <code>find</code> to retrieve documents from a collection.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-findOne" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-findOne"><em>collection</em>.findOne([selector], [options])</a>

    
  </h3>

  <div class="desc">
    <p>Finds the first document that matches the selector, as ordered by sort and skip options.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p>A query describing the documents to find</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">sort</span>
          <span class="type"><a href="#sortspecifiers">Mongo Sort Specifier</a></span>
        </dt>
        <dd>
          <p>Sort order (default: natural order)</p>
        </dd>
      
        <dt>
          <span class="name">skip</span>
          <span class="type">Number</span>
        </dt>
        <dd>
          <p>Number of results to skip at the beginning</p>
        </dd>
      
        <dt>
          <span class="name">fields</span>
          <span class="type"><a href="#fieldspecifiers">Mongo Field Specifier</a></span>
        </dt>
        <dd>
          <p>Dictionary of fields to return or exclude.</p>
        </dd>
      
    </dl>
  

  
</div>


<p>This method lets you retrieve a specific document from your
collection. The <code>findOne</code> method is most commonly called with a specific
document <code>_id</code>:</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> post = Posts.findOne(postId);
</code></pre>

<p>However, you can also call <code>findOne</code> with a Mongo selector, which is an
object that specifies a required set of attributes of the desired
document. For example, this selector</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> post = Posts.findOne({
  createdBy: <span class="hljs-string">&quot;12345&quot;</span>,
  title: {$regex: <span class="hljs-regexp">/first/</span>}
});
</code></pre>

<p>will match this document</p>

<pre><code class="hljs css"><span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">createdBy</span>:<span class="hljs-value"> <span class="hljs-string">&quot;12345&quot;</span>,
  title: <span class="hljs-string">&quot;My first post!&quot;</span>,
  content: <span class="hljs-string">&quot;Today was a good day.&quot;</span>
</span></span></span>}
</code></pre>

<p>You can read about MongoDB query operators such as <code>$regex</code>, <code>$lt</code> (less than),
<code>$text</code> (text search), and more in the <a href="http://docs.mongodb.org/manual/reference/operator/query/">MongoDB
documentation</a>.</p>

<p>One useful behavior that might not be obvious is that Mongo selectors also
match items in arrays. For example, this selector</p>

<pre><code class="hljs css"><span class="hljs-tag">Post</span><span class="hljs-class">.findOne</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">tags</span>:<span class="hljs-value"> <span class="hljs-string">&quot;meteor&quot;</span>
</span></span></span>});
</code></pre>

<p>will match this document</p>

<pre><code class="hljs css"><span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">title</span>:<span class="hljs-value"> <span class="hljs-string">&quot;I love Meteor&quot;</span>,
  createdBy: <span class="hljs-string">&quot;242135223&quot;</span>,
  tags: [<span class="hljs-string">&quot;meteor&quot;</span>, <span class="hljs-string">&quot;javascript&quot;</span>, <span class="hljs-string">&quot;fun&quot;</span>]
</span></span></span>}
</code></pre>

<p>The <code>findOne</code> method is reactive just like <a href="#session_get"><code>Session.get</code></a>,
meaning that, if you use it inside a <a href="#template_helpers">template helper</a>
or a <a href="#tracker_autorun"><code>Tracker.autorun</code></a> callback, it will automatically
rerender the view or rerun the computation if the returned document
changes.</p>

<p>Note that <code>findOne</code> will return <code>null</code> if it fails to find a matching document,
which often happens if the document hasn&apos;t been loaded yet or has been removed
from the collection, so you should be prepared to handle <code>null</code> values.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-find" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-find"><em>collection</em>.find([selector], [options])</a>

    
  </h3>

  <div class="desc">
    <p>Find the documents in a collection that match the selector.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p>A query describing the documents to find</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">sort</span>
          <span class="type"><a href="#sortspecifiers">Mongo Sort Specifier</a></span>
        </dt>
        <dd>
          <p>Sort order (default: natural order)</p>
        </dd>
      
        <dt>
          <span class="name">skip</span>
          <span class="type">Number</span>
        </dt>
        <dd>
          <p>Number of results to skip at the beginning</p>
        </dd>
      
        <dt>
          <span class="name">limit</span>
          <span class="type">Number</span>
        </dt>
        <dd>
          <p>Maximum number of results to return</p>
        </dd>
      
        <dt>
          <span class="name">fields</span>
          <span class="type"><a href="#fieldspecifiers">Mongo Field Specifier</a></span>
        </dt>
        <dd>
          <p>Dictionary of fields to return or exclude.</p>
        </dd>
      
    </dl>
  

  
</div>


<p>The <code>find</code> method is similar to <code>findOne</code>, but instead of returning a
single document it returns a MongoDB <em>cursor</em>. A cursor is a special
object that represents a list of documents that might be returned from a
query. You can pass a cursor into a template helper anywhere you could
pass an array:</p>

<pre><code class="hljs javascript">Template.blog.helpers({
  posts: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// this helper returns a cursor of</span>
    <span class="hljs-comment">// all of the posts in the collection</span>
    <span class="hljs-keyword">return</span> Posts.find();
  }
});
</code></pre>

<pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- a template that renders multiple posts --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">template</span> <span class="hljs-attribute">name</span>=<span class="hljs-value">&quot;blog&quot;</span>&gt;</span>
  {{#each posts}}
    <span class="hljs-tag">&lt;<span class="hljs-title">h1</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-title">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">p</span>&gt;</span>{{content}}<span class="hljs-tag">&lt;/<span class="hljs-title">p</span>&gt;</span>
  {{/each}}
<span class="hljs-tag">&lt;/<span class="hljs-title">template</span>&gt;</span>
</code></pre>

<p>When you want to retrieve the current list of documents from a cursor,
call the cursor&apos;s <code>.fetch()</code> method:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// get an array of posts</span>
<span class="hljs-keyword">var</span> postsArray = Posts.find().fetch();
</code></pre>

<p>Keep in mind that while the computation in which you call <code>fetch</code> will rerun
when the data changes, the resulting array will not be reactive if it is
passed somewhere else.</p>

<p>You can modify the data stored in a <code>Mongo.Collection</code> by calling <code>insert</code>,
<code>update</code>, or <code>remove</code>.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-insert" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-insert"><em>collection</em>.insert(doc, [callback])</a>

    
  </h3>

  <div class="desc">
    <p>Insert a document in the collection.  Returns its unique _id.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">doc</span>
          <span class="type">Object</span>
        </dt>
        <dd>
          <p>The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.</p>
        </dd>
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Here&apos;s how you insert a document into a collection:</p>

<pre><code class="hljs css"><span class="hljs-tag">Posts</span><span class="hljs-class">.insert</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">createdBy</span>:<span class="hljs-value"> Meteor.<span class="hljs-function">userId</span>(),
  createdAt: new <span class="hljs-function">Date</span>(),
  title: <span class="hljs-string">&quot;My first post!&quot;</span>,
  content: <span class="hljs-string">&quot;Today was a good day.&quot;</span>
</span></span></span>});
</code></pre>

<p>Every document in every <code>Mongo.Collection</code> has an <code>_id</code> field. It must be
unique, and is automatically generated if you don&apos;t provide one. The <code>_id</code>
field can be used to retrieve a specific document using
<a href="#findOne"><code>collection.findOne</code></a>.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-update" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-update"><em>collection</em>.update(selector, modifier, [options], [callback])</a>

    
  </h3>

  <div class="desc">
    <p>Modify one or more documents in the collection. Returns the number of affected documents.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p>Specifies which documents to modify</p>
        </dd>
      
        <dt>
          <span class="name">modifier</span>
          <span class="type"><a href="#modifiers">Mongo Modifier</a></span>
        </dt>
        <dd>
          <p>Specifies how to modify the documents</p>
        </dd>
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.</p>
        </dd>
      
    </dl>
  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">multi</span>
          <span class="type">Boolean</span>
        </dt>
        <dd>
          <p>True to modify all matching documents; false to only modify one of the matching documents (the default).</p>
        </dd>
      
        <dt>
          <span class="name">upsert</span>
          <span class="type">Boolean</span>
        </dt>
        <dd>
          <p>True to insert a document if no matching documents are found.</p>
        </dd>
      
    </dl>
  

  
</div>


<p>The selector here is just like the one you would pass to <code>find</code>, and can
match multiple documents. The modifier is an object that specifies which
changes should be made to the matched documents. Watch out - unless you use
an operator like <code>$set</code>, <code>update</code> will simply replace the entire matched
document with the modifier.</p>

<p>Here&apos;s an example of setting the <code>content</code> field on all posts whose titles
contain the word &quot;first&quot;:</p>

<pre><code class="hljs css"><span class="hljs-tag">Posts</span><span class="hljs-class">.update</span>(<span class="hljs-rules">{
  <span class="hljs-rule"><span class="hljs-attribute">title</span>:<span class="hljs-value"> {$regex: /first/</span></span></span>}
}, <span class="hljs-rules">{
  <span class="hljs-rule">$<span class="hljs-attribute">set</span>:<span class="hljs-value"> {content: <span class="hljs-string">&quot;Tomorrow will be a great day.&quot;</span></span></span></span>}
});
</code></pre>

<p>You can read about all of the different operators that are supported in the
<a href="http://docs.mongodb.org/manual/reference/operator/update/">MongoDB documentation</a>.</p>

<p>There&apos;s one catch: when you call <code>update</code> on the client, you can only find
documents by their <code>_id</code> field. To use all of the possible selectors, you
must call <code>update</code> in server code or from a <a href="#meteor_methods">method</a>.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-remove" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-remove"><em>collection</em>.remove(selector, [callback])</a>

    
  </h3>

  <div class="desc">
    <p>Remove documents from the collection</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">selector</span>
          <span class="type"><a href="#selectors">Mongo Selector</a>, <a href="#mongo_object_id">Object ID</a>, or String</span>
        </dt>
        <dd>
          <p>Specifies which documents to remove</p>
        </dd>
      
        <dt>
          <span class="name">callback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Optional.  If present, called with an error object as its argument.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>This method uses the same selectors as <code>find</code> and <code>update</code>, and removes
any documents that match the selector from the database. Use <code>remove</code>
carefully &#x2014; there&apos;s no way to get that data back.</p>

<p>As with <code>update</code>, client code can only remove documents by <code>_id</code>, whereas
server code and <a href="#meteor_methods">methods</a> can remove documents using any
selector.</p>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-allow" class="api-title">
    <div class="locus">
      Server
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-allow"><em>collection</em>.allow(options)</a>

    
  </h3>

  <div class="desc">
    <p>Allow users to write directly to this collection from client code, subject to limitations you define.</p>
  </div>

  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">insert, update, remove</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Functions that look at a proposed modification to the database and return true if it should be allowed.</p>
        </dd>
      
    </dl>
  

  
</div>


<p>In newly created apps, Meteor allows almost any calls to <code>insert</code>, <code>update</code>, and
<code>remove</code> from any client or server code. This is because apps started with
<code>meteor create</code> include the <code>insecure</code> package by default to simplify
development. Obviously, if any user could change the database whenever they
wanted it would be bad for security, so it is important to remove the
<code>insecure</code> package and specify some permissions rules, in your terminal:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> remove insecure
</code></pre>

<p>Once you have removed the <code>insecure</code> package, use the <code>allow</code> and <code>deny</code>
methods to control who can perform which operations on the database. By
default, all operations on the client are denied, so we need to add some
<code>allow</code> rules.  Keep in mind that server code and code inside
<a href="#meteor_methods">methods</a> are not affected by <code>allow</code> and <code>deny</code> &#x2014;
these rules only apply when <code>insert</code>, <code>update</code>, and <code>remove</code> are called
from untrusted client code.</p>

<p>For example, we might say that users can only create new posts if the
<code>createdBy</code> field matches the ID of the current user, so that users can&apos;t
impersonate each other.</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// In a file loaded on the server (ignored on the client)</span>
Posts.allow({
  insert: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, post)</span> </span>{
    <span class="hljs-comment">// can only create posts where you are the author</span>
    <span class="hljs-keyword">return</span> post.createdBy === userId;
  },
  remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, post)</span> </span>{
    <span class="hljs-comment">// can only delete your own posts</span>
    <span class="hljs-keyword">return</span> post.createdBy === userId;
  }
  <span class="hljs-comment">// since there is no update field, all updates</span>
  <span class="hljs-comment">// are automatically denied</span>
});
</code></pre>

<p>The <code>allow</code> method accepts three possible callbacks: <code>insert</code>, <code>remove</code>,
and <code>update</code>. The first argument to all three callbacks is the <code>_id</code> of
the logged in user, and the remaining arguments are as follows:</p>

<ol>
<li><p><code>insert(userId, document)</code></p>

<p><code>document</code> is the document that is about to be inserted into the database.
Return <code>true</code> if the insert should be allowed, <code>false</code> otherwise.</p></li>
<li><p><code>update(userId, document, fieldNames, modifier)</code></p>

<p><code>document</code> is the document that is about to be modified. <code>fieldNames</code> is an
array of top-level fields that are affected by this change. <code>modifier</code> is
the <a href="#mongo_modifiers">Mongo Modifier</a> that was passed as the second
argument of <code>collection.update</code>. It can be difficult to achieve correct
validation using this callback, so it is recommended to use
<a href="#meteor_methods">methods</a> instead. Return <code>true</code> if the update should be
allowed, <code>false</code> otherwise.</p></li>
<li><p><code>remove(userId, document)</code></p>

<p><code>document</code> is the document that is about to be removed from the database.
Return <code>true</code> if the document should be removed, <code>false</code> otherwise.</p></li>
</ol>


<div class="api new-api-box">
  <h3 id="/basic/Mongo-Collection-deny" class="api-title">
    <div class="locus">
      Server
    </div>

    <a class="name selflink" href="#/basic/Mongo-Collection-deny"><em>collection</em>.deny(options)</a>

    
  </h3>

  <div class="desc">
    <p>Override <code>allow</code> rules.</p>
  </div>

  

  
    <h4>Options</h4>
    <dl class="args">
      
        <dt>
          <span class="name">insert, update, remove</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Functions that look at a proposed modification to the database and return true if it should be denied, even if an <a href="#allow">allow</a> rule says otherwise.</p>
        </dd>
      
    </dl>
  

  
</div>


<p>The <code>deny</code> method lets you selectively override your <code>allow</code> rules. While
only one of your <code>allow</code> callbacks has to return true to allow a
modification, <em>every one</em> of your <code>deny</code> callbacks has to return false for
the database change to happen.</p>

<p>For example, if we wanted to override part of our <code>allow</code> rule above to exclude
certain post titles:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// In a file loaded on the server (ignored on the client)</span>
Posts.deny({
  insert: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(userId, post)</span> </span>{
    <span class="hljs-comment">// Don&apos;t allow posts with a certain title</span>
    <span class="hljs-keyword">return</span> post.title === <span class="hljs-string">&quot;First!&quot;</span>;
  }
});
</code></pre>
<h2 id="/basic/accounts"><span>Accounts</span></h2>

<p>To get accounts functionality, add one or more of the following packages to
your app with <code>meteor add</code>:</p>

<ul>
<li><code>accounts-ui</code>: This package allows you to use
<code>{{&gt; loginButtons}}</code> in your templates to add an automatically
generated UI that will let users log into your app. There are several
community alternatives to this package that change the appearance, or you
can not use it and use the <a href="#accounts">advanced Accounts methods</a> instead.</li>
<li><code>accounts-password</code>: This package will allow users to log in with passwords.
When you add it the <code>loginButtons</code> dropdown will automatically gain email
and password fields.</li>
<li><code>accounts-facebook</code>, <code>accounts-google</code>, <code>accounts-github</code>, <code>accounts-twitter</code>,
and community packages for other services will allow your users to log
in with their accounts from other websites. These will automatically add
buttons to the <code>loginButtons</code> dropdown.</li>
</ul>

<h3 id="/basic/loginButtons" class="api-title">
  <a class="name selflink" href="#b-loginButtons">{{&gt; loginButtons}}</a>
  <span class="locus">Client</span>
</h3>

<p>Include the <code>loginButtons</code> template somewhere in your HTML to use Meteor&apos;s
default UI for logging in. To use this, you need to add the <code>accounts-ui</code> package,
in your terminal:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> add accounts-ui
</code></pre>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-user" class="api-title">
    <div class="locus">
      Anywhere but publish functions
    </div>

    <a class="name selflink" href="#/basic/Meteor-user">Meteor.user()</a>

    
  </h3>

  <div class="desc">
    <p>Get the current user record, or <code>null</code> if no user is logged in. A reactive data source.</p>
  </div>

  

  

  
</div>


<p>Get the logged in user from the <a href="#meteor_users"><code>Meteor.users</code></a> collection.
Equivalent to <code>Meteor.users.findOne(Meteor.userId())</code>.</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-userId" class="api-title">
    <div class="locus">
      Anywhere but publish functions
    </div>

    <a class="name selflink" href="#/basic/Meteor-userId">Meteor.userId()</a>

    
  </h3>

  <div class="desc">
    <p>Get the current user id, or <code>null</code> if no user is logged in. A reactive data source.</p>
  </div>

  

  

  
</div>



<div class="api new-api-box">
  <h3 id="/basic/Meteor-users" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-users">Meteor.users</a>

    
  </h3>

  <div class="desc">
    <p>A <a href="#collections">Mongo.Collection</a> containing user documents.</p>
  </div>

  

  

  
</div>


<p>This collection contains one document per registered user. Here&apos;s an example
user document:</p>

<pre><code class="hljs objectivec">{
  _<span class="hljs-keyword">id</span>: <span class="hljs-string">&quot;bbca5d6a-2156-41c4-89da-0329e8c99a4f&quot;</span>,  <span class="hljs-comment">// Meteor.userId()</span>
  username: <span class="hljs-string">&quot;cool_kid_13&quot;</span>, <span class="hljs-comment">// unique name</span>
  emails: [
    <span class="hljs-comment">// each email address can only belong to one user.</span>
    { address: <span class="hljs-string">&quot;cool@example.com&quot;</span>, verified: <span class="hljs-literal">true</span> },
    { address: <span class="hljs-string">&quot;another@different.com&quot;</span>, verified: <span class="hljs-literal">false</span> }
  ],
  createdAt: Wed Aug <span class="hljs-number">21</span> <span class="hljs-number">2013</span> <span class="hljs-number">15</span>:<span class="hljs-number">16</span>:<span class="hljs-number">52</span> GMT-<span class="hljs-number">0700</span> (PDT),
  profile: {
    <span class="hljs-comment">// The profile is writable by the user by default.</span>
    name: <span class="hljs-string">&quot;Joe Schmoe&quot;</span>
  },
  services: {
    facebook: {
      <span class="hljs-keyword">id</span>: <span class="hljs-string">&quot;709050&quot;</span>, <span class="hljs-comment">// facebook id</span>
      accessToken: <span class="hljs-string">&quot;AAACCgdX7G2...AbV9AZDZD&quot;</span>
    },
    resume: {
      loginTokens: [
        { token: <span class="hljs-string">&quot;97e8c205-c7e4-47c9-9bea-8e2ccc0694cd&quot;</span>,
          when: <span class="hljs-number">1349761684048</span> }
      ]
    }
  }
}
</code></pre>

<p>A user document can contain any data you want to store about a user. Meteor
treats the following fields specially:</p>

<ul>
<li><code>username</code>: a unique String identifying the user.</li>
<li><code>emails</code>: an Array of Objects with keys <code>address</code> and <code>verified</code>;
an email address may belong to at most one user. <code>verified</code> is
a Boolean which is true if the user has <a href="#accounts_verifyemail">verified the
address</a> with a token sent over email.</li>
<li><code>createdAt</code>: the Date at which the user document was created.</li>
<li><code>profile</code>: an Object which (by default) the user can create
and update with any data.</li>
<li><code>services</code>: an Object containing data used by particular
login services. For example, its <code>reset</code> field contains
tokens used by <a href="#accounts_forgotpassword">forgot password</a> links,
and its <code>resume</code> field contains tokens used to keep you
logged in between sessions.</li>
</ul>

<p>Like all <a href="#collections">Mongo.Collection</a>s, you can access all
documents on the server, but only those specifically published by the server are
available on the client.</p>

<p>By default, the current user&apos;s <code>username</code>, <code>emails</code> and <code>profile</code> are
published to the client. You can publish additional fields for the
current user with:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// server</span>
Meteor.publish(<span class="hljs-string">&quot;userData&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.userId) {
    <span class="hljs-keyword">return</span> Meteor.users.find({_id: <span class="hljs-keyword">this</span>.userId},
                             {fields: {<span class="hljs-string">&apos;other&apos;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&apos;things&apos;</span>: <span class="hljs-number">1</span>}});
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.ready();
  }
});

<span class="hljs-comment">// client</span>
Meteor.subscribe(<span class="hljs-string">&quot;userData&quot;</span>);
</code></pre>

<p>If the autopublish package is installed, information about all users
on the system is published to all clients. This includes <code>username</code>,
<code>profile</code>, and any fields in <code>services</code> that are meant to be public
(eg <code>services.facebook.id</code>,
<code>services.twitter.screenName</code>). Additionally, when using autopublish
more information is published for the currently logged in user,
including access tokens. This allows making API calls directly from
the client for services that allow this.</p>

<p>Users are by default allowed to specify their own <code>profile</code> field with
<a href="#accounts_createuser"><code>Accounts.createUser</code></a> and modify it with
<code>Meteor.users.update</code>. To allow users to edit additional fields, use
<a href="#allow"><code>Meteor.users.allow</code></a>. To forbid users from making any modifications to
their user document:</p>

<pre><code class="hljs javascript">Meteor.users.deny({update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }});
</code></pre>


<div class="api new-api-box">
  <h3 id="/basic/currentUser" class="api-title">
    <div class="locus">
      
    </div>

    <a class="name selflink" href="#/basic/currentUser">{{ currentUser  }}</a>

    
  </h3>

  <div class="desc">
    <p>Calls <a href="#meteor_user">Meteor.user()</a>. Use <code>{{#if currentUser}}</code> to check whether the user is logged in.</p>
  </div>

  

  

  
</div>

<h2 id="/basic/methods"><span>Methods</span></h2>

<p>Methods are server functions that can be called from the client. They are
useful in situations where you want to do something more complicated than
<code>insert</code>, <code>update</code> or <code>remove</code>, or when you need to do data validation that
is difficult to achieve with just <code>allow</code> and <code>deny</code>.</p>

<p>Methods can return values and throw errors.</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-methods" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-methods">Meteor.methods(methods)</a>

    
  </h3>

  <div class="desc">
    <p>Defines functions that can be invoked over the network by clients.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">methods</span>
          <span class="type">Object</span>
        </dt>
        <dd>
          <p>Dictionary whose keys are method names and values are functions.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Calling <code>Meteor.methods</code> on the server defines functions that can be
called remotely by clients. Here&apos;s an example of a method that checks its
arguments and throws an error:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// On the server</span>
Meteor.methods({
  commentOnPost: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(comment, postId)</span> </span>{
    <span class="hljs-comment">// Check argument types</span>
    check(comment, <span class="hljs-built_in">String</span>);
    check(postId, <span class="hljs-built_in">String</span>);

    <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">this</span>.userId) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">&quot;not-logged-in&quot;</span>,
        <span class="hljs-string">&quot;Must be logged in to post a comment.&quot;</span>);
    }

    <span class="hljs-comment">// ... do stuff ...</span>

    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;
  },

  otherMethod: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// ... do other stuff ...</span>
  }
});
</code></pre>

<p>The <a href="#check"><code>check</code></a> function is a convenient way to enforce the expected
<a href="#matchpatterns">types and structure</a> of method arguments.</p>

<p>Inside your method definition, <code>this</code> is bound to a method invocation object,
which has several useful properties, including <code>this.userId</code>, which
identifies the currently logged-in user.</p>

<p>You don&apos;t have to put all your method definitions into a single <code>Meteor.methods</code>
call; you may call it multiple times, as long as each method has a unique name.</p>

<h3 id="/basic/latencycompensation">Latency Compensation</h3>

<p>Calling a method on the server requires a round-trip over the network. It would
be really frustrating if users had to wait a whole second to see their comment
show up due to this delay. That&apos;s why Meteor has a feature called <em>method
stubs</em>. If you define a method on the client with the same name as a server
method, Meteor will run it to attempt to predict the outcome of the server
method. When the code on the server actually finishes, the prediction generated
on the client will be replaced with the actual outcome of the server method.</p>

<p>The client versions of <a href="#insert"><code>insert</code></a>, <a href="#update"><code>update</code></a>, and
<a href="#remove"><code>remove</code></a>, which are implemented as methods, use this feature to make
client-side interactions with the database appear instant.</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-call" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-call">Meteor.call(name, [arg1, arg2...], [asyncCallback])</a>

    
  </h3>

  <div class="desc">
    <p>Invokes a method passing any number of arguments.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>Name of method to invoke</p>
        </dd>
      
        <dt>
          <span class="name">arg1, arg2...</span>
          <span class="type"><a href="#ejson">EJSON-able Object</a></span>
        </dt>
        <dd>
          <p>Optional method arguments</p>
        </dd>
      
        <dt>
          <span class="name">asyncCallback</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>This is how you call a method.</p>

<h3 id="/basic/ontheclient">On the client</h3>

<p>Methods called on the client run asynchronously, so you need to pass a
callback in order to observe the result of the call. The callback will be
called with two arguments, <code>error</code> and <code>result</code>. The <code>error</code> argument will
be <code>null</code> unless an exception was thrown. When an exception is thrown, the
<code>error</code> argument is a <code>Meteor.Error</code> instance and the <code>result</code> argument is
undefined.</p>

<p>Here&apos;s an example of calling the <code>commentOnPost</code> method with arguments
<code>comment</code> and <code>postId</code>:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// Asynchronous call with a callback on the client</span>
Meteor.call(<span class="hljs-string">&apos;commentOnPost&apos;</span>, comment, postId, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error, result)</span> </span>{
  <span class="hljs-keyword">if</span> (error) {
    <span class="hljs-comment">// handle error</span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// examine result</span>
  }
});
</code></pre>

<p>Meteor tracks the database updates performed as part of a method call, and
waits to invoke the client-side callback until all of those updates have
been sent to the client.</p>

<h3 id="/basic/ontheserver">On the server</h3>

<p>On the server, you don&apos;t have to pass a callback &#x2014; the method call
will simply block until the method is complete, returning a result or
throwing an exception, just as if you called the function directly:</p>

<pre><code class="hljs js"><span class="hljs-comment">// Synchronous call on the server with no callback</span>
<span class="hljs-keyword">var</span> result = Meteor.call(<span class="hljs-string">&apos;commentOnPost&apos;</span>, comment, postId);
</code></pre>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-Error" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-Error">new Meteor.Error(error, [reason], [details])</a>

    
  </h3>

  <div class="desc">
    <p>This class represents a symbolic error thrown by a method.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">error</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>A string code uniquely identifying this kind of error.
This string should be used by callers of the method to determine the
appropriate action to take, instead of attempting to parse the reason
or details fields. For example:</p>
<pre class="prettyprint source"><code class="hljs javascript"><span class="hljs-comment">// on the server, pick a code unique to this error</span>
<span class="hljs-comment">// the reason field should be a useful debug message</span>
<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">&quot;logged-out&quot;</span>, 
  <span class="hljs-string">&quot;The user must be logged in to post a comment.&quot;</span>);

<span class="hljs-comment">// on the client</span>
Meteor.call(<span class="hljs-string">&quot;methodName&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(error)</span> </span>{
  <span class="hljs-comment">// identify the error</span>
  <span class="hljs-keyword">if</span> (error &amp;&amp; error.error === <span class="hljs-string">&quot;logged-out&quot;</span>) {
    <span class="hljs-comment">// show a nice error message</span>
    Session.set(<span class="hljs-string">&quot;errorMessage&quot;</span>, <span class="hljs-string">&quot;Please log in to post a comment.&quot;</span>);
  }
});</code></pre><p>For legacy reasons, some built-in Meteor functions such as <code>check</code> throw
errors with a number in this field.</p>
        </dd>
      
        <dt>
          <span class="name">reason</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>Optional.  A short human-readable summary of the
error, like &apos;Not Found&apos;.</p>
        </dd>
      
        <dt>
          <span class="name">details</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>Optional.  Additional information about the error,
like a textual stack trace.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>If you want to return an error from a method, throw an exception.  Methods can
throw any kind of exception, but <code>Meteor.Error</code> is the only kind of error that
will be sent to the client. If a method function throws a different exception,
the client gets <code>Meteor.Error(500, &apos;Internal server error&apos;)</code>.</p>
<h2 id="/basic/pubsub"><span>Publish and subscribe</span></h2>

<p>Meteor servers can publish sets of documents with <code>Meteor.publish</code>, and
clients can subscribe to those publications with <code>Meteor.subscribe</code>. Any
documents the client subscribes to will be available through the <code>find</code>
method of client collections.</p>

<p>By default, every newly created Meteor app contains the <code>autopublish</code>
package, which automatically publishes all available documents to every
client. To exercise finer-grained control over what documents different
clients receive, first remove <code>autopublish</code>, in your terminal:</p>

<pre><code class="hljs nginx"><span class="hljs-title">meteor</span> remove autopublish
</code></pre>

<p>Now you can use <code>Meteor.publish</code> and <code>Meteor.subscribe</code> to control what
documents flow from the server to its clients.</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-publish" class="api-title">
    <div class="locus">
      Server
    </div>

    <a class="name selflink" href="#/basic/Meteor-publish">Meteor.publish(name, func)</a>

    
  </h3>

  <div class="desc">
    <p>Publish a record set.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>Name of the record set.  If <code>null</code>, the set has no name, and the record set is automatically sent to all connected clients.</p>
        </dd>
      
        <dt>
          <span class="name">func</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>Function called on the server each time a client subscribes.  Inside the function, <code>this</code> is the publish handler object, described below.  If the client passed arguments to <code>subscribe</code>, the function is called with the same arguments.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>To publish data to clients, call <code>Meteor.publish</code> on the server with two
arguments: the name of the record set, and a <em>publish function</em> that will
be called each time a client subscribes to this record set.</p>

<p>Publish functions typically return the result of calling
<code>collection.find(query)</code> on some <code>collection</code> with a <code>query</code> that narrows
down the set of documents to publish from that collection:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// Publish the logged in user&apos;s posts</span>
Meteor.publish(<span class="hljs-string">&quot;posts&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> Posts.find({ createdBy: <span class="hljs-keyword">this</span>.userId });
});
</code></pre>

<p>You can publish documents from multiple collections by returning an array
of <code>collection.find</code> results:</p>

<pre><code class="hljs javascript"><span class="hljs-comment">// Publish a single post and its comments</span>
Meteor.publish(<span class="hljs-string">&quot;postAndComments&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(postId)</span> </span>{
  <span class="hljs-comment">// Check argument</span>
  check(postId, <span class="hljs-built_in">String</span>);

  <span class="hljs-keyword">return</span> [
    Posts.find({ _id: postId }),
    Comments.find({ postId: roomId })
  ];
});
</code></pre>

<p>Inside the publish function, <code>this.userId</code> is the current logged-in user&apos;s
<code>_id</code>, which can be useful for filtering collections so that certain
documents are visible only to certain users. If the logged-in user changes
for a particular client, the publish function will be automatically rerun
with the new <code>userId</code>, so the new user will not have access to any
documents that were meant only for the previous user.</p>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-subscribe" class="api-title">
    <div class="locus">
      Client
    </div>

    <a class="name selflink" href="#/basic/Meteor-subscribe">Meteor.subscribe(name, [arg1, arg2...], [callbacks])</a>

    
  </h3>

  <div class="desc">
    <p>Subscribe to a record set.  Returns a handle that provides
<code>stop()</code> and <code>ready()</code> methods.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">name</span>
          <span class="type">String</span>
        </dt>
        <dd>
          <p>Name of the subscription.  Matches the name of the
server&apos;s <code>publish()</code> call.</p>
        </dd>
      
        <dt>
          <span class="name">arg1, arg2...</span>
          <span class="type">Any</span>
        </dt>
        <dd>
          <p>Optional arguments passed to publisher
function on server.</p>
        </dd>
      
        <dt>
          <span class="name">callbacks</span>
          <span class="type">Function or Object</span>
        </dt>
        <dd>
          <p>Optional. May include <code>onStop</code>
and <code>onReady</code> callbacks. If there is an error, it is passed as an
argument to <code>onStop</code>. If a function is passed instead of an object, it
is interpreted as an <code>onReady</code> callback.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>Clients call <code>Meteor.subscribe</code> to express interest in document
collections published by the server. Clients can further filter these
collections of documents by calling <a href="#find"><code>collection.find(query)</code></a>.
Whenever any data that was accessed by a publish function changes on the
server, the publish function is automatically rerun and the updated
document collections are pushed to the subscribed client.</p>

<p>The <code>onReady</code> callback is called with no arguments when the server has sent all
of the initial data for the subscription. The <code>onStop</code> callback is when the
subscription is terminated for any reason; it receives a
<a href="#meteor_error"><code>Meteor.Error</code></a> if the subscription failed due to a server-side
error.</p>

<p><code>Meteor.subscribe</code> returns a subscription handle, which is an object with the
following methods:</p>

<dl class="callbacks">


  
    <dt><span class="name">stop()</span></dt>
  
  <dd><p>Cancel the subscription. This will typically result in the server directing the
client to remove the subscription&apos;s data from the client&apos;s cache.</p></dd>



  
    <dt><span class="name">ready()</span></dt>
  
  <dd><p>Returns true if the server has <a href="#publish_ready">marked the subscription as
ready</a>. A reactive data source.</p></dd>
</dl>

<p>If you call <code>Meteor.subscribe</code> inside
<a href="#tracker_autorun"><code>Tracker.autorun</code></a>, the subscription will be cancelled
automatically whenever the computation reruns (so that a new subscription
can be created, if appropriate), meaning you don&apos;t have to to call <code>stop</code>
on subscriptions made from inside <code>Tracker.autorun</code>.</p>
<h2 id="/basic/environment"><span>Environment</span></h2>

<p>
<div class="api new-api-box">
  <h3 id="/basic/Meteor-isClient" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-isClient">Meteor.isClient</a>

    
  </h3>

  <div class="desc">
    <p>Boolean variable.  True if running in client environment.</p>
  </div>

  

  

  
</div>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-isServer" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-isServer">Meteor.isServer</a>

    
  </h3>

  <div class="desc">
    <p>Boolean variable.  True if running in server environment.</p>
  </div>

  

  

  
</div>
</p>

<div class="note">
  <p>
<code>Meteor.isServer</code> can be used to limit where code runs, but it does
not prevent code from being sent to the client. Any sensitive code that you
don&apos;t want served to the client, such as code containing passwords or
authentication mechanisms, should be kept in the <code>server</code> directory.
</p>
</div>


<div class="api new-api-box">
  <h3 id="/basic/Meteor-startup" class="api-title">
    <div class="locus">
      Anywhere
    </div>

    <a class="name selflink" href="#/basic/Meteor-startup">Meteor.startup(func)</a>

    
  </h3>

  <div class="desc">
    <p>Run code when a client or a server starts.</p>
  </div>

  
    <h4>Arguments</h4>
    <dl class="args">
      
        <dt>
          <span class="name">func</span>
          <span class="type">Function</span>
        </dt>
        <dd>
          <p>A function to run on startup.</p>
        </dd>
      
    </dl>
  

  

  
</div>


<p>On the server, the callback function will run as soon as the server
process is finished starting up. On the client, the callback function will
run as soon as the page is ready.</p>

<p>It&apos;s good practice to wrap all code that isn&apos;t inside template events,
template helpers, <code>Meteor.methods</code>, <code>Meteor.publish</code>, or
<code>Meteor.subscribe</code> in <code>Meteor.startup</code> so that your application code isn&apos;t
executed before the environment is ready.</p>

<p>For example, to create some initial data if the database is empty when the
server starts up, you might use the following pattern:</p>

<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (Meteor.isServer) {
  Meteor.startup(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">if</span> (Rooms.find().count() === <span class="hljs-number">0</span>) {
      Rooms.insert({name: <span class="hljs-string">&quot;Initial room&quot;</span>});
    }
  });
}
</code></pre>

<p>If you call <code>Meteor.startup</code> on the server after the server process has
started up, or on the client after the page is ready, the callback will
fire immediately. <!-- XXX It should still fire asynchronously, though --></p><p></p>
  <h2 id="/basic/packages"><span>Packages</span></h2>

<p>All of Meteor&apos;s functionality is implemented in modular packages. In addition
to the core packages documented above, there are many others that you can add to
your app to enable useful functionality.</p>

<p>From the command line, you can add and remove packages with <code>meteor add</code>
and <code>meteor remove</code>:</p>

<pre><code class="hljs bash"><span class="hljs-comment"># add the less package</span>
meteor add less

<span class="hljs-comment"># remove the less package</span>
meteor remove less
</code></pre>

<p>Your app will restart itself automatically when you add or remove a
package.  An app&apos;s package dependencies are tracked in <code>.meteor/packages</code>,
so your collaborators will be automatically updated to the same set of
installed packages as you after they pull your source code, because they
have the same <code>.meteor/packages</code> file as you.</p>

<p>You can see which packages are used by your app by running <code>meteor list</code>
in the app&apos;s directory.</p>

<h2 id="/basic/searchingforpackages">Searching for packages</h2>

<p>Currently the best way to search for packages available from the official
Meteor package server is <a href="https://atmospherejs.com/?__hstc=256467284.06c0d3fa064611691d66d2c578e27182.1445920650574.1445920650574.1445920650574.1&amp;__hssc=256467284.1.1445920650574&amp;__hsfp=1614345591">Atmosphere</a>, the
community package search website maintained by Percolate Studio. You can
also search for packages directly using the <code>meteor search</code> command.</p>

<p>Packages that have a <code>:</code> in the name, such as <code>mquandalle:jade</code>, are written and
maintained by community members. The prefix before the colon is the name of the
user or organization who created that package. Unprefixed packages are
maintained by Meteor Development Group as part of the Meteor framework.</p>

<p>There are currently over 2000 packages available on Atmosphere. Below is a small
selection of some of the most useful packages.</p>

<h2 id="/basic/accountsui">accounts-ui</h2>

<p>This is a drop-in user interface to Meteor&apos;s accounts system. After adding the
package, include it in your templates with <code>{{&gt; loginButtons}}</code>. The UI
automatically adapts to include controls for any added login services, such as
<code>accounts-password</code>, <code>accounts-facebook</code>, etc.</p>

<p><a href="#/basic/accounts">See the docs about accounts-ui above.</a>.</p>

<h2 id="/basic/coffeescript">coffeescript</h2>

<p>Use <a href="http://coffeescript.org/">CoffeeScript</a> in your app. With this package, any
files with a <code>.coffee</code> extension will be compiled to JavaScript by Meteor&apos;s
build system.</p>

<h2 id="/basic/email">email</h2>

<p>Send emails from your app. See the <a href="#/full/email">email section of the full API
docs</a>.</p>

<h2 id="/basic/jade">mquandalle:jade</h2>

<p>Use the <a href="http://jade-lang.com/">Jade</a> templating language in your app. After
adding this package, any files with a <code>.jade</code> extension will be compiled into
Meteor templates. See the <a href="https://atmospherejs.com/mquandalle/jade?__hstc=256467284.06c0d3fa064611691d66d2c578e27182.1445920650574.1445920650574.1445920650574.1&amp;__hssc=256467284.1.1445920650574&amp;__hsfp=1614345591">page on
Atmosphere</a> for details.</p>

<h2 id="/basic/jquery">jquery</h2>

<p>JQuery makes HTML traversal and manipulation, event handling, and animation
easy with a simple API that works across most browsers.</p>

<p>JQuery is automatically included in every Meteor app since the framework uses it
extensively. See the <a href="http://jquery.com/">JQuery docs</a> for more details.</p>

<h2 id="/basic/http">http</h2>

<p>This package allows you to make HTTP requests from the client or server using
the same API. See the <a href="#/full/http">http docs</a> to see how to use it.</p>

<h2 id="/basic/less">less</h2>

<p>Add the <a href="http://lesscss.org/">LESS</a> CSS preprocessor to your app to
compile any files with a <code>.less</code> extension into standard CSS. If you want
to use <code>@import</code> to include other files and not have Meteor automatically
compile them, use the <code>.import.less</code> extension.</p>

<h2 id="/basic/markdown">markdown</h2>

<p>Include <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a>
code in your templates. It&apos;s as easy as using the <code>{{#
markdown}}</code> helper:</p>

<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">class</span>=<span class="hljs-value">&quot;my-div&quot;</span>&gt;</span>
{{#markdown}}
# My heading

Some paragraph text
{{/markdown}}
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
</code></pre>

<p>Just make sure to keep your markdown unindented, since whitespace matters.</p>

<h2 id="/basic/underscore">underscore</h2>

<p><a href="http://underscorejs.org/">Underscore</a> provides a collection of useful functions
to manipulate arrays, objects, and functions. <code>underscore</code> is included in every
Meteor app because the framework itself uses it extensively.</p>

<h2 id="/basic/spiderable">spiderable</h2>

<p>This package gives your app server-side rendering to allow search engine
crawlers and other bots see your app&apos;s contents. If you care about SEO, you
should add this package.</p>

  <h1 id="checkoutthefullapidocs">Check out the Full API Docs</h1>

<p>Congratulations, you&apos;re at the end of the Meteor basic documentation. For more
advanced features and more specific explanations, check out the <a href="#/full/">Full API
Docs</a>.</p>

  <a href="http://meteor.com">
    <img src="http://docs.meteor.com/logo.png" style="width: 100%; max-width: 300px">
  </a>
        </div>
      </div>
    </div>
  </div>
  
</body></html>
